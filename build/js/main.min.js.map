{"version":3,"sources":["node_modules/browser-pack/_prelude.js","source/js/accordions.js","source/js/init-accordion.js","source/js/init-tabs.js","source/js/main.js","source/js/modules/form-validate/callback.js","source/js/modules/form-validate/form.js","source/js/modules/form-validate/init-phone-input.js","source/js/modules/form-validate/matrix.js","source/js/modules/form-validate/regular-expression.js","source/js/modules/form-validate/render-message.js","source/js/modules/form-validate/validator.js","source/js/modules/modals/init-modals.js","source/js/modules/modals/modals.js","source/js/tabs.js","source/js/utils/focus-lock.js","source/js/utils/ios-checker.js","source/js/utils/ios-vh-fix.js","source/js/utils/scroll-lock.js","source/js/vendor/swiper.js"],"names":[],"mappings":"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AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA,OAAA,CAAA,eAAA,GAAA,eAAA","file":"main.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","export class Accordions {\n  constructor() {\n    this._openHeight = 0;\n    this._windowWidth = window.innerWidth;\n    this._documentClickHandler = this._documentClickHandler.bind(this);\n    this._windowResizeHandler = this._windowResizeHandler.bind(this);\n    this._init();\n  }\n\n  _init() {\n    this.fullUpdate();\n    document.addEventListener('click', this._documentClickHandler);\n    window.addEventListener('resize', this._windowResizeHandler);\n  }\n\n  _documentClickHandler(evt) {\n    const target = evt.target;\n    if (!target.closest('[data-accordion=\"button\"]')) {\n      return;\n    }\n\n    evt.preventDefault();\n    const parent = target.closest('[data-accordion=\"parent\"]');\n\n    if (parent.dataset.destroy && !window.matchMedia(parent.dataset.destroy).matches) {\n      return;\n    }\n\n    const element = target.closest('[data-accordion=\"element\"]');\n    if (element.classList.contains('is-active')) {\n      this.closeAccordion(element);\n      return;\n    }\n    this.openAccordion(element);\n  }\n\n  _windowResizeHandler() {\n    if (this._windowWidth === window.innerWidth) {\n      return;\n    }\n    this._windowWidth = window.innerWidth;\n    this.updateAccordionsHeight();\n  }\n\n  closeAllAccordion(parent) {\n    const elements = parent.querySelectorAll('[data-accordion=\"element\"]');\n    elements.forEach((element) => {\n      const currentParent = element.closest('[data-accordion=\"parent\"]');\n      if (currentParent === parent) {\n        this.closeAccordion(element);\n      }\n    });\n  }\n\n  updateAccordionsHeight(element = null) {\n    if (element) {\n      const content = element.querySelector('[data-accordion=\"content\"]');\n      content.style.transition = 'none';\n      content.style.maxHeight = `${content.scrollHeight}px`;\n      setTimeout(() => {\n        content.style.transition = null;\n      });\n      return;\n    }\n\n    const closeElements = document.querySelectorAll('[data-accordion=\"element\"]:not(.is-active)');\n\n    closeElements.forEach((closeElement) => {\n      const parent = closeElement.closest('[data-accordion=\"parent\"]');\n      const content = closeElement.querySelector('[data-accordion=\"content\"]');\n      if (parent.dataset.destroy && !window.matchMedia(parent.dataset.destroy).matches) {\n        content.style.maxHeight = '100%';\n        return;\n      }\n      content.style.maxHeight = null;\n    });\n\n    const openElements = document.querySelectorAll('[data-accordion=\"element\"].is-active');\n    openElements.forEach((openElement) => {\n      const content = openElement.querySelector('[data-accordion=\"content\"]');\n      const parent = openElement.closest('[data-accordion=\"parent\"]');\n      if (parent.dataset.destroy && !window.matchMedia(parent.dataset.destroy).matches) {\n        content.style.maxHeight = '100%';\n        return;\n      }\n      content.style.transition = 'none';\n      content.style.maxHeight = `${content.scrollHeight}px`;\n      setTimeout(() => {\n        content.style.transition = null;\n      });\n    });\n  }\n\n  fullUpdate(parent = null, transition = false) {\n    let openElements;\n    if (parent) {\n      openElements = parent.querySelectorAll('[data-accordion=\"element\"].is-active');\n    } else {\n      openElements = document.querySelectorAll('[data-accordion=\"element\"].is-active');\n    }\n    openElements.forEach((openElement) => {\n      const innerParent = openElement.querySelector('[data-accordion=\"parent\"]');\n      if (innerParent) {\n        return;\n      }\n      this.openAccordion(openElement, transition);\n    });\n    this.updateAccordionsHeight();\n  }\n\n  openAccordion(element, transition = true) {\n    const parentElement = element.closest('[data-accordion=\"parent\"]');\n    const contentElement = element.querySelector('[data-accordion=\"content\"]');\n    this._openHeight += contentElement.scrollHeight;\n\n    if (parentElement.hasAttribute('data-single')) {\n      this.closeAllAccordion(parentElement);\n    }\n\n    element.classList.add('is-active');\n    if (transition) {\n      contentElement.style.maxHeight = `${this._openHeight}px`;\n    } else {\n      contentElement.style.transition = 'none';\n      contentElement.style.maxHeight = `${this._openHeight}px`;\n      setTimeout(() => {\n        contentElement.style.transition = null;\n      });\n    }\n\n    if (parentElement.closest('[data-accordion=\"element\"]')) {\n      this.openAccordion(parentElement.closest('[data-accordion=\"element\"]'), transition);\n      return;\n    }\n\n    this._openHeight = 0;\n  }\n\n  closeAccordion(element, transition = true) {\n    const contentElement = element.querySelector('[data-accordion=\"content\"]');\n    if (!contentElement) {\n      return;\n    }\n    element.classList.remove('is-active');\n    if (transition) {\n      contentElement.style.maxHeight = '0';\n    } else {\n      contentElement.style.transition = 'none';\n      contentElement.style.maxHeight = '0';\n      setTimeout(() => {\n        contentElement.style.transition = null;\n      });\n    }\n  }\n}\n","import {Accordions} from './accordions';\nlet accordions;\n\nconst initAccordions = () => {\n  accordions = new Accordions();\n  //      accordions, window   \n  window.accordions = accordions;\n};\n\nexport {initAccordions, accordions};\n","import {Tabs} from './tabs';\n\nlet tabs;\n\nconst initTabs = () => {\n  tabs = new Tabs();\n  //      tabs, window   \n  window.tabs = tabs;\n};\n\nexport {initTabs, tabs};\n","import {iosVhFix} from './utils/ios-vh-fix';\nimport {initModals} from './modules/modals/init-modals';\nimport {Form} from './modules/form-validate/form';\nimport {createNewSlider} from './vendor/swiper';\nimport {initTabs} from './init-tabs';\nimport {initAccordions} from './init-accordion';\n\n// ---------------------------------\n\nwindow.addEventListener('DOMContentLoaded', () => {\n\n  // Utils\n  initAccordions();\n  iosVhFix();\n  createNewSlider();\n  initTabs();\n\n  // Modules\n  // ---------------------------------\n\n  //       'DOMContentLoaded',     'load'\n  //  load   ,      \n  window.addEventListener('load', () => {\n\n    initModals();\n    const form = new Form();\n    window.form = form;\n    form.init();\n  });\n});\n\n// ---------------------------------\n\n//     eslint, stylelint, editorconfig   .\n\n//  js   ,     (data-validate)\n\n//   .block--active   \n// .is-active || .is-open || .is-invalid   (    )\n// .select.select--opened  ---> [data-select].is-open \n\n//     \n// url    ,   , url  json  ..\n\n//   JS  matchMedia  addListener\n// const breakpoint = window.matchMedia(`(min-width:1024px)`);\n// const breakpointChecker = () => {\n//   if (breakpoint.matches) {\n//   } else {\n//   }\n// };\n// breakpoint.addListener(breakpointChecker);\n// breakpointChecker();\n\n//  .closest(el)\n","\nconst baseSuccessCallback = (event) => {\n  event.preventDefault();\n  //    ,                      \n};\n\nconst baseErrorCallback = (event) => {\n  event.preventDefault();\n  //       -         ,       \n};\n\nexport const callbacks = {\n  base: {\n    //  \n    reset: true,\n    //   \n    resetTimeout: 500,\n    successCallback: baseSuccessCallback,\n    errorCallback: baseErrorCallback,\n  },\n};\n","import {Validator} from './validator';\nimport {callbacks} from './callback';\nimport {initPhoneInput} from './init-phone-input';\n\nexport class Form {\n  constructor() {\n    this._validator = new Validator();\n    this._initPhoneInput = initPhoneInput;\n    this._callbacks = callbacks;\n  }\n\n  _resetSelect(select) {\n    const nativeSelect = select.querySelector('select');\n    const activeIndex = nativeSelect.options.selectedIndex;\n    const selectedOption = nativeSelect.options[activeIndex];\n    const buttonText = select.querySelector('.custom-select__text');\n    const selectItems = select.querySelectorAll('.custom-select__item');\n    buttonText.textContent = selectedOption.textContent;\n    selectItems.forEach((item, index) => {\n      if (index === activeIndex - 1) {\n        item.setAttribute('aria-selected', 'true');\n        return;\n      }\n      item.setAttribute('aria-selected', 'false');\n    });\n    if (!nativeSelect.value) {\n      select.classList.remove('not-empty');\n      select.classList.remove('is-valid');\n    }\n  }\n\n  _resetSelects(form) {\n    const selects = form.querySelectorAll('[data-select]');\n    selects.forEach((select) => {\n      this._resetSelect(select);\n    });\n  }\n\n  reset(form) {\n    form.reset();\n    form.querySelectorAll('.is-invalid').forEach((item) => item.classList.remove('is-invalid'));\n    form.querySelectorAll('.is-valid').forEach((item) => item.classList.remove('is-valid'));\n    form.querySelectorAll('.input-message').forEach((item) => item.remove());\n    setTimeout(() => {\n      this._resetSelects(form);\n    });\n  }\n\n  initPhoneInput(parent) {\n    this._initPhoneInput(parent);\n  }\n\n  validateForm(form) {\n    return this._validator.validateForm(form);\n  }\n\n  validateFormElement(item) {\n    return this._validator.validateFormElement(item);\n  }\n\n  _onFormSubmit(event, callback = null) {\n    if (this.validateForm(event.target) && callback) {\n      this._callbacks[callback].successCallback(event);\n      if (this._callbacks[callback].reset) {\n        setTimeout(() => {\n          this.reset(event.target);\n        }, this._callbacks[callback].resetTimeout ? this._callbacks[callback].resetTimeout : 500);\n      }\n      return;\n    }\n    if (!this.validateForm(event.target) && callback) {\n      this._callbacks[callback].errorCallback(event);\n      return;\n    }\n  }\n\n  _onFormInput(item) {\n    this.validateFormElement(item);\n  }\n\n  _initValidate(parent) {\n    const form = parent.querySelector('form');\n    if (!form) {\n      return;\n    }\n\n    const phoneParents = form.querySelectorAll('[data-validate-type=\"phone\"]');\n    phoneParents.forEach((item) => this._initPhoneInput(item));\n\n    const callback = parent.dataset.callback;\n    form.noValidate = true;\n\n    form.addEventListener('submit', (event) => {\n      event.preventDefault();\n      this._onFormSubmit(event, callback);\n    });\n\n    form.addEventListener('input', (event) => {\n      this._onFormInput(event.target);\n    });\n\n    form.addEventListener('reset', (event) => {\n      this.reset(event.target);\n    });\n  }\n\n  init() {\n    this._validateParent = document.querySelectorAll('[data-form-validate]');\n    if (!this._validateParent.length) {\n      return;\n    }\n    this._validateParent.forEach((parent) => this._initValidate(parent));\n  }\n}\n","const baseCountryCode = '+7';\nconst baseMatrix = ' (___) ___ __ __';\nconst phoneLength = baseCountryCode.length + baseMatrix.length;\n\nconst onPhoneInputInput = (e) => {\n  const matrix = `${baseCountryCode}${baseMatrix}`;\n  const def = matrix.replace(/\\D/g, '');\n  let i = 0;\n  let val = e.target.value.replace(/\\D/g, '');\n  if (def.length >= val.length) {\n    val = def;\n  }\n  e.target.value = matrix.replace(/./g, (a) => {\n    if (/[_\\d]/.test(a) && i < val.length) {\n      return val.charAt(i++);\n    } else if (i >= val.length) {\n      return '';\n    } else {\n      return a;\n    }\n  });\n};\n\nconst onPhoneInputFocus = ({target}) => {\n  if (!target.value) {\n    target.value = baseCountryCode;\n  }\n  target.addEventListener('input', onPhoneInputInput);\n  target.addEventListener('blur', onPhoneInputBlur);\n  target.addEventListener('keydown', onPhoneInputKeydown);\n  target.addEventListener('paste', onPhoneInputPaste);\n  target.addEventListener('click', onPhoneInputClick);\n};\n\nconst onPhoneInputClick = (e) => {\n  if (e.target.selectionStart < 4) {\n    e.preventDefault();\n    e.target.setSelectionRange(3, 3);\n  }\n};\n\nconst onPhoneInputPaste = (e) => {\n  e.target.setSelectionRange(0, 0);\n  if (!e.target.selectionStart) {\n    setTimeout(() => {\n      if (e.target.value.startsWith('+7')) {\n        return;\n      }\n      if (e.target.value.startsWith('+8')) {\n        e.target.value = `+7 ${e.target.value.slice(3)}`;\n        return;\n      }\n      e.target.value = '';\n    });\n  }\n};\n\nconst onPhoneInputKeydown = (e) => {\n  if (e.target.selectionStart < 4 && (e.keyCode === 37 || e.keyCode === 13)) {\n    e.preventDefault();\n    e.target.setSelectionRange(3, 3);\n  }\n};\n\nconst onPhoneInputBlur = ({target}) => {\n  if (target.value === baseCountryCode) {\n    const parent = target.closest('[data-validate-type=\"phone\"]');\n    target.value = '';\n    if (!parent.hasAttribute('data-required')) {\n      parent.classList.remove('is-valid');\n      parent.classList.remove('is-invalid');\n      const parentMessage = parent.querySelector('.input-message');\n      if (parentMessage) {\n        parentMessage.remove();\n      }\n    }\n    parent.classList.remove('not-empty');\n    target.removeEventListener('input', onPhoneInputInput);\n    target.removeEventListener('blur', onPhoneInputBlur);\n    target.removeEventListener('keydown', onPhoneInputKeydown);\n    target.removeEventListener('paste', onPhoneInputPaste);\n    target.removeEventListener('click', onPhoneInputClick);\n  }\n};\n\nexport const initPhoneInput = (parent) => {\n  const input = parent.querySelector('input');\n  parent.dataset.phoneLength = phoneLength;\n  input.addEventListener('focus', onPhoneInputFocus);\n};\n","export const matrixReplace = (item, matrix, RegEx) => {\n  if (!matrix) {\n    // eslint-disable-next-line no-console\n    console.error('       : data-matrix=\"\"');\n    item.value = '';\n    return;\n  }\n\n  if (!RegEx) {\n    // eslint-disable-next-line no-console\n    console.error('       : data-matrix-limitations=\"\"');\n    item.value = '';\n    return;\n  }\n\n  const def = matrix.replace(RegEx, '');\n  let val = item.value.replace(RegEx, '');\n  let i = 0;\n\n  if (def.length >= val.length) {\n    val = def;\n  }\n\n  item.value = matrix.replace(/./g, (a) => {\n    if (/[_\\^]/.test(a) && i < val.length) {\n      return val.charAt(i++);\n    } else if (i >= val.length) {\n      return '';\n    } else {\n      return a;\n    }\n  });\n};\n","const setLimitationError = (limitation) => {\n  // eslint-disable-next-line no-console\n  console.error(`  (data-limitation=\"${limitation}\") -  .    .`);\n};\n\nexport const getLimitationsRegEx = (limitation) => {\n  switch (limitation) {\n    case 'digit':\n      return /[^\\d]/g;\n    case 'name':\n      return /[^a-zA-Z--\\-\\s]/g;\n    case 'letters':\n      return /[^a-zA-Z--\\s]/g;\n    case 'letters-and-digit':\n      return /[^a-zA-Z--\\s\\d]/g;\n    case 'cyrillic':\n      return /[^--\\s]/g;\n    case 'latin':\n      return /[^a-zA-Z\\s]/g;\n    default:\n      return setLimitationError(limitation);\n  }\n};\n\nexport const getMatrixLimitationsRegEx = (matrix) => {\n  switch (matrix) {\n    case 'digit':\n      return /[^\\d]/g;\n    case 'name':\n      return /[^\\-\\-\\a-z\\A-Z\\-]]/g;\n    case 'letters':\n      return /[^\\-\\-\\a-z\\A-Z]/g;\n    case 'letters-and-digit':\n      return /[^\\-\\-\\a-z\\A-Z\\d]/g;\n    case 'cyrillic':\n      return /[^\\-\\-]/g;\n    case 'latin':\n      return /[^\\a-z\\A-Z]/g;\n    default:\n      return false;\n  }\n};\n\nexport const getMailRegEx = () => /[a-zA-Z--0-9]{1}([a-zA-Z--0-9\\-_\\.]{1,})?@[a-zA-Z--0-9\\-]{1}([a-zA-Z--0-9.\\-]{1,})?[a-zA-Z--0-9\\-]{1}\\.[a-zA-Z--]{2,6}/;\n","export class Message {\n  constructor() {\n    this._baseErrorText = '   ';\n  }\n\n  _messageTemplate(message, state) {\n    const cssClass = state === 'valid' ? 'is-valid' : 'is-invalid';\n    return `<span class=\"input-message ${cssClass}\">${message}</span>`;\n  }\n\n  removeMessage(parent) {\n    const parentMessage = parent.querySelector('.input-message');\n    if (parentMessage) {\n      parentMessage.remove();\n    }\n  }\n\n  renderMessage(parent, message, state) {\n    this.removeMessage(parent);\n    parent.insertAdjacentHTML('beforeend', this._messageTemplate(message, state));\n  }\n}\n","import {getLimitationsRegEx, getMatrixLimitationsRegEx, getMailRegEx} from './regular-expression';\nimport {matrixReplace} from './matrix';\nimport {Message} from './render-message';\n\nexport class Validator {\n  constructor() {\n    this._getLimitationsRegEx = getLimitationsRegEx;\n    this._getMatrixLimitationsRegEx = getMatrixLimitationsRegEx;\n    this._getMailRegEx = getMailRegEx;\n    this._matrixReplace = matrixReplace;\n    this._message = new Message();\n  }\n\n  _renderMessage(trigger, parent, input) {\n    if (!parent.hasAttribute('data-required') && !input.value) {\n      return;\n    }\n    if (!trigger) {\n      parent.classList.add('is-invalid');\n      if (parent.hasAttribute('data-message-base') && !input.value) {\n        this._message.renderMessage(parent, parent.dataset.messageBase, 'invalid');\n      } else if (parent.hasAttribute('data-message-extra') && input.value) {\n        this._message.renderMessage(parent, parent.dataset.messageExtra, 'invalid');\n      } else if (!parent.hasAttribute('data-message-extra') && parent.hasAttribute('data-message-base') && input.value) {\n        this._message.renderMessage(parent, parent.dataset.messageBase, 'invalid');\n      } else {\n        this._message.removeMessage(parent);\n      }\n    } else {\n      if (parent.hasAttribute('data-message-success')) {\n        this._message.renderMessage(parent, parent.dataset.messageSuccess, 'valid');\n      } else {\n        this._message.removeMessage(parent);\n      }\n    }\n  }\n\n  _setItemValidState(parent, input) {\n    if (!parent.hasAttribute('data-required') && !input.value) {\n      return;\n    }\n    parent.classList.add('is-valid');\n    parent.classList.remove('is-invalid');\n    input.setAttribute('aria-invalid', 'false');\n    this._message.removeMessage(parent);\n  }\n\n  _setItemInvalidState(parent, input) {\n    if (!parent.hasAttribute('data-required') && !input.value) {\n      return;\n    }\n    parent.classList.remove('is-valid');\n    input.setAttribute('aria-invalid', 'true');\n  }\n\n  _simpleLimitation(item, limitation) {\n    item.value = item.value.replace(this._getLimitationsRegEx(limitation), '');\n  }\n\n  _matrixLimitation(item, matrix, limitation) {\n    this._matrixReplace(item, matrix, limitation);\n  }\n\n  _validateTextInput(parent, input) {\n    let flag = true;\n    if (input.value.length >= (+input.getAttribute('minlength') || 1)) {\n      this._setItemValidState(parent, input);\n    } else {\n      this._setItemInvalidState(parent, input);\n      flag = false;\n    }\n    return flag;\n  }\n\n  _validateMatrixInput(parent, input) {\n    let flag = true;\n    if (input.value.length === input.closest('[data-matrix]').dataset.matrix.length) {\n      this._setItemValidState(parent, input);\n    } else {\n      this._setItemInvalidState(parent, input);\n      flag = false;\n    }\n    return flag;\n  }\n\n  _validateEmailInput(parent, input) {\n    let flag = true;\n    if (new RegExp(this._getMailRegEx(), '').test(input.value)) {\n      this._setItemValidState(parent, input);\n    } else {\n      this._setItemInvalidState(parent, input);\n      flag = false;\n    }\n    return flag;\n  }\n\n  _validatePhoneInput(parent, input) {\n    let flag = true;\n    if (input.value.length >= +parent.dataset.phoneLength) {\n      this._setItemValidState(parent, input);\n    } else {\n      this._setItemInvalidState(parent, input);\n      flag = false;\n    }\n    return flag;\n  }\n\n  _validateCheckbox(parent, input) {\n    let flag = true;\n    if (input.checked) {\n      this._setItemValidState(parent, input);\n    } else {\n      this._setItemInvalidState(parent, input);\n      flag = false;\n    }\n    return flag;\n  }\n\n  _findSelectedOption(options) {\n    let flag = false;\n    options.forEach((option) => {\n      if (option.value && option.selected) {\n        flag = true;\n      }\n    });\n    return flag;\n  }\n\n  _validateSelect(parent, input) {\n    const options = input.querySelectorAll('option');\n    const customSelectText = parent.querySelector('.custom-select__text');\n    input.setAttribute('aria-invalid', 'false');\n    let flag = true;\n    if (this._findSelectedOption(options)) {\n      this._setItemValidState(parent, input);\n    } else {\n      this._setItemInvalidState(parent, input);\n      parent.classList.remove('not-empty');\n      customSelectText.innerHTML = '';\n      flag = false;\n    }\n    return flag;\n  }\n\n  _returnCheckedElements(inputs) {\n    let flag = false;\n    inputs.forEach((input) => {\n      if (input.checked) {\n        flag = true;\n      }\n    });\n    return flag;\n  }\n\n  _removeGroupAria(inputs) {\n    inputs.forEach((input) => {\n      if (!input.checked) {\n        input.removeAttribute('aria-required');\n        input.removeAttribute('aria-invalid');\n      } else {\n        input.setAttribute('aria-required', true);\n        input.setAttribute('aria-invalid', false);\n      }\n    });\n  }\n\n  _setGroupAria(inputs) {\n    inputs.forEach((input) => {\n      input.setAttribute('aria-required', true);\n      input.setAttribute('aria-invalid', true);\n    });\n  }\n\n  _validateToggleGroup(parent) {\n    const formElements = parent.querySelectorAll('input');\n    let flag = true;\n    if (this._returnCheckedElements(formElements)) {\n      this._removeGroupAria(formElements);\n      parent.classList.remove('is-invalid');\n      parent.classList.add('is-valid');\n      this._message.removeMessage(parent);\n    } else {\n      this._setGroupAria(formElements);\n      parent.classList.remove('is-valid');\n      flag = false;\n    }\n    return flag;\n  }\n\n  _customExample(parent, input) {\n    let flag = true;\n    if (!input.value.length) {\n      parent.dataset.messageBase = '   ';\n      this._setItemInvalidState(parent, input);\n      flag = false;\n    } else if (input.value.length < input.minLength) {\n      parent.dataset.messageBase = `   ${input.minLength - input.value.length} `;\n      this._setItemInvalidState(parent, input);\n      flag = false;\n    } else if (input.value.length > input.minLength) {\n      parent.dataset.messageBase = `  ${input.value.length - input.minLength}  `;\n      this._setItemInvalidState(parent, input);\n      flag = false;\n    } else {\n      parent.dataset.messageSuccess = '  ';\n      this._setItemValidState(parent, input);\n      flag = true;\n    }\n    return flag;\n  }\n\n  _validateFile(parent, input) {\n    let flag = true;\n    const sizeTest = parent.dataset.maxSize && input.files[0] ? input.files[0].size < +parent.dataset.maxSize : true;\n    if (input.value && sizeTest) {\n      this._setItemValidState(parent, input);\n    } else {\n      this._setItemInvalidState(parent, input);\n      flag = false;\n    }\n    return flag;\n  }\n\n  _validateInput(type, parent, input) {\n    switch (type) {\n      case 'text':\n        return this._validateTextInput(parent, input);\n      case 'matrix':\n        return this._validateMatrixInput(parent, input);\n      case 'email':\n        return this._validateEmailInput(parent, input);\n      case 'phone':\n        return this._validatePhoneInput(parent, input);\n      case 'checkbox':\n        return this._validateCheckbox(parent, input);\n      case 'select':\n        return this._validateSelect(parent, input);\n      case 'toggle-group':\n        return this._validateToggleGroup(parent, input);\n      case 'file':\n        return this._validateFile(parent, input);\n      case 'custom-example':\n        return this._customExample(parent, input);\n      default:\n        return false;\n    }\n  }\n\n  validateFormElement(formElement, fullValidate = false) {\n    const parent = formElement.closest('[data-validate-type]');\n    if (!parent) {\n      return;\n    }\n\n    if (!parent.hasAttribute('data-required')) {\n      const removeElement = parent.querySelector('input') || parent.querySelector('select') || parent.querySelector('textarea');\n\n      if (!removeElement.value) {\n        parent.classList.remove('is-valid');\n        parent.classList.remove('is-invalid');\n      }\n    }\n\n    const onInputValidate = parent.hasAttribute('data-on-input-validate');\n\n    if (parent.hasAttribute('data-limitation')) {\n      this._simpleLimitation(formElement, parent.dataset.limitation);\n    }\n\n    if (parent.dataset.validateType === 'matrix') {\n      this._matrixLimitation(formElement, parent.dataset.matrix, this._getMatrixLimitationsRegEx(parent.dataset.matrixLimitation));\n    }\n\n    const isValid = this._validateInput(parent.dataset.validateType, parent, formElement);\n\n    if (onInputValidate || fullValidate) {\n      this._renderMessage(isValid, parent, formElement);\n    }\n  }\n\n  _fullValidate(items) {\n    let result = true;\n    items.forEach((item) => {\n      const formElement = item.querySelector('input') || item.querySelector('select') || item.querySelector('textarea');\n      this.validateFormElement(formElement, true);\n      if (item.classList.contains('is-invalid')) {\n        result = false;\n      }\n    });\n    return result;\n  }\n\n  validateForm(form) {\n    const validateItems = form.querySelectorAll('[data-validate-type]');\n    const result = this._fullValidate(validateItems);\n    return result;\n  }\n}\n","import {Modals} from './modals';\n\nlet modals;\n\n//        \n// const openModalInCloseCallback = (name, context = this) => {\n//   context._enableScrolling = false;\n//   context._setSettings('default');\n//   modals.open(name);\n// };\n\n// closeCallback() {\n//   openModalInCloseCallback('modal-5');\n// },\n\nconst settings = {\n  'default': {\n    preventDefault: true,\n    stopPlay: true,\n    lockFocus: true,\n    startFocus: true,\n    focusBack: true,\n    eventTimeout: 400,\n    openCallback: false,\n    closeCallback: false,\n  },\n};\n\nconst initModals = () => {\n  const modalElements = document.querySelectorAll('.modal');\n  modalElements.forEach((el) => {\n    setTimeout(() => {\n      el.classList.remove('modal--preload');\n    }, 100);\n  });\n  modals = new Modals(settings);\n  //      modals, window   \n  window.modals = modals;\n};\n\nexport {modals, initModals};\n","import {ScrollLock} from '../../utils/scroll-lock';\nimport {FocusLock} from '../../utils/focus-lock';\n\nexport class Modals {\n  constructor(settings = {}) {\n    this._scrollLock = new ScrollLock();\n    this._focusLock = new FocusLock();\n\n    this._modalOpenElements = document.querySelectorAll('[data-open-modal]');\n    this._openedModalElement = null;\n    this._modalName = null;\n    this._enableScrolling = true;\n    this._settingKey = 'default';\n\n    this._settings = settings;\n    this._preventDefault = this._settings[this._settingKey].preventDefault;\n    this._stopPlay = this._settings[this._settingKey].stopPlay;\n    this._lockFocus = this._settings[this._settingKey].lockFocus;\n    this._startFocus = this._settings[this._settingKey].startFocus;\n    this._focusBack = this._settings[this._settingKey].focusBack;\n    this._eventTimeout = this._settings[this._settingKey].eventTimeout;\n    this._openCallback = this._settings[this._settingKey].openCallback;\n    this._closeCallback = this._settings[this._settingKey].closeCallback;\n\n    this._documentKeydownHandler = this._documentKeydownHandler.bind(this);\n    this._documentClickHandler = this._documentClickHandler.bind(this);\n    this._modalClickHandler = this._modalClickHandler.bind(this);\n\n    this._init();\n  }\n\n  _init() {\n    if (this._modalOpenElements.length) {\n      document.addEventListener('click', this._documentClickHandler);\n    }\n  }\n\n  _setSettings(settingKey = this._settingKey) {\n    if (!this._settings[settingKey]) {\n      return;\n    }\n\n    this._preventDefault =\n      typeof this._settings[settingKey].preventDefault === 'boolean'\n        ? this._settings[settingKey].preventDefault\n        : this._settings[this._settingKey].preventDefault;\n    this._stopPlay =\n      typeof this._settings[settingKey].stopPlay === 'boolean'\n        ? this._settings[settingKey].stopPlay\n        : this._settings[this._settingKey].stopPlay;\n    this._lockFocus =\n      typeof this._settings[settingKey].lockFocus === 'boolean'\n        ? this._settings[settingKey].lockFocus\n        : this._settings[this._settingKey].lockFocus;\n    this._startFocus =\n      typeof this._settings[settingKey].startFocus === 'boolean'\n        ? this._settings[settingKey].startFocus\n        : this._settings[this._settingKey].startFocus;\n    this._focusBack =\n      typeof this._settings[settingKey].lockFocus === 'boolean'\n        ? this._settings[settingKey].focusBack\n        : this._settings[this._settingKey].focusBack;\n    this._eventTimeout =\n      typeof this._settings[settingKey].eventTimeout === 'number'\n        ? this._settings[settingKey].eventTimeout\n        : this._settings[this._settingKey].eventTimeout;\n    this._openCallback = this._settings[settingKey].openCallback || this._settings[this._settingKey].openCallback;\n    this._closeCallback = this._settings[settingKey].closeCallback || this._settings[this._settingKey].closeCallback;\n  }\n\n  _documentClickHandler(evt) {\n    const target = evt.target;\n\n    if (!target.closest('[data-open-modal]')) {\n      return;\n    }\n\n    evt.preventDefault();\n\n    this._modalName = target.closest('[data-open-modal]').dataset.openModal;\n\n    if (!this._modalName) {\n      return;\n    }\n\n    this.open();\n  }\n\n  _documentKeydownHandler(evt) {\n    const isEscKey = evt.key === 'Escape' || evt.key === 'Esc';\n\n    if (isEscKey) {\n      evt.preventDefault();\n      this.close(document.querySelector('.modal.is-active').dataset.modal);\n    }\n  }\n\n  _modalClickHandler(evt) {\n    const target = evt.target;\n\n    if (!target.closest('[data-close-modal]')) {\n      return;\n    }\n\n    this.close(target.closest('[data-modal]').dataset.modal);\n  }\n\n  _addListeners(modal) {\n    modal.addEventListener('click', this._modalClickHandler);\n    document.addEventListener('keydown', this._documentKeydownHandler);\n  }\n\n  _removeListeners(modal) {\n    modal.removeEventListener('click', this._modalClickHandler);\n    document.removeEventListener('keydown', this._documentKeydownHandler);\n  }\n\n  _stopInteractive(modal) {\n    if (this._stopPlay) {\n      modal.querySelectorAll('video, audio').forEach((el) => el.pause());\n      modal.querySelectorAll('[data-iframe]').forEach((el) => {\n        el.querySelector('iframe').contentWindow.postMessage('{\"event\": \"command\", \"func\": \"pauseVideo\", \"args\": \"\"}', '*');\n      });\n    }\n  }\n\n  _autoPlay(modal) {\n    modal.querySelectorAll('[data-iframe]').forEach((el) => {\n      const autoPlay = el.closest('[data-auto-play]');\n      if (autoPlay) {\n        el.querySelector('iframe').contentWindow.postMessage('{\"event\":\"command\",\"func\":\"playVideo\",\"args\":\"\"}', '*');\n      }\n    });\n  }\n\n  open(modalName = this._modalName) {\n    const modal = document.querySelector(`[data-modal=\"${modalName}\"]`);\n\n    if (!modal || modal.classList.contains('is-active')) {\n      return;\n    }\n\n    document.removeEventListener('click', this._documentClickHandler);\n\n    this._openedModalElement = document.querySelector('.modal.is-active');\n\n    if (this._openedModalElement) {\n      this._enableScrolling = false;\n      this.close(this._openedModalElement.dataset.modal);\n    }\n\n    this._setSettings(modalName);\n    modal.classList.add('is-active');\n\n    if (!this._openedModalElement) {\n      this._scrollLock.disableScrolling();\n    }\n\n    if (this._openCallback) {\n      this._openCallback();\n    }\n\n    if (this._lockFocus) {\n      this._focusLock.lock('.modal.is-active', this._startFocus);\n    }\n\n    setTimeout(() => {\n      this._addListeners(modal);\n      this._autoPlay(modal);\n      document.addEventListener('click', this._documentClickHandler);\n    }, this._eventTimeout);\n  }\n\n  close(modalName = this._modalName) {\n    const modal = document.querySelector(`[data-modal=\"${modalName}\"]`);\n    document.removeEventListener('click', this._documentClickHandler);\n\n    if (!modal || !modal.classList.contains('is-active')) {\n      return;\n    }\n\n    if (this._lockFocus) {\n      this._focusLock.unlock(this._focusBack);\n    }\n\n    modal.classList.remove('is-active');\n    this._removeListeners(modal);\n    this._stopInteractive(modal);\n\n    if (this._closeCallback) {\n      this._closeCallback();\n    }\n\n    if (this._enableScrolling) {\n      setTimeout(() => {\n        this._scrollLock.enableScrolling();\n      }, this._eventTimeout);\n    }\n\n    setTimeout(() => {\n      document.addEventListener('click', this._documentClickHandler);\n    }, this._eventTimeout);\n\n    this._setSettings('default');\n    this._enableScrolling = true;\n  }\n}\n","export class Tabs {\n  constructor() {\n    this._windowWidth = window.innerWidth;\n    this._documentClickHandler = this._documentClickHandler.bind(this);\n    this._init();\n  }\n\n  _init() {\n    this._initAllTabs();\n    document.addEventListener('click', this._documentClickHandler);\n  }\n\n  _resizeObserver() {\n    return new ResizeObserver((entries) => {\n      for (let entry of entries) {\n        if (entry.target.classList.contains('is-active')) {\n          this._updateTabHeight();\n        }\n      }\n    });\n  }\n\n  _documentClickHandler(evt) {\n    const target = evt.target;\n    if (!target.closest('[data-tabs=\"control\"]')) {\n      return;\n    }\n    evt.preventDefault();\n    const control = target.closest('[data-tabs=\"control\"]');\n    this.openTab(control);\n  }\n\n  _initAllTabs() {\n    const tabs = document.querySelectorAll('[data-tabs=\"parent\"]');\n    const forLoadTabs = document.querySelectorAll('[data-tabs=\"element\"].for-load');\n    tabs.forEach((tab) => {\n      this._initTab(tab);\n    });\n    forLoadTabs.forEach((tab) => {\n      tab.classList.remove('for-load');\n    });\n  }\n\n  _removeAllActiveClasses(tabControlElements, tabElements) {\n    tabElements.forEach((tab) => {\n      tab.classList.remove('is-active');\n    });\n\n    tabControlElements.forEach((element, index) => {\n      element.classList.remove('is-active');\n      element.setAttribute('data-index', index);\n    });\n  }\n\n  _setTabStartState(tab, dataHeight, tabElements, tabContentElement, tabControlElements, dataDelay) {\n    const activeIndex = this._returnActiveIndex(tabControlElements);\n    const blockHeight = dataHeight === 'max' ? this._returnMaxHeight(tabElements) : tabElements[activeIndex].offsetHeight;\n    this._removeAllActiveClasses(tabControlElements, tabElements);\n    tab.classList.add('no-transition');\n    tabControlElements[activeIndex].classList.add('is-active');\n    tabElements[activeIndex].classList.add('is-active');\n    if (dataHeight !== 'unset') {\n      tabContentElement.style.height = `${blockHeight}px`;\n    }\n    setTimeout(() => {\n      if (dataDelay) {\n        tab.classList.remove('no-transition');\n      }\n    }, dataDelay);\n  }\n\n  _returnActiveIndex(tabControlElements) {\n    let activeIndex = 0;\n    let flag = true;\n    tabControlElements.forEach((control, index) => {\n      if (control.classList.contains('is-active') && flag) {\n        activeIndex = index;\n        flag = false;\n      }\n    });\n    return activeIndex;\n  }\n\n  _returnMaxHeight(tabElements) {\n    let height = [];\n    tabElements.forEach((element) => {\n      height.push(element.offsetHeight);\n    });\n    height.sort((a, b) => a - b);\n    return height[height.length - 1];\n  }\n\n  _returnScopeList(nodeList, parent) {\n    const array = [];\n    nodeList.forEach((element) => {\n      const elementParent = element.closest('[data-tabs=\"parent\"]');\n      if (elementParent === parent) {\n        array.push(element);\n      }\n    });\n\n    return array;\n  }\n\n  _returnScopeChild(nodeList, parent) {\n    let currentChild;\n    nodeList.forEach((element) => {\n      const elementParent = element.closest('[data-tabs=\"parent\"]');\n      if (elementParent === parent) {\n        currentChild = element;\n      }\n    });\n\n    return currentChild;\n  }\n\n  _updateTabHeight() {\n    const activeElements = document.querySelectorAll('[data-tabs=\"element\"].is-active');\n    activeElements.forEach((element) => {\n      let transition = false;\n      const parent = element.closest('[data-tabs=\"parent\"]');\n      if (parent.closest('[data-tabs=\"element\"]')) {\n        transition = true;\n      }\n      this._setTabElementHeight(element, transition);\n    });\n  }\n\n  _setTabElementHeight(element, transition) {\n    const parentElement = element.closest('[data-tabs=\"parent\"]');\n    const dataHeight = parentElement.dataset.height;\n    const contentElement = this._returnScopeChild(parentElement.querySelectorAll('[data-tabs=\"content\"]'), parentElement);\n    const tabElements = this._returnScopeList(parentElement.querySelectorAll('[data-tabs=\"element\"]'), parentElement);\n\n    if (!transition) {\n      parentElement.classList.add('no-transition');\n    }\n\n    if (dataHeight === 'max') {\n      contentElement.style.height = `${this._returnMaxHeight(tabElements)}px`;\n    } else if (dataHeight === 'unset') {\n      contentElement.style.height = null;\n    } else {\n      contentElement.style.height = `${this._returnScopeChild(parentElement.querySelectorAll('[data-tabs=\"element\"].is-active'), parentElement).offsetHeight}px`;\n    }\n\n    setTimeout(() => parentElement.classList.remove('no-transition'));\n  }\n\n  _initTab(tab) {\n    const dataHeight = tab.dataset.height;\n    const dataDelay = tab.dataset.delay ? tab.dataset.delay : 0;\n    const tabContentElement = tab.querySelector('[data-tabs=\"content\"]');\n    const tabControlElements = this._returnScopeList(tab.querySelectorAll('[data-tabs=\"control\"]'), tab);\n    const tabElements = this._returnScopeList(tab.querySelectorAll('[data-tabs=\"element\"]'), tab);\n    this._setTabStartState(tab, dataHeight, tabElements, tabContentElement, tabControlElements, dataDelay);\n    if (dataHeight !== 'unset') {\n      tabElements.forEach((element) => {\n        this._resizeObserver().observe(element);\n      });\n    }\n    setTimeout(() => {\n      tab.classList.remove('no-transition-global');\n    });\n  }\n\n  reInit() {\n    this._initAllTabs();\n  }\n\n  openTab(control) {\n    const currentIndex = control.dataset.index;\n    const parentElement = control.closest('[data-tabs=\"parent\"]');\n\n    if (control.classList.contains('is-active') || parentElement.classList.contains('no-action')) {\n      return;\n    }\n\n    const dataDelay = parentElement.dataset.delay ? parentElement.dataset.delay : 0;\n    const dataHeight = parentElement.dataset.height;\n    const contentElement = parentElement.querySelector('[data-tabs=\"content\"]');\n    const tabElements = this._returnScopeList(parentElement.querySelectorAll('[data-tabs=\"element\"]'), parentElement);\n\n    const activeControl = this._returnScopeChild(parentElement.querySelectorAll('[data-tabs=\"control\"].is-active'), parentElement);\n    const activeElement = this._returnScopeChild(parentElement.querySelectorAll('[data-tabs=\"element\"].is-active'), parentElement);\n    const currentHeight = contentElement.offsetHeight;\n    const newHeight = tabElements[currentIndex].offsetHeight;\n\n    parentElement.classList.add('no-action');\n    document.activeElement.blur();\n\n    if (activeControl) {\n      activeControl.classList.remove('is-active');\n    }\n\n    if (activeElement) {\n      activeElement.classList.remove('is-active');\n    }\n\n    if (currentHeight > newHeight) {\n      setTimeout(() => {\n        if (dataHeight !== 'max' && dataHeight !== 'unset') {\n          contentElement.style.height = newHeight + 'px';\n        }\n        control.classList.add('is-active');\n        tabElements[currentIndex].classList.add('is-active');\n        parentElement.classList.remove('no-action');\n      }, dataDelay);\n    } else {\n      if (dataHeight !== 'max' && dataHeight !== 'unset') {\n        contentElement.style.height = newHeight + 'px';\n      }\n      setTimeout(() => {\n        control.classList.add('is-active');\n        tabElements[currentIndex].classList.add('is-active');\n        parentElement.classList.remove('no-action');\n      }, dataDelay);\n    }\n  }\n}\n","const SELECTORS = [\n  'a[href]',\n  'area[href]',\n  'input:not([disabled]):not([type=\"hidden\"]):not([aria-hidden])',\n  'select:not([disabled]):not([aria-hidden])',\n  'textarea:not([disabled]):not([aria-hidden])',\n  'button:not([disabled]):not([aria-hidden])',\n  'iframe',\n  'object',\n  'embed',\n  '[contenteditable]',\n  '[tabindex]:not([tabindex^=\"-\"])'\n];\n\nexport class FocusLock {\n  constructor() {\n    this._lockedSelector = null;\n    this._focusableElements = null;\n    this._endElement = null;\n    this._selectors = SELECTORS;\n\n    this._documentKeydownHandler = this._documentKeydownHandler.bind(this);\n  }\n\n  _documentKeydownHandler(evt) {\n    const activeElement = document.activeElement;\n    if (evt.key === 'Tab') {\n      if (!this._focusableElements.length) {\n        evt.preventDefault();\n        activeElement.blur();\n        return;\n      }\n      if (this._focusableElements.length === 1) {\n        evt.preventDefault();\n        this._focusableElements[0].focus();\n        return;\n      }\n      if (this._focusableElements.length > 1 && !activeElement.closest(this._lockedSelector)) {\n        evt.preventDefault();\n        this._focusableElements[0].focus();\n        return;\n      }\n    }\n    if (evt.key === 'Tab' && !evt.shiftKey && activeElement === this._focusableElements[this._focusableElements.length - 1]) {\n      evt.preventDefault();\n      this._focusableElements[0].focus();\n    }\n    if (evt.key === 'Tab' && evt.shiftKey && activeElement === this._focusableElements[0]) {\n      evt.preventDefault();\n      this._focusableElements[this._focusableElements.length - 1].focus();\n    }\n  }\n\n  lock(lockedSelector, startFocus = true) {\n    this.unlock();\n    this._lockedSelector = lockedSelector;\n    const lockedElement = document.querySelector(this._lockedSelector);\n    if (!lockedElement) {\n      return;\n    }\n    this._focusableElements = lockedElement.querySelectorAll(this._selectors);\n    this._endElement = document.activeElement;\n    const startElement = lockedElement.querySelector('[data-focus]') || this._focusableElements[0];\n    if (this._endElement) {\n      this._endElement.blur();\n    }\n    if (startElement && startFocus) {\n      startElement.focus();\n    }\n    document.addEventListener('keydown', this._documentKeydownHandler);\n  }\n\n  unlock(returnFocus = true) {\n    if (this._endElement && returnFocus) {\n      this._endElement.focus();\n    }\n    this._lockedSelector = null;\n    this._focusableElements = null;\n    this._endElement = null;\n    document.removeEventListener('keydown', this._documentKeydownHandler);\n  }\n}\n\nwindow.focusLock = new FocusLock();\n","export const iosChecker = () => {\n  return [\n    'iPad Simulator',\n    'iPhone Simulator',\n    'iPod Simulator',\n    'iPad',\n    'iPhone',\n    'iPod'\n  ].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);\n};\n","import {iosChecker} from './ios-checker';\n\nconst iosVhFix = () => {\n  if (!(!!window.MSInputMethodContext && !!document.documentMode)) {\n    if (iosChecker()) {\n      let vh = window.innerHeight * 0.01;\n      document.documentElement.style.setProperty('--vh', `${vh}px`);\n\n      window.addEventListener('resize', function () {\n        vh = window.innerHeight * 0.01;\n        document.documentElement.style.setProperty('--vh', `${vh}px`);\n      });\n    }\n  }\n};\n\nexport {iosVhFix};\n","import {iosChecker} from './ios-checker';\n\nexport class ScrollLock {\n  constructor() {\n    this._iosChecker = iosChecker;\n    this._lockClass = this._iosChecker() ? 'scroll-lock-ios' : 'scroll-lock';\n    this._scrollTop = null;\n    this._fixedBlockElements = document.querySelectorAll('[data-fix-block]');\n  }\n\n  _getScrollbarWidth() {\n    return window.innerWidth - document.documentElement.clientWidth;\n  }\n\n  _getBodyScrollTop() {\n    return (\n      self.pageYOffset ||\n      (document.documentElement && document.documentElement.ScrollTop) ||\n      (document.body && document.body.scrollTop)\n    );\n  }\n\n  disableScrolling() {\n    this._scrollTop = document.body.dataset.scroll = document.body.dataset.scroll ? document.body.dataset.scroll : this._getBodyScrollTop();\n    if (this._getScrollbarWidth()) {\n      document.body.style.paddingRight = `${this._getScrollbarWidth()}px`;\n      this._fixedBlockElements.forEach((block) => {\n        block.style.paddingRight = `${this._getScrollbarWidth()}px`;\n      });\n    }\n    document.body.style.top = `-${this._scrollTop}px`;\n    document.body.classList.add(this._lockClass);\n  }\n\n  enableScrolling() {\n    document.body.classList.remove(this._lockClass);\n    window.scrollTo(0, +document.body.dataset.scroll);\n    document.body.style.paddingRight = null;\n    document.body.style.top = null;\n    this._fixedBlockElements.forEach((block) => {\n      block.style.paddingRight = null;\n    });\n    document.body.removeAttribute('data-scroll');\n    this._scrollTop = null;\n  }\n}\n\nwindow.scrollLock = new ScrollLock();\n","const createNewSlider = () => {\nnew Swiper('.swiper', {\n    navigation: {\n      nextEl:'.trainer__swiper-next',\n      prevEl:'.trainer__swiper-prev',\n    },\n    loop: true,\n    breakpoints: {\n          320: {\n            slidesPerView: 1,\n          },\n          768: {\n            slidesPerView: 2,\n            spaceBetween: 30\n          },\n          1200: {\n            slidesPerView: 4,\n            spaceBetween: 40\n          }\n  }});\n}\nexport {createNewSlider};\n\n\n\n\n// var swiper = new Swiper('.swiper-container', {\n//   slidesPerView: 3,\n//   slidesPerColumn: 2,\n//   spaceBetween: 0,\n//   navigation: {\n//     nextEl: '.sw-next',\n//     prevEl: '.sw-prev',\n//    },\n//   breakpoints: {\n//     // when window width is <= 320px\n//     320: {\n//       slidesPerView: 1,\n//       spaceBetween: 10\n//     },\n//     // when window width is <= 480px\n//     480: {\n//       slidesPerView: 2,\n//       spaceBetween: 20\n//     },\n//     // when window width is <= 640px\n//     640: {\n//       slidesPerView: 3,\n//       spaceBetween: 30\n//     }\n//   }\n// });\n//   /**\n//    * Swiper 7.4.1\n//    * Most modern mobile touch slider and framework with hardware accelerated transitions\n//    * https://swiperjs.com\n//    *\n//    * Copyright 2014-2021 Vladimir Kharlampidi\n//    *\n//    * Released under the MIT License\n//    *\n//    * Released on: December 24, 2021\n//    */\n\n//   (function (global, factory) {\n//     typeof exports === 'object' && typeof module !== 'undefined'\n//       ? (module.exports = factory())\n//       : typeof define === 'function' && define.amd\n//       ? define(factory)\n//       : ((global = typeof globalThis !== 'undefined' ? globalThis : global || self), (global.Swiper = factory()));\n//   })(this, function () {\n\n//     'use strict';\n\n//     /**\n//      * SSR Window 4.0.2\n//      * Better handling for window object in SSR environment\n//      * https://github.com/nolimits4web/ssr-window\n//      *\n//      * Copyright 2021, Vladimir Kharlampidi\n//      *\n//      * Licensed under MIT\n//      *\n//      * Released on: December 13, 2021\n//      */\n\n//     /* eslint-disable no-param-reassign */\n//     function isObject$1(obj) {\n//       return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;\n//     }\n\n//     function extend$1(target = {}, src = {}) {\n//       Object.keys(src).forEach((key) => {\n//         if (typeof target[key] === 'undefined') target[key] = src[key];\n//         else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n//           extend$1(target[key], src[key]);\n//         }\n//       });\n//     }\n\n//     const ssrDocument = {\n//       body: {},\n\n//       addEventListener() {},\n\n//       removeEventListener() {},\n\n//       activeElement: {\n//         blur() {},\n\n//         nodeName: '',\n//       },\n\n//       querySelector() {\n//         return null;\n//       },\n\n//       querySelectorAll() {\n//         return [];\n//       },\n\n//       getElementById() {\n//         return null;\n//       },\n\n//       createEvent() {\n//         return {\n//           initEvent() {},\n//         };\n//       },\n\n//       createElement() {\n//         return {\n//           children: [],\n//           childNodes: [],\n//           style: {},\n\n//           setAttribute() {},\n\n//           getElementsByTagName() {\n//             return [];\n//           },\n//         };\n//       },\n\n//       createElementNS() {\n//         return {};\n//       },\n\n//       importNode() {\n//         return null;\n//       },\n\n//       location: {\n//         hash: '',\n//         host: '',\n//         hostname: '',\n//         href: '',\n//         origin: '',\n//         pathname: '',\n//         protocol: '',\n//         search: '',\n//       },\n//     };\n\n//     function getDocument() {\n//       const doc = typeof document !== 'undefined' ? document : {};\n//       extend$1(doc, ssrDocument);\n//       return doc;\n//     }\n\n//     const ssrWindow = {\n//       document: ssrDocument,\n//       navigator: {\n//         userAgent: '',\n//       },\n//       location: {\n//         hash: '',\n//         host: '',\n//         hostname: '',\n//         href: '',\n//         origin: '',\n//         pathname: '',\n//         protocol: '',\n//         search: '',\n//       },\n//       history: {\n//         replaceState() {},\n\n//         pushState() {},\n\n//         go() {},\n\n//         back() {},\n//       },\n//       CustomEvent: function CustomEvent() {\n//         return this;\n//       },\n\n//       addEventListener() {},\n\n//       removeEventListener() {},\n\n//       getComputedStyle() {\n//         return {\n//           getPropertyValue() {\n//             return '';\n//           },\n//         };\n//       },\n\n//       Image() {},\n\n//       Date() {},\n\n//       screen: {},\n\n//       setTimeout() {},\n\n//       clearTimeout() {},\n\n//       matchMedia() {\n//         return {};\n//       },\n\n//       requestAnimationFrame(callback) {\n//         if (typeof setTimeout === 'undefined') {\n//           callback();\n//           return null;\n//         }\n\n//         return setTimeout(callback, 0);\n//       },\n\n//       cancelAnimationFrame(id) {\n//         if (typeof setTimeout === 'undefined') {\n//           return;\n//         }\n\n//         clearTimeout(id);\n//       },\n//     };\n\n//     function getWindow() {\n//       const win = typeof window !== 'undefined' ? window : {};\n//       extend$1(win, ssrWindow);\n//       return win;\n//     }\n\n//     /**\n//      * Dom7 4.0.2\n//      * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API\n//      * https://framework7.io/docs/dom7.html\n//      *\n//      * Copyright 2021, Vladimir Kharlampidi\n//      *\n//      * Licensed under MIT\n//      *\n//      * Released on: December 13, 2021\n//      */\n//     /* eslint-disable no-proto */\n\n//     function makeReactive(obj) {\n//       const proto = obj.__proto__;\n//       Object.defineProperty(obj, '__proto__', {\n//         get() {\n//           return proto;\n//         },\n\n//         set(value) {\n//           proto.__proto__ = value;\n//         },\n//       });\n//     }\n\n//     class Dom7 extends Array {\n//       constructor(items) {\n//         super(...(items || []));\n//         makeReactive(this);\n//       }\n//     }\n\n//     function arrayFlat(arr = []) {\n//       const res = [];\n//       arr.forEach((el) => {\n//         if (Array.isArray(el)) {\n//           res.push(...arrayFlat(el));\n//         } else {\n//           res.push(el);\n//         }\n//       });\n//       return res;\n//     }\n\n//     function arrayFilter(arr, callback) {\n//       return Array.prototype.filter.call(arr, callback);\n//     }\n\n//     function arrayUnique(arr) {\n//       const uniqueArray = [];\n\n//       for (let i = 0; i < arr.length; i += 1) {\n//         if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);\n//       }\n\n//       return uniqueArray;\n//     }\n\n//     function qsa(selector, context) {\n//       if (typeof selector !== 'string') {\n//         return [selector];\n//       }\n\n//       const a = [];\n//       const res = context.querySelectorAll(selector);\n\n//       for (let i = 0; i < res.length; i += 1) {\n//         a.push(res[i]);\n//       }\n\n//       return a;\n//     }\n\n//     function $(selector, context) {\n//       const window = getWindow();\n//       const document = getDocument();\n//       let arr = [];\n\n//       if (!context && selector instanceof Dom7) {\n//         return selector;\n//       }\n\n//       if (!selector) {\n//         return new Dom7(arr);\n//       }\n\n//       if (typeof selector === 'string') {\n//         const html = selector.trim();\n\n//         if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {\n//           let toCreate = 'div';\n//           if (html.indexOf('<li') === 0) toCreate = 'ul';\n//           if (html.indexOf('<tr') === 0) toCreate = 'tbody';\n//           if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';\n//           if (html.indexOf('<tbody') === 0) toCreate = 'table';\n//           if (html.indexOf('<option') === 0) toCreate = 'select';\n//           const tempParent = document.createElement(toCreate);\n//           tempParent.innerHTML = html;\n\n//           for (let i = 0; i < tempParent.childNodes.length; i += 1) {\n//             arr.push(tempParent.childNodes[i]);\n//           }\n//         } else {\n//           arr = qsa(selector.trim(), context || document);\n//         } // arr = qsa(selector, document);\n//       } else if (selector.nodeType || selector === window || selector === document) {\n//         arr.push(selector);\n//       } else if (Array.isArray(selector)) {\n//         if (selector instanceof Dom7) return selector;\n//         arr = selector;\n//       }\n\n//       return new Dom7(arrayUnique(arr));\n//     }\n\n//     $.fn = Dom7.prototype; // eslint-disable-next-line\n\n//     function addClass(...classes) {\n//       const classNames = arrayFlat(classes.map((c) => c.split(' ')));\n//       this.forEach((el) => {\n//         el.classList.add(...classNames);\n//       });\n//       return this;\n//     }\n\n//     function removeClass(...classes) {\n//       const classNames = arrayFlat(classes.map((c) => c.split(' ')));\n//       this.forEach((el) => {\n//         el.classList.remove(...classNames);\n//       });\n//       return this;\n//     }\n\n//     function toggleClass(...classes) {\n//       const classNames = arrayFlat(classes.map((c) => c.split(' ')));\n//       this.forEach((el) => {\n//         classNames.forEach((className) => {\n//           el.classList.toggle(className);\n//         });\n//       });\n//     }\n\n//     function hasClass(...classes) {\n//       const classNames = arrayFlat(classes.map((c) => c.split(' ')));\n//       return (\n//         arrayFilter(this, (el) => {\n//           return classNames.filter((className) => el.classList.contains(className)).length > 0;\n//         }).length > 0\n//       );\n//     }\n\n//     function attr(attrs, value) {\n//       if (arguments.length === 1 && typeof attrs === 'string') {\n//         // Get attr\n//         if (this[0]) return this[0].getAttribute(attrs);\n//         return undefined;\n//       } // Set attrs\n\n//       for (let i = 0; i < this.length; i += 1) {\n//         if (arguments.length === 2) {\n//           // String\n//           this[i].setAttribute(attrs, value);\n//         } else {\n//           // Object\n//           for (const attrName in attrs) {\n//             this[i][attrName] = attrs[attrName];\n//             this[i].setAttribute(attrName, attrs[attrName]);\n//           }\n//         }\n//       }\n\n//       return this;\n//     }\n\n//     function removeAttr(attr) {\n//       for (let i = 0; i < this.length; i += 1) {\n//         this[i].removeAttribute(attr);\n//       }\n\n//       return this;\n//     }\n\n//     function transform(transform) {\n//       for (let i = 0; i < this.length; i += 1) {\n//         this[i].style.transform = transform;\n//       }\n\n//       return this;\n//     }\n\n//     function transition$1(duration) {\n//       for (let i = 0; i < this.length; i += 1) {\n//         this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;\n//       }\n\n//       return this;\n//     }\n\n//     function on(...args) {\n//       let [eventType, targetSelector, listener, capture] = args;\n\n//       if (typeof args[1] === 'function') {\n//         [eventType, listener, capture] = args;\n//         targetSelector = undefined;\n//       }\n\n//       if (!capture) capture = false;\n\n//       function handleLiveEvent(e) {\n//         const target = e.target;\n//         if (!target) return;\n//         const eventData = e.target.dom7EventData || [];\n\n//         if (eventData.indexOf(e) < 0) {\n//           eventData.unshift(e);\n//         }\n\n//         if ($(target).is(targetSelector)) listener.apply(target, eventData);\n//         else {\n//           const parents = $(target).parents(); // eslint-disable-line\n\n//           for (let k = 0; k < parents.length; k += 1) {\n//             if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);\n//           }\n//         }\n//       }\n\n//       function handleEvent(e) {\n//         const eventData = e && e.target ? e.target.dom7EventData || [] : [];\n\n//         if (eventData.indexOf(e) < 0) {\n//           eventData.unshift(e);\n//         }\n\n//         listener.apply(this, eventData);\n//       }\n\n//       const events = eventType.split(' ');\n//       let j;\n\n//       for (let i = 0; i < this.length; i += 1) {\n//         const el = this[i];\n\n//         if (!targetSelector) {\n//           for (j = 0; j < events.length; j += 1) {\n//             const event = events[j];\n//             if (!el.dom7Listeners) el.dom7Listeners = {};\n//             if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];\n//             el.dom7Listeners[event].push({\n//               listener,\n//               proxyListener: handleEvent,\n//             });\n//             el.addEventListener(event, handleEvent, capture);\n//           }\n//         } else {\n//           // Live events\n//           for (j = 0; j < events.length; j += 1) {\n//             const event = events[j];\n//             if (!el.dom7LiveListeners) el.dom7LiveListeners = {};\n//             if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];\n//             el.dom7LiveListeners[event].push({\n//               listener,\n//               proxyListener: handleLiveEvent,\n//             });\n//             el.addEventListener(event, handleLiveEvent, capture);\n//           }\n//         }\n//       }\n\n//       return this;\n//     }\n\n//     function off(...args) {\n//       let [eventType, targetSelector, listener, capture] = args;\n\n//       if (typeof args[1] === 'function') {\n//         [eventType, listener, capture] = args;\n//         targetSelector = undefined;\n//       }\n\n//       if (!capture) capture = false;\n//       const events = eventType.split(' ');\n\n//       for (let i = 0; i < events.length; i += 1) {\n//         const event = events[i];\n\n//         for (let j = 0; j < this.length; j += 1) {\n//           const el = this[j];\n//           let handlers;\n\n//           if (!targetSelector && el.dom7Listeners) {\n//             handlers = el.dom7Listeners[event];\n//           } else if (targetSelector && el.dom7LiveListeners) {\n//             handlers = el.dom7LiveListeners[event];\n//           }\n\n//           if (handlers && handlers.length) {\n//             for (let k = handlers.length - 1; k >= 0; k -= 1) {\n//               const handler = handlers[k];\n\n//               if (listener && handler.listener === listener) {\n//                 el.removeEventListener(event, handler.proxyListener, capture);\n//                 handlers.splice(k, 1);\n//               } else if (\n//                 listener &&\n//                 handler.listener &&\n//                 handler.listener.dom7proxy &&\n//                 handler.listener.dom7proxy === listener\n//               ) {\n//                 el.removeEventListener(event, handler.proxyListener, capture);\n//                 handlers.splice(k, 1);\n//               } else if (!listener) {\n//                 el.removeEventListener(event, handler.proxyListener, capture);\n//                 handlers.splice(k, 1);\n//               }\n//             }\n//           }\n//         }\n//       }\n\n//       return this;\n//     }\n\n//     function trigger(...args) {\n//       const window = getWindow();\n//       const events = args[0].split(' ');\n//       const eventData = args[1];\n\n//       for (let i = 0; i < events.length; i += 1) {\n//         const event = events[i];\n\n//         for (let j = 0; j < this.length; j += 1) {\n//           const el = this[j];\n\n//           if (window.CustomEvent) {\n//             const evt = new window.CustomEvent(event, {\n//               detail: eventData,\n//               bubbles: true,\n//               cancelable: true,\n//             });\n//             el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);\n//             el.dispatchEvent(evt);\n//             el.dom7EventData = [];\n//             delete el.dom7EventData;\n//           }\n//         }\n//       }\n\n//       return this;\n//     }\n\n//     function transitionEnd$1(callback) {\n//       const dom = this;\n\n//       function fireCallBack(e) {\n//         if (e.target !== this) return;\n//         callback.call(this, e);\n//         dom.off('transitionend', fireCallBack);\n//       }\n\n//       if (callback) {\n//         dom.on('transitionend', fireCallBack);\n//       }\n\n//       return this;\n//     }\n\n//     function outerWidth(includeMargins) {\n//       if (this.length > 0) {\n//         if (includeMargins) {\n//           const styles = this.styles();\n//           return (\n//             this[0].offsetWidth +\n//             parseFloat(styles.getPropertyValue('margin-right')) +\n//             parseFloat(styles.getPropertyValue('margin-left'))\n//           );\n//         }\n\n//         return this[0].offsetWidth;\n//       }\n\n//       return null;\n//     }\n\n//     function outerHeight(includeMargins) {\n//       if (this.length > 0) {\n//         if (includeMargins) {\n//           const styles = this.styles();\n//           return (\n//             this[0].offsetHeight +\n//             parseFloat(styles.getPropertyValue('margin-top')) +\n//             parseFloat(styles.getPropertyValue('margin-bottom'))\n//           );\n//         }\n\n//         return this[0].offsetHeight;\n//       }\n\n//       return null;\n//     }\n\n//     function offset() {\n//       if (this.length > 0) {\n//         const window = getWindow();\n//         const document = getDocument();\n//         const el = this[0];\n//         const box = el.getBoundingClientRect();\n//         const body = document.body;\n//         const clientTop = el.clientTop || body.clientTop || 0;\n//         const clientLeft = el.clientLeft || body.clientLeft || 0;\n//         const scrollTop = el === window ? window.scrollY : el.scrollTop;\n//         const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n//         return {\n//           top: box.top + scrollTop - clientTop,\n//           left: box.left + scrollLeft - clientLeft,\n//         };\n//       }\n\n//       return null;\n//     }\n\n//     function styles() {\n//       const window = getWindow();\n//       if (this[0]) return window.getComputedStyle(this[0], null);\n//       return {};\n//     }\n\n//     function css(props, value) {\n//       const window = getWindow();\n//       let i;\n\n//       if (arguments.length === 1) {\n//         if (typeof props === 'string') {\n//           // .css('width')\n//           if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);\n//         } else {\n//           // .css({ width: '100px' })\n//           for (i = 0; i < this.length; i += 1) {\n//             for (const prop in props) {\n//               this[i].style[prop] = props[prop];\n//             }\n//           }\n\n//           return this;\n//         }\n//       }\n\n//       if (arguments.length === 2 && typeof props === 'string') {\n//         // .css('width', '100px')\n//         for (i = 0; i < this.length; i += 1) {\n//           this[i].style[props] = value;\n//         }\n\n//         return this;\n//       }\n\n//       return this;\n//     }\n\n//     function each(callback) {\n//       if (!callback) return this;\n//       this.forEach((el, index) => {\n//         callback.apply(el, [el, index]);\n//       });\n//       return this;\n//     }\n\n//     function filter(callback) {\n//       const result = arrayFilter(this, callback);\n//       return $(result);\n//     }\n\n//     function html(html) {\n//       if (typeof html === 'undefined') {\n//         return this[0] ? this[0].innerHTML : null;\n//       }\n\n//       for (let i = 0; i < this.length; i += 1) {\n//         this[i].innerHTML = html;\n//       }\n\n//       return this;\n//     }\n\n//     function text(text) {\n//       if (typeof text === 'undefined') {\n//         return this[0] ? this[0].textContent.trim() : null;\n//       }\n\n//       for (let i = 0; i < this.length; i += 1) {\n//         this[i].textContent = text;\n//       }\n\n//       return this;\n//     }\n\n//     function is(selector) {\n//       const window = getWindow();\n//       const document = getDocument();\n//       const el = this[0];\n//       let compareWith;\n//       let i;\n//       if (!el || typeof selector === 'undefined') return false;\n\n//       if (typeof selector === 'string') {\n//         if (el.matches) return el.matches(selector);\n//         if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);\n//         if (el.msMatchesSelector) return el.msMatchesSelector(selector);\n//         compareWith = $(selector);\n\n//         for (i = 0; i < compareWith.length; i += 1) {\n//           if (compareWith[i] === el) return true;\n//         }\n\n//         return false;\n//       }\n\n//       if (selector === document) {\n//         return el === document;\n//       }\n\n//       if (selector === window) {\n//         return el === window;\n//       }\n\n//       if (selector.nodeType || selector instanceof Dom7) {\n//         compareWith = selector.nodeType ? [selector] : selector;\n\n//         for (i = 0; i < compareWith.length; i += 1) {\n//           if (compareWith[i] === el) return true;\n//         }\n\n//         return false;\n//       }\n\n//       return false;\n//     }\n\n//     function index() {\n//       let child = this[0];\n//       let i;\n\n//       if (child) {\n//         i = 0; // eslint-disable-next-line\n\n//         while ((child = child.previousSibling) !== null) {\n//           if (child.nodeType === 1) i += 1;\n//         }\n\n//         return i;\n//       }\n\n//       return undefined;\n//     }\n\n//     function eq(index) {\n//       if (typeof index === 'undefined') return this;\n//       const length = this.length;\n\n//       if (index > length - 1) {\n//         return $([]);\n//       }\n\n//       if (index < 0) {\n//         const returnIndex = length + index;\n//         if (returnIndex < 0) return $([]);\n//         return $([this[returnIndex]]);\n//       }\n\n//       return $([this[index]]);\n//     }\n\n//     function append(...els) {\n//       let newChild;\n//       const document = getDocument();\n\n//       for (let k = 0; k < els.length; k += 1) {\n//         newChild = els[k];\n\n//         for (let i = 0; i < this.length; i += 1) {\n//           if (typeof newChild === 'string') {\n//             const tempDiv = document.createElement('div');\n//             tempDiv.innerHTML = newChild;\n\n//             while (tempDiv.firstChild) {\n//               this[i].appendChild(tempDiv.firstChild);\n//             }\n//           } else if (newChild instanceof Dom7) {\n//             for (let j = 0; j < newChild.length; j += 1) {\n//               this[i].appendChild(newChild[j]);\n//             }\n//           } else {\n//             this[i].appendChild(newChild);\n//           }\n//         }\n//       }\n\n//       return this;\n//     }\n\n//     function prepend(newChild) {\n//       const document = getDocument();\n//       let i;\n//       let j;\n\n//       for (i = 0; i < this.length; i += 1) {\n//         if (typeof newChild === 'string') {\n//           const tempDiv = document.createElement('div');\n//           tempDiv.innerHTML = newChild;\n\n//           for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {\n//             this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);\n//           }\n//         } else if (newChild instanceof Dom7) {\n//           for (j = 0; j < newChild.length; j += 1) {\n//             this[i].insertBefore(newChild[j], this[i].childNodes[0]);\n//           }\n//         } else {\n//           this[i].insertBefore(newChild, this[i].childNodes[0]);\n//         }\n//       }\n\n//       return this;\n//     }\n\n//     function next(selector) {\n//       if (this.length > 0) {\n//         if (selector) {\n//           if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {\n//             return $([this[0].nextElementSibling]);\n//           }\n\n//           return $([]);\n//         }\n\n//         if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);\n//         return $([]);\n//       }\n\n//       return $([]);\n//     }\n\n//     function nextAll(selector) {\n//       const nextEls = [];\n//       let el = this[0];\n//       if (!el) return $([]);\n\n//       while (el.nextElementSibling) {\n//         const next = el.nextElementSibling; // eslint-disable-line\n\n//         if (selector) {\n//           if ($(next).is(selector)) nextEls.push(next);\n//         } else nextEls.push(next);\n\n//         el = next;\n//       }\n\n//       return $(nextEls);\n//     }\n\n//     function prev(selector) {\n//       if (this.length > 0) {\n//         const el = this[0];\n\n//         if (selector) {\n//           if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {\n//             return $([el.previousElementSibling]);\n//           }\n\n//           return $([]);\n//         }\n\n//         if (el.previousElementSibling) return $([el.previousElementSibling]);\n//         return $([]);\n//       }\n\n//       return $([]);\n//     }\n\n//     function prevAll(selector) {\n//       const prevEls = [];\n//       let el = this[0];\n//       if (!el) return $([]);\n\n//       while (el.previousElementSibling) {\n//         const prev = el.previousElementSibling; // eslint-disable-line\n\n//         if (selector) {\n//           if ($(prev).is(selector)) prevEls.push(prev);\n//         } else prevEls.push(prev);\n\n//         el = prev;\n//       }\n\n//       return $(prevEls);\n//     }\n\n//     function parent(selector) {\n//       const parents = []; // eslint-disable-line\n\n//       for (let i = 0; i < this.length; i += 1) {\n//         if (this[i].parentNode !== null) {\n//           if (selector) {\n//             if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);\n//           } else {\n//             parents.push(this[i].parentNode);\n//           }\n//         }\n//       }\n\n//       return $(parents);\n//     }\n\n//     function parents(selector) {\n//       const parents = []; // eslint-disable-line\n\n//       for (let i = 0; i < this.length; i += 1) {\n//         let parent = this[i].parentNode; // eslint-disable-line\n\n//         while (parent) {\n//           if (selector) {\n//             if ($(parent).is(selector)) parents.push(parent);\n//           } else {\n//             parents.push(parent);\n//           }\n\n//           parent = parent.parentNode;\n//         }\n//       }\n\n//       return $(parents);\n//     }\n\n//     function closest(selector) {\n//       let closest = this; // eslint-disable-line\n\n//       if (typeof selector === 'undefined') {\n//         return $([]);\n//       }\n\n//       if (!closest.is(selector)) {\n//         closest = closest.parents(selector).eq(0);\n//       }\n\n//       return closest;\n//     }\n\n//     function find(selector) {\n//       const foundElements = [];\n\n//       for (let i = 0; i < this.length; i += 1) {\n//         const found = this[i].querySelectorAll(selector);\n\n//         for (let j = 0; j < found.length; j += 1) {\n//           foundElements.push(found[j]);\n//         }\n//       }\n\n//       return $(foundElements);\n//     }\n\n//     function children(selector) {\n//       const children = []; // eslint-disable-line\n\n//       for (let i = 0; i < this.length; i += 1) {\n//         const childNodes = this[i].children;\n\n//         for (let j = 0; j < childNodes.length; j += 1) {\n//           if (!selector || $(childNodes[j]).is(selector)) {\n//             children.push(childNodes[j]);\n//           }\n//         }\n//       }\n\n//       return $(children);\n//     }\n\n//     function remove() {\n//       for (let i = 0; i < this.length; i += 1) {\n//         if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);\n//       }\n\n//       return this;\n//     }\n\n//     const Methods = {\n//       addClass,\n//       removeClass,\n//       hasClass,\n//       toggleClass,\n//       attr,\n//       removeAttr,\n//       transform,\n//       transition: transition$1,\n//       on,\n//       off,\n//       trigger,\n//       transitionEnd: transitionEnd$1,\n//       outerWidth,\n//       outerHeight,\n//       styles,\n//       offset,\n//       css,\n//       each,\n//       html,\n//       text,\n//       is,\n//       index,\n//       eq,\n//       append,\n//       prepend,\n//       next,\n//       nextAll,\n//       prev,\n//       prevAll,\n//       parent,\n//       parents,\n//       closest,\n//       find,\n//       children,\n//       filter,\n//       remove,\n//     };\n//     Object.keys(Methods).forEach((methodName) => {\n//       Object.defineProperty($.fn, methodName, {\n//         value: Methods[methodName],\n//         writable: true,\n//       });\n//     });\n\n//     function deleteProps(obj) {\n//       const object = obj;\n//       Object.keys(object).forEach((key) => {\n//         try {\n//           object[key] = null;\n//         } catch (e) {\n//           // no getter for object\n//         }\n\n//         try {\n//           delete object[key];\n//         } catch (e) {\n//           // something got wrong\n//         }\n//       });\n//     }\n\n//     function nextTick(callback, delay = 0) {\n//       return setTimeout(callback, delay);\n//     }\n\n//     function now() {\n//       return Date.now();\n//     }\n\n//     function getComputedStyle$1(el) {\n//       const window = getWindow();\n//       let style;\n\n//       if (window.getComputedStyle) {\n//         style = window.getComputedStyle(el, null);\n//       }\n\n//       if (!style && el.currentStyle) {\n//         style = el.currentStyle;\n//       }\n\n//       if (!style) {\n//         style = el.style;\n//       }\n\n//       return style;\n//     }\n\n//     function getTranslate(el, axis = 'x') {\n//       const window = getWindow();\n//       let matrix;\n//       let curTransform;\n//       let transformMatrix;\n//       const curStyle = getComputedStyle$1(el);\n\n//       if (window.WebKitCSSMatrix) {\n//         curTransform = curStyle.transform || curStyle.webkitTransform;\n\n//         if (curTransform.split(',').length > 6) {\n//           curTransform = curTransform\n//             .split(', ')\n//             .map((a) => a.replace(',', '.'))\n//             .join(', ');\n//         } // Some old versions of Webkit choke when 'none' is passed; pass\n//         // empty string instead in this case\n\n//         transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n//       } else {\n//         transformMatrix =\n//           curStyle.MozTransform ||\n//           curStyle.OTransform ||\n//           curStyle.MsTransform ||\n//           curStyle.msTransform ||\n//           curStyle.transform ||\n//           curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n//         matrix = transformMatrix.toString().split(',');\n//       }\n\n//       if (axis === 'x') {\n//         // Latest Chrome and webkits Fix\n//         if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix\n//         else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers\n//         else curTransform = parseFloat(matrix[4]);\n//       }\n\n//       if (axis === 'y') {\n//         // Latest Chrome and webkits Fix\n//         if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix\n//         else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers\n//         else curTransform = parseFloat(matrix[5]);\n//       }\n\n//       return curTransform || 0;\n//     }\n\n//     function isObject(o) {\n//       return (\n//         typeof o === 'object' &&\n//         o !== null &&\n//         o.constructor &&\n//         Object.prototype.toString.call(o).slice(8, -1) === 'Object'\n//       );\n//     }\n\n//     function isNode(node) {\n//       // eslint-disable-next-line\n//       if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n//         return node instanceof HTMLElement;\n//       }\n\n//       return node && (node.nodeType === 1 || node.nodeType === 11);\n//     }\n\n//     function extend(...args) {\n//       const to = Object(args[0]);\n//       const noExtend = ['__proto__', 'constructor', 'prototype'];\n\n//       for (let i = 1; i < args.length; i += 1) {\n//         const nextSource = args[i];\n\n//         if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n//           const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);\n\n//           for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n//             const nextKey = keysArray[nextIndex];\n//             const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n\n//             if (desc !== undefined && desc.enumerable) {\n//               if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n//                 if (nextSource[nextKey].__swiper__) {\n//                   to[nextKey] = nextSource[nextKey];\n//                 } else {\n//                   extend(to[nextKey], nextSource[nextKey]);\n//                 }\n//               } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n//                 to[nextKey] = {};\n\n//                 if (nextSource[nextKey].__swiper__) {\n//                   to[nextKey] = nextSource[nextKey];\n//                 } else {\n//                   extend(to[nextKey], nextSource[nextKey]);\n//                 }\n//               } else {\n//                 to[nextKey] = nextSource[nextKey];\n//               }\n//             }\n//           }\n//         }\n//       }\n\n//       return to;\n//     }\n\n//     function setCSSProperty(el, varName, varValue) {\n//       el.style.setProperty(varName, varValue);\n//     }\n\n//     function animateCSSModeScroll({swiper, targetPosition, side}) {\n//       const window = getWindow();\n//       const startPosition = -swiper.translate;\n//       let startTime = null;\n//       let time;\n//       const duration = swiper.params.speed;\n//       swiper.wrapperEl.style.scrollSnapType = 'none';\n//       window.cancelAnimationFrame(swiper.cssModeFrameID);\n//       const dir = targetPosition > startPosition ? 'next' : 'prev';\n\n//       const isOutOfBound = (current, target) => {\n//         return (dir === 'next' && current >= target) || (dir === 'prev' && current <= target);\n//       };\n\n//       const animate = () => {\n//         time = new Date().getTime();\n\n//         if (startTime === null) {\n//           startTime = time;\n//         }\n\n//         const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n//         const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n//         let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n\n//         if (isOutOfBound(currentPosition, targetPosition)) {\n//           currentPosition = targetPosition;\n//         }\n\n//         swiper.wrapperEl.scrollTo({\n//           [side]: currentPosition,\n//         });\n\n//         if (isOutOfBound(currentPosition, targetPosition)) {\n//           swiper.wrapperEl.style.overflow = 'hidden';\n//           swiper.wrapperEl.style.scrollSnapType = '';\n//           setTimeout(() => {\n//             swiper.wrapperEl.style.overflow = '';\n//             swiper.wrapperEl.scrollTo({\n//               [side]: currentPosition,\n//             });\n//           });\n//           window.cancelAnimationFrame(swiper.cssModeFrameID);\n//           return;\n//         }\n\n//         swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n//       };\n\n//       animate();\n//     }\n\n//     let support;\n\n//     function calcSupport() {\n//       const window = getWindow();\n//       const document = getDocument();\n//       return {\n//         smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,\n//         touch: !!('ontouchstart' in window || (window.DocumentTouch && document instanceof window.DocumentTouch)),\n//         passiveListener: (function checkPassiveListener() {\n//           let supportsPassive = false;\n\n//           try {\n//             const opts = Object.defineProperty({}, 'passive', {\n//               // eslint-disable-next-line\n//               get() {\n//                 supportsPassive = true;\n//               },\n//             });\n//             window.addEventListener('testPassiveListener', null, opts);\n//           } catch (e) {\n//             // No support\n//           }\n\n//           return supportsPassive;\n//         })(),\n//         gestures: (function checkGestures() {\n//           return 'ongesturestart' in window;\n//         })(),\n//       };\n//     }\n\n//     function getSupport() {\n//       if (!support) {\n//         support = calcSupport();\n//       }\n\n//       return support;\n//     }\n\n//     let deviceCached;\n\n//     function calcDevice({userAgent} = {}) {\n//       const support = getSupport();\n//       const window = getWindow();\n//       const platform = window.navigator.platform;\n//       const ua = userAgent || window.navigator.userAgent;\n//       const device = {\n//         ios: false,\n//         android: false,\n//       };\n//       const screenWidth = window.screen.width;\n//       const screenHeight = window.screen.height;\n//       const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n\n//       let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n//       const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n//       const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n//       const windows = platform === 'Win32';\n//       let macos = platform === 'MacIntel'; // iPadOs 13 fix\n\n//       const iPadScreens = [\n//         '1024x1366',\n//         '1366x1024',\n//         '834x1194',\n//         '1194x834',\n//         '834x1112',\n//         '1112x834',\n//         '768x1024',\n//         '1024x768',\n//         '820x1180',\n//         '1180x820',\n//         '810x1080',\n//         '1080x810',\n//       ];\n\n//       if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n//         ipad = ua.match(/(Version)\\/([\\d.]+)/);\n//         if (!ipad) ipad = [0, 1, '13_0_0'];\n//         macos = false;\n//       } // Android\n\n//       if (android && !windows) {\n//         device.os = 'android';\n//         device.android = true;\n//       }\n\n//       if (ipad || iphone || ipod) {\n//         device.os = 'ios';\n//         device.ios = true;\n//       } // Export object\n\n//       return device;\n//     }\n\n//     function getDevice(overrides = {}) {\n//       if (!deviceCached) {\n//         deviceCached = calcDevice(overrides);\n//       }\n\n//       return deviceCached;\n//     }\n\n//     let browser;\n\n//     function calcBrowser() {\n//       const window = getWindow();\n\n//       function isSafari() {\n//         const ua = window.navigator.userAgent.toLowerCase();\n//         return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n//       }\n\n//       return {\n//         isSafari: isSafari(),\n//         isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),\n//       };\n//     }\n\n//     function getBrowser() {\n//       if (!browser) {\n//         browser = calcBrowser();\n//       }\n\n//       return browser;\n//     }\n\n//     function Resize({swiper, on, emit}) {\n//       const window = getWindow();\n//       let observer = null;\n\n//       const resizeHandler = () => {\n//         if (!swiper || swiper.destroyed || !swiper.initialized) return;\n//         emit('beforeResize');\n//         emit('resize');\n//       };\n\n//       const createObserver = () => {\n//         if (!swiper || swiper.destroyed || !swiper.initialized) return;\n//         observer = new ResizeObserver((entries) => {\n//           const {width, height} = swiper;\n//           let newWidth = width;\n//           let newHeight = height;\n//           entries.forEach(({contentBoxSize, contentRect, target}) => {\n//             if (target && target !== swiper.el) return;\n//             newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n//             newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n//           });\n\n//           if (newWidth !== width || newHeight !== height) {\n//             resizeHandler();\n//           }\n//         });\n//         observer.observe(swiper.el);\n//       };\n\n//       const removeObserver = () => {\n//         if (observer && observer.unobserve && swiper.el) {\n//           observer.unobserve(swiper.el);\n//           observer = null;\n//         }\n//       };\n\n//       const orientationChangeHandler = () => {\n//         if (!swiper || swiper.destroyed || !swiper.initialized) return;\n//         emit('orientationchange');\n//       };\n\n//       on('init', () => {\n//         if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n//           createObserver();\n//           return;\n//         }\n\n//         window.addEventListener('resize', resizeHandler);\n//         window.addEventListener('orientationchange', orientationChangeHandler);\n//       });\n//       on('destroy', () => {\n//         removeObserver();\n//         window.removeEventListener('resize', resizeHandler);\n//         window.removeEventListener('orientationchange', orientationChangeHandler);\n//       });\n//     }\n\n//     function Observer({swiper, extendParams, on, emit}) {\n//       const observers = [];\n//       const window = getWindow();\n\n//       const attach = (target, options = {}) => {\n//         const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n//         const observer = new ObserverFunc((mutations) => {\n//           // The observerUpdate event should only be triggered\n//           // once despite the number of mutations.  Additional\n//           // triggers are redundant and are very costly\n//           if (mutations.length === 1) {\n//             emit('observerUpdate', mutations[0]);\n//             return;\n//           }\n\n//           const observerUpdate = function observerUpdate() {\n//             emit('observerUpdate', mutations[0]);\n//           };\n\n//           if (window.requestAnimationFrame) {\n//             window.requestAnimationFrame(observerUpdate);\n//           } else {\n//             window.setTimeout(observerUpdate, 0);\n//           }\n//         });\n//         observer.observe(target, {\n//           attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n//           childList: typeof options.childList === 'undefined' ? true : options.childList,\n//           characterData: typeof options.characterData === 'undefined' ? true : options.characterData,\n//         });\n//         observers.push(observer);\n//       };\n\n//       const init = () => {\n//         if (!swiper.params.observer) return;\n\n//         if (swiper.params.observeParents) {\n//           const containerParents = swiper.$el.parents();\n\n//           for (let i = 0; i < containerParents.length; i += 1) {\n//             attach(containerParents[i]);\n//           }\n//         } // Observe container\n\n//         attach(swiper.$el[0], {\n//           childList: swiper.params.observeSlideChildren,\n//         }); // Observe wrapper\n\n//         attach(swiper.$wrapperEl[0], {\n//           attributes: false,\n//         });\n//       };\n\n//       const destroy = () => {\n//         observers.forEach((observer) => {\n//           observer.disconnect();\n//         });\n//         observers.splice(0, observers.length);\n//       };\n\n//       extendParams({\n//         observer: false,\n//         observeParents: false,\n//         observeSlideChildren: false,\n//       });\n//       on('init', init);\n//       on('destroy', destroy);\n//     }\n\n//     /* eslint-disable no-underscore-dangle */\n//     var eventsEmitter = {\n//       on(events, handler, priority) {\n//         const self = this;\n//         if (typeof handler !== 'function') return self;\n//         const method = priority ? 'unshift' : 'push';\n//         events.split(' ').forEach((event) => {\n//           if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n//           self.eventsListeners[event][method](handler);\n//         });\n//         return self;\n//       },\n\n//       once(events, handler, priority) {\n//         const self = this;\n//         if (typeof handler !== 'function') return self;\n\n//         function onceHandler(...args) {\n//           self.off(events, onceHandler);\n\n//           if (onceHandler.__emitterProxy) {\n//             delete onceHandler.__emitterProxy;\n//           }\n\n//           handler.apply(self, args);\n//         }\n\n//         onceHandler.__emitterProxy = handler;\n//         return self.on(events, onceHandler, priority);\n//       },\n\n//       onAny(handler, priority) {\n//         const self = this;\n//         if (typeof handler !== 'function') return self;\n//         const method = priority ? 'unshift' : 'push';\n\n//         if (self.eventsAnyListeners.indexOf(handler) < 0) {\n//           self.eventsAnyListeners[method](handler);\n//         }\n\n//         return self;\n//       },\n\n//       offAny(handler) {\n//         const self = this;\n//         if (!self.eventsAnyListeners) return self;\n//         const index = self.eventsAnyListeners.indexOf(handler);\n\n//         if (index >= 0) {\n//           self.eventsAnyListeners.splice(index, 1);\n//         }\n\n//         return self;\n//       },\n\n//       off(events, handler) {\n//         const self = this;\n//         if (!self.eventsListeners) return self;\n//         events.split(' ').forEach((event) => {\n//           if (typeof handler === 'undefined') {\n//             self.eventsListeners[event] = [];\n//           } else if (self.eventsListeners[event]) {\n//             self.eventsListeners[event].forEach((eventHandler, index) => {\n//               if (\n//                 eventHandler === handler ||\n//                 (eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler)\n//               ) {\n//                 self.eventsListeners[event].splice(index, 1);\n//               }\n//             });\n//           }\n//         });\n//         return self;\n//       },\n\n//       emit(...args) {\n//         const self = this;\n//         if (!self.eventsListeners) return self;\n//         let events;\n//         let data;\n//         let context;\n\n//         if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n//           events = args[0];\n//           data = args.slice(1, args.length);\n//           context = self;\n//         } else {\n//           events = args[0].events;\n//           data = args[0].data;\n//           context = args[0].context || self;\n//         }\n\n//         data.unshift(context);\n//         const eventsArray = Array.isArray(events) ? events : events.split(' ');\n//         eventsArray.forEach((event) => {\n//           if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n//             self.eventsAnyListeners.forEach((eventHandler) => {\n//               eventHandler.apply(context, [event, ...data]);\n//             });\n//           }\n\n//           if (self.eventsListeners && self.eventsListeners[event]) {\n//             self.eventsListeners[event].forEach((eventHandler) => {\n//               eventHandler.apply(context, data);\n//             });\n//           }\n//         });\n//         return self;\n//       },\n//     };\n\n//     function updateSize() {\n//       const swiper = this;\n//       let width;\n//       let height;\n//       const $el = swiper.$el;\n\n//       if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n//         width = swiper.params.width;\n//       } else {\n//         width = $el[0].clientWidth;\n//       }\n\n//       if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n//         height = swiper.params.height;\n//       } else {\n//         height = $el[0].clientHeight;\n//       }\n\n//       if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {\n//         return;\n//       } // Subtract paddings\n\n//       width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);\n//       height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);\n//       if (Number.isNaN(width)) width = 0;\n//       if (Number.isNaN(height)) height = 0;\n//       Object.assign(swiper, {\n//         width,\n//         height,\n//         size: swiper.isHorizontal() ? width : height,\n//       });\n//     }\n\n//     function updateSlides() {\n//       const swiper = this;\n\n//       function getDirectionLabel(property) {\n//         if (swiper.isHorizontal()) {\n//         return property;\n//       } // prettier-ignore\n\n//         return {\n//           width: 'height',\n//           'margin-top': 'margin-left',\n//           'margin-bottom ': 'margin-right',\n//           'margin-left': 'margin-top',\n//           'margin-right': 'margin-bottom',\n//           'padding-left': 'padding-top',\n//           'padding-right': 'padding-bottom',\n//           marginRight: 'marginBottom',\n//         }[property];\n//       }\n\n//       function getDirectionPropertyValue(node, label) {\n//         return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n//       }\n\n//       const params = swiper.params;\n//       const {$wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL} = swiper;\n//       const isVirtual = swiper.virtual && params.virtual.enabled;\n//       const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n//       const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);\n//       const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n//       let snapGrid = [];\n//       const slidesGrid = [];\n//       const slidesSizesGrid = [];\n//       let offsetBefore = params.slidesOffsetBefore;\n\n//       if (typeof offsetBefore === 'function') {\n//         offsetBefore = params.slidesOffsetBefore.call(swiper);\n//       }\n\n//       let offsetAfter = params.slidesOffsetAfter;\n\n//       if (typeof offsetAfter === 'function') {\n//         offsetAfter = params.slidesOffsetAfter.call(swiper);\n//       }\n\n//       const previousSnapGridLength = swiper.snapGrid.length;\n//       const previousSlidesGridLength = swiper.slidesGrid.length;\n//       let spaceBetween = params.spaceBetween;\n//       let slidePosition = -offsetBefore;\n//       let prevSlideSize = 0;\n//       let index = 0;\n\n//       if (typeof swiperSize === 'undefined') {\n//         return;\n//       }\n\n//       if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n//         spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;\n//       }\n\n//       swiper.virtualSize = -spaceBetween; // reset margins\n\n//       if (rtl)\n//         slides.css({\n//           marginLeft: '',\n//           marginBottom: '',\n//           marginTop: '',\n//         });\n//       else\n//         slides.css({\n//           marginRight: '',\n//           marginBottom: '',\n//           marginTop: '',\n//         }); // reset cssMode offsets\n\n//       if (params.centeredSlides && params.cssMode) {\n//         setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');\n//         setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');\n//       }\n\n//       const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n\n//       if (gridEnabled) {\n//         swiper.grid.initSlides(slidesLength);\n//       } // Calc slides\n\n//       let slideSize;\n//       const shouldResetSlideSize =\n//         params.slidesPerView === 'auto' &&\n//         params.breakpoints &&\n//         Object.keys(params.breakpoints).filter((key) => {\n//           return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n//         }).length > 0;\n\n//       for (let i = 0; i < slidesLength; i += 1) {\n//         slideSize = 0;\n//         const slide = slides.eq(i);\n\n//         if (gridEnabled) {\n//           swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n//         }\n\n//         if (slide.css('display') === 'none') continue; // eslint-disable-line\n\n//         if (params.slidesPerView === 'auto') {\n//           if (shouldResetSlideSize) {\n//             slides[i].style[getDirectionLabel('width')] = ``;\n//           }\n\n//           const slideStyles = getComputedStyle(slide[0]);\n//           const currentTransform = slide[0].style.transform;\n//           const currentWebKitTransform = slide[0].style.webkitTransform;\n\n//           if (currentTransform) {\n//             slide[0].style.transform = 'none';\n//           }\n\n//           if (currentWebKitTransform) {\n//             slide[0].style.webkitTransform = 'none';\n//           }\n\n//           if (params.roundLengths) {\n//             slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);\n//           } else {\n//             // eslint-disable-next-line\n//             const width = getDirectionPropertyValue(slideStyles, 'width');\n//             const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n//             const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n//             const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n//             const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n//             const boxSizing = slideStyles.getPropertyValue('box-sizing');\n\n//             if (boxSizing && boxSizing === 'border-box') {\n//               slideSize = width + marginLeft + marginRight;\n//             } else {\n//               const {clientWidth, offsetWidth} = slide[0];\n//               slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n//             }\n//           }\n\n//           if (currentTransform) {\n//             slide[0].style.transform = currentTransform;\n//           }\n\n//           if (currentWebKitTransform) {\n//             slide[0].style.webkitTransform = currentWebKitTransform;\n//           }\n\n//           if (params.roundLengths) slideSize = Math.floor(slideSize);\n//         } else {\n//           slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n//           if (params.roundLengths) slideSize = Math.floor(slideSize);\n\n//           if (slides[i]) {\n//             slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n//           }\n//         }\n\n//         if (slides[i]) {\n//           slides[i].swiperSlideSize = slideSize;\n//         }\n\n//         slidesSizesGrid.push(slideSize);\n\n//         if (params.centeredSlides) {\n//           slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n//           if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n//           if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n//           if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n//           if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n//           if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n//           slidesGrid.push(slidePosition);\n//         } else {\n//           if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n//           if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0)\n//             snapGrid.push(slidePosition);\n//           slidesGrid.push(slidePosition);\n//           slidePosition = slidePosition + slideSize + spaceBetween;\n//         }\n\n//         swiper.virtualSize += slideSize + spaceBetween;\n//         prevSlideSize = slideSize;\n//         index += 1;\n//       }\n\n//       swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n\n//       if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n//         $wrapperEl.css({\n//           width: `${swiper.virtualSize + params.spaceBetween}px`,\n//         });\n//       }\n\n//       if (params.setWrapperSize) {\n//         $wrapperEl.css({\n//           [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`,\n//         });\n//       }\n\n//       if (gridEnabled) {\n//         swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n//       } // Remove last grid elements depending on width\n\n//       if (!params.centeredSlides) {\n//         const newSlidesGrid = [];\n\n//         for (let i = 0; i < snapGrid.length; i += 1) {\n//           let slidesGridItem = snapGrid[i];\n//           if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n\n//           if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n//             newSlidesGrid.push(slidesGridItem);\n//           }\n//         }\n\n//         snapGrid = newSlidesGrid;\n\n//         if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n//           snapGrid.push(swiper.virtualSize - swiperSize);\n//         }\n//       }\n\n//       if (snapGrid.length === 0) snapGrid = [0];\n\n//       if (params.spaceBetween !== 0) {\n//         const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n//         slides\n//           .filter((_, slideIndex) => {\n//             if (!params.cssMode) return true;\n\n//             if (slideIndex === slides.length - 1) {\n//               return false;\n//             }\n\n//             return true;\n//           })\n//           .css({\n//             [key]: `${spaceBetween}px`,\n//           });\n//       }\n\n//       if (params.centeredSlides && params.centeredSlidesBounds) {\n//         let allSlidesSize = 0;\n//         slidesSizesGrid.forEach((slideSizeValue) => {\n//           allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n//         });\n//         allSlidesSize -= params.spaceBetween;\n//         const maxSnap = allSlidesSize - swiperSize;\n//         snapGrid = snapGrid.map((snap) => {\n//           if (snap < 0) return -offsetBefore;\n//           if (snap > maxSnap) return maxSnap + offsetAfter;\n//           return snap;\n//         });\n//       }\n\n//       if (params.centerInsufficientSlides) {\n//         let allSlidesSize = 0;\n//         slidesSizesGrid.forEach((slideSizeValue) => {\n//           allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n//         });\n//         allSlidesSize -= params.spaceBetween;\n\n//         if (allSlidesSize < swiperSize) {\n//           const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n//           snapGrid.forEach((snap, snapIndex) => {\n//             snapGrid[snapIndex] = snap - allSlidesOffset;\n//           });\n//           slidesGrid.forEach((snap, snapIndex) => {\n//             slidesGrid[snapIndex] = snap + allSlidesOffset;\n//           });\n//         }\n//       }\n\n//       Object.assign(swiper, {\n//         slides,\n//         snapGrid,\n//         slidesGrid,\n//         slidesSizesGrid,\n//       });\n\n//       if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n//         setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n//         setCSSProperty(\n//           swiper.wrapperEl,\n//           '--swiper-centered-offset-after',\n//           `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`,\n//         );\n//         const addToSnapGrid = -swiper.snapGrid[0];\n//         const addToSlidesGrid = -swiper.slidesGrid[0];\n//         swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);\n//         swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);\n//       }\n\n//       if (slidesLength !== previousSlidesLength) {\n//         swiper.emit('slidesLengthChange');\n//       }\n\n//       if (snapGrid.length !== previousSnapGridLength) {\n//         if (swiper.params.watchOverflow) swiper.checkOverflow();\n//         swiper.emit('snapGridLengthChange');\n//       }\n\n//       if (slidesGrid.length !== previousSlidesGridLength) {\n//         swiper.emit('slidesGridLengthChange');\n//       }\n\n//       if (params.watchSlidesProgress) {\n//         swiper.updateSlidesOffset();\n//       }\n//     }\n\n//     function updateAutoHeight(speed) {\n//       const swiper = this;\n//       const activeSlides = [];\n//       const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n//       let newHeight = 0;\n//       let i;\n\n//       if (typeof speed === 'number') {\n//         swiper.setTransition(speed);\n//       } else if (speed === true) {\n//         swiper.setTransition(swiper.params.speed);\n//       }\n\n//       const getSlideByIndex = (index) => {\n//         if (isVirtual) {\n//           return swiper.slides.filter((el) => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];\n//         }\n\n//         return swiper.slides.eq(index)[0];\n//       }; // Find slides currently in view\n\n//       if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n//         if (swiper.params.centeredSlides) {\n//           swiper.visibleSlides.each((slide) => {\n//             activeSlides.push(slide);\n//           });\n//         } else {\n//           for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n//             const index = swiper.activeIndex + i;\n//             if (index > swiper.slides.length && !isVirtual) break;\n//             activeSlides.push(getSlideByIndex(index));\n//           }\n//         }\n//       } else {\n//         activeSlides.push(getSlideByIndex(swiper.activeIndex));\n//       } // Find new height from highest slide in view\n\n//       for (i = 0; i < activeSlides.length; i += 1) {\n//         if (typeof activeSlides[i] !== 'undefined') {\n//           const height = activeSlides[i].offsetHeight;\n//           newHeight = height > newHeight ? height : newHeight;\n//         }\n//       } // Update Height\n\n//       if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);\n//     }\n\n//     function updateSlidesOffset() {\n//       const swiper = this;\n//       const slides = swiper.slides;\n\n//       for (let i = 0; i < slides.length; i += 1) {\n//         slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;\n//       }\n//     }\n\n//     function updateSlidesProgress(translate = (this && this.translate) || 0) {\n//       const swiper = this;\n//       const params = swiper.params;\n//       const {slides, rtlTranslate: rtl, snapGrid} = swiper;\n//       if (slides.length === 0) return;\n//       if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n//       let offsetCenter = -translate;\n//       if (rtl) offsetCenter = translate; // Visible Slides\n\n//       slides.removeClass(params.slideVisibleClass);\n//       swiper.visibleSlidesIndexes = [];\n//       swiper.visibleSlides = [];\n\n//       for (let i = 0; i < slides.length; i += 1) {\n//         const slide = slides[i];\n//         let slideOffset = slide.swiperSlideOffset;\n\n//         if (params.cssMode && params.centeredSlides) {\n//           slideOffset -= slides[0].swiperSlideOffset;\n//         }\n\n//         const slideProgress =\n//           (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) /\n//           (slide.swiperSlideSize + params.spaceBetween);\n//         const originalSlideProgress =\n//           (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) /\n//           (slide.swiperSlideSize + params.spaceBetween);\n//         const slideBefore = -(offsetCenter - slideOffset);\n//         const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n//         const isVisible =\n//           (slideBefore >= 0 && slideBefore < swiper.size - 1) ||\n//           (slideAfter > 1 && slideAfter <= swiper.size) ||\n//           (slideBefore <= 0 && slideAfter >= swiper.size);\n\n//         if (isVisible) {\n//           swiper.visibleSlides.push(slide);\n//           swiper.visibleSlidesIndexes.push(i);\n//           slides.eq(i).addClass(params.slideVisibleClass);\n//         }\n\n//         slide.progress = rtl ? -slideProgress : slideProgress;\n//         slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n//       }\n\n//       swiper.visibleSlides = $(swiper.visibleSlides);\n//     }\n\n//     function updateProgress(translate) {\n//       const swiper = this;\n\n//       if (typeof translate === 'undefined') {\n//         const multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line\n\n//         translate = (swiper && swiper.translate && swiper.translate * multiplier) || 0;\n//       }\n\n//       const params = swiper.params;\n//       const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n//       let {progress, isBeginning, isEnd} = swiper;\n//       const wasBeginning = isBeginning;\n//       const wasEnd = isEnd;\n\n//       if (translatesDiff === 0) {\n//         progress = 0;\n//         isBeginning = true;\n//         isEnd = true;\n//       } else {\n//         progress = (translate - swiper.minTranslate()) / translatesDiff;\n//         isBeginning = progress <= 0;\n//         isEnd = progress >= 1;\n//       }\n\n//       Object.assign(swiper, {\n//         progress,\n//         isBeginning,\n//         isEnd,\n//       });\n//       if (params.watchSlidesProgress || (params.centeredSlides && params.autoHeight))\n//         swiper.updateSlidesProgress(translate);\n\n//       if (isBeginning && !wasBeginning) {\n//         swiper.emit('reachBeginning toEdge');\n//       }\n\n//       if (isEnd && !wasEnd) {\n//         swiper.emit('reachEnd toEdge');\n//       }\n\n//       if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {\n//         swiper.emit('fromEdge');\n//       }\n\n//       swiper.emit('progress', progress);\n//     }\n\n//     function updateSlidesClasses() {\n//       const swiper = this;\n//       const {slides, params, $wrapperEl, activeIndex, realIndex} = swiper;\n//       const isVirtual = swiper.virtual && params.virtual.enabled;\n//       slides.removeClass(\n//         `${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`,\n//       );\n//       let activeSlide;\n\n//       if (isVirtual) {\n//         activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index=\"${activeIndex}\"]`);\n//       } else {\n//         activeSlide = slides.eq(activeIndex);\n//       } // Active classes\n\n//       activeSlide.addClass(params.slideActiveClass);\n\n//       if (params.loop) {\n//         // Duplicate to all looped slides\n//         if (activeSlide.hasClass(params.slideDuplicateClass)) {\n//           $wrapperEl\n//             .children(\n//               `.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${realIndex}\"]`,\n//             )\n//             .addClass(params.slideDuplicateActiveClass);\n//         } else {\n//           $wrapperEl\n//             .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${realIndex}\"]`)\n//             .addClass(params.slideDuplicateActiveClass);\n//         }\n//       } // Next Slide\n\n//       let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);\n\n//       if (params.loop && nextSlide.length === 0) {\n//         nextSlide = slides.eq(0);\n//         nextSlide.addClass(params.slideNextClass);\n//       } // Prev Slide\n\n//       let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);\n\n//       if (params.loop && prevSlide.length === 0) {\n//         prevSlide = slides.eq(-1);\n//         prevSlide.addClass(params.slidePrevClass);\n//       }\n\n//       if (params.loop) {\n//         // Duplicate to all looped slides\n//         if (nextSlide.hasClass(params.slideDuplicateClass)) {\n//           $wrapperEl\n//             .children(\n//               `.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${nextSlide.attr(\n//                 'data-swiper-slide-index',\n//               )}\"]`,\n//             )\n//             .addClass(params.slideDuplicateNextClass);\n//         } else {\n//           $wrapperEl\n//             .children(\n//               `.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${nextSlide.attr(\n//                 'data-swiper-slide-index',\n//               )}\"]`,\n//             )\n//             .addClass(params.slideDuplicateNextClass);\n//         }\n\n//         if (prevSlide.hasClass(params.slideDuplicateClass)) {\n//           $wrapperEl\n//             .children(\n//               `.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${prevSlide.attr(\n//                 'data-swiper-slide-index',\n//               )}\"]`,\n//             )\n//             .addClass(params.slideDuplicatePrevClass);\n//         } else {\n//           $wrapperEl\n//             .children(\n//               `.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${prevSlide.attr(\n//                 'data-swiper-slide-index',\n//               )}\"]`,\n//             )\n//             .addClass(params.slideDuplicatePrevClass);\n//         }\n//       }\n\n//       swiper.emitSlidesClasses();\n//     }\n\n//     function updateActiveIndex(newActiveIndex) {\n//       const swiper = this;\n//       const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n//       const {\n//         slidesGrid,\n//         snapGrid,\n//         params,\n//         activeIndex: previousIndex,\n//         realIndex: previousRealIndex,\n//         snapIndex: previousSnapIndex,\n//       } = swiper;\n//       let activeIndex = newActiveIndex;\n//       let snapIndex;\n\n//       if (typeof activeIndex === 'undefined') {\n//         for (let i = 0; i < slidesGrid.length; i += 1) {\n//           if (typeof slidesGrid[i + 1] !== 'undefined') {\n//             if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n//               activeIndex = i;\n//             } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n//               activeIndex = i + 1;\n//             }\n//           } else if (translate >= slidesGrid[i]) {\n//             activeIndex = i;\n//           }\n//         } // Normalize slideIndex\n\n//         if (params.normalizeSlideIndex) {\n//           if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n//         }\n//       }\n\n//       if (snapGrid.indexOf(translate) >= 0) {\n//         snapIndex = snapGrid.indexOf(translate);\n//       } else {\n//         const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n//         snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n//       }\n\n//       if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n//       if (activeIndex === previousIndex) {\n//         if (snapIndex !== previousSnapIndex) {\n//           swiper.snapIndex = snapIndex;\n//           swiper.emit('snapIndexChange');\n//         }\n\n//         return;\n//       } // Get real index\n\n//       const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);\n//       Object.assign(swiper, {\n//         snapIndex,\n//         realIndex,\n//         previousIndex,\n//         activeIndex,\n//       });\n//       swiper.emit('activeIndexChange');\n//       swiper.emit('snapIndexChange');\n\n//       if (previousRealIndex !== realIndex) {\n//         swiper.emit('realIndexChange');\n//       }\n\n//       if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n//         swiper.emit('slideChange');\n//       }\n//     }\n\n//     function updateClickedSlide(e) {\n//       const swiper = this;\n//       const params = swiper.params;\n//       const slide = $(e).closest(`.${params.slideClass}`)[0];\n//       let slideFound = false;\n//       let slideIndex;\n\n//       if (slide) {\n//         for (let i = 0; i < swiper.slides.length; i += 1) {\n//           if (swiper.slides[i] === slide) {\n//             slideFound = true;\n//             slideIndex = i;\n//             break;\n//           }\n//         }\n//       }\n\n//       if (slide && slideFound) {\n//         swiper.clickedSlide = slide;\n\n//         if (swiper.virtual && swiper.params.virtual.enabled) {\n//           swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);\n//         } else {\n//           swiper.clickedIndex = slideIndex;\n//         }\n//       } else {\n//         swiper.clickedSlide = undefined;\n//         swiper.clickedIndex = undefined;\n//         return;\n//       }\n\n//       if (\n//         params.slideToClickedSlide &&\n//         swiper.clickedIndex !== undefined &&\n//         swiper.clickedIndex !== swiper.activeIndex\n//       ) {\n//         swiper.slideToClickedSlide();\n//       }\n//     }\n\n//     var update = {\n//       updateSize,\n//       updateSlides,\n//       updateAutoHeight,\n//       updateSlidesOffset,\n//       updateSlidesProgress,\n//       updateProgress,\n//       updateSlidesClasses,\n//       updateActiveIndex,\n//       updateClickedSlide,\n//     };\n\n//     function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {\n//       const swiper = this;\n//       const {params, rtlTranslate: rtl, translate, $wrapperEl} = swiper;\n\n//       if (params.virtualTranslate) {\n//         return rtl ? -translate : translate;\n//       }\n\n//       if (params.cssMode) {\n//         return translate;\n//       }\n\n//       let currentTranslate = getTranslate($wrapperEl[0], axis);\n//       if (rtl) currentTranslate = -currentTranslate;\n//       return currentTranslate || 0;\n//     }\n\n//     function setTranslate(translate, byController) {\n//       const swiper = this;\n//       const {rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress} = swiper;\n//       let x = 0;\n//       let y = 0;\n//       const z = 0;\n\n//       if (swiper.isHorizontal()) {\n//         x = rtl ? -translate : translate;\n//       } else {\n//         y = translate;\n//       }\n\n//       if (params.roundLengths) {\n//         x = Math.floor(x);\n//         y = Math.floor(y);\n//       }\n\n//       if (params.cssMode) {\n//         wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n//       } else if (!params.virtualTranslate) {\n//         $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);\n//       }\n\n//       swiper.previousTranslate = swiper.translate;\n//       swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress\n\n//       let newProgress;\n//       const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n\n//       if (translatesDiff === 0) {\n//         newProgress = 0;\n//       } else {\n//         newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n//       }\n\n//       if (newProgress !== progress) {\n//         swiper.updateProgress(translate);\n//       }\n\n//       swiper.emit('setTranslate', swiper.translate, byController);\n//     }\n\n//     function minTranslate() {\n//       return -this.snapGrid[0];\n//     }\n\n//     function maxTranslate() {\n//       return -this.snapGrid[this.snapGrid.length - 1];\n//     }\n\n//     function translateTo(\n//       translate = 0,\n//       speed = this.params.speed,\n//       runCallbacks = true,\n//       translateBounds = true,\n//       internal,\n//     ) {\n//       const swiper = this;\n//       const {params, wrapperEl} = swiper;\n\n//       if (swiper.animating && params.preventInteractionOnTransition) {\n//         return false;\n//       }\n\n//       const minTranslate = swiper.minTranslate();\n//       const maxTranslate = swiper.maxTranslate();\n//       let newTranslate;\n//       if (translateBounds && translate > minTranslate) newTranslate = minTranslate;\n//       else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;\n//       else newTranslate = translate; // Update progress\n\n//       swiper.updateProgress(newTranslate);\n\n//       if (params.cssMode) {\n//         const isH = swiper.isHorizontal();\n\n//         if (speed === 0) {\n//           wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n//         } else {\n//           if (!swiper.support.smoothScroll) {\n//             animateCSSModeScroll({\n//               swiper,\n//               targetPosition: -newTranslate,\n//               side: isH ? 'left' : 'top',\n//             });\n//             return true;\n//           }\n\n//           wrapperEl.scrollTo({\n//             [isH ? 'left' : 'top']: -newTranslate,\n//             behavior: 'smooth',\n//           });\n//         }\n\n//         return true;\n//       }\n\n//       if (speed === 0) {\n//         swiper.setTransition(0);\n//         swiper.setTranslate(newTranslate);\n\n//         if (runCallbacks) {\n//           swiper.emit('beforeTransitionStart', speed, internal);\n//           swiper.emit('transitionEnd');\n//         }\n//       } else {\n//         swiper.setTransition(speed);\n//         swiper.setTranslate(newTranslate);\n\n//         if (runCallbacks) {\n//           swiper.emit('beforeTransitionStart', speed, internal);\n//           swiper.emit('transitionStart');\n//         }\n\n//         if (!swiper.animating) {\n//           swiper.animating = true;\n\n//           if (!swiper.onTranslateToWrapperTransitionEnd) {\n//             swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n//               if (!swiper || swiper.destroyed) return;\n//               if (e.target !== this) return;\n//               swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n//               swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);\n//               swiper.onTranslateToWrapperTransitionEnd = null;\n//               delete swiper.onTranslateToWrapperTransitionEnd;\n\n//               if (runCallbacks) {\n//                 swiper.emit('transitionEnd');\n//               }\n//             };\n//           }\n\n//           swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n//           swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);\n//         }\n//       }\n\n//       return true;\n//     }\n\n//     var translate = {\n//       getTranslate: getSwiperTranslate,\n//       setTranslate,\n//       minTranslate,\n//       maxTranslate,\n//       translateTo,\n//     };\n\n//     function setTransition(duration, byController) {\n//       const swiper = this;\n\n//       if (!swiper.params.cssMode) {\n//         swiper.$wrapperEl.transition(duration);\n//       }\n\n//       swiper.emit('setTransition', duration, byController);\n//     }\n\n//     function transitionEmit({swiper, runCallbacks, direction, step}) {\n//       const {activeIndex, previousIndex} = swiper;\n//       let dir = direction;\n\n//       if (!dir) {\n//         if (activeIndex > previousIndex) dir = 'next';\n//         else if (activeIndex < previousIndex) dir = 'prev';\n//         else dir = 'reset';\n//       }\n\n//       swiper.emit(`transition${step}`);\n\n//       if (runCallbacks && activeIndex !== previousIndex) {\n//         if (dir === 'reset') {\n//           swiper.emit(`slideResetTransition${step}`);\n//           return;\n//         }\n\n//         swiper.emit(`slideChangeTransition${step}`);\n\n//         if (dir === 'next') {\n//           swiper.emit(`slideNextTransition${step}`);\n//         } else {\n//           swiper.emit(`slidePrevTransition${step}`);\n//         }\n//       }\n//     }\n\n//     function transitionStart(runCallbacks = true, direction) {\n//       const swiper = this;\n//       const {params} = swiper;\n//       if (params.cssMode) return;\n\n//       if (params.autoHeight) {\n//         swiper.updateAutoHeight();\n//       }\n\n//       transitionEmit({\n//         swiper,\n//         runCallbacks,\n//         direction,\n//         step: 'Start',\n//       });\n//     }\n\n//     function transitionEnd(runCallbacks = true, direction) {\n//       const swiper = this;\n//       const {params} = swiper;\n//       swiper.animating = false;\n//       if (params.cssMode) return;\n//       swiper.setTransition(0);\n//       transitionEmit({\n//         swiper,\n//         runCallbacks,\n//         direction,\n//         step: 'End',\n//       });\n//     }\n\n//     var transition = {\n//       setTransition,\n//       transitionStart,\n//       transitionEnd,\n//     };\n\n//     function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {\n//       if (typeof index !== 'number' && typeof index !== 'string') {\n//         throw new Error(\n//           `The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`,\n//         );\n//       }\n\n//       if (typeof index === 'string') {\n//         /**\n//          * The `index` argument converted from `string` to `number`.\n//          * @type {number}\n//          */\n//         const indexAsNumber = parseInt(index, 10);\n//         /**\n//          * Determines whether the `index` argument is a valid `number`\n//          * after being converted from the `string` type.\n//          * @type {boolean}\n//          */\n\n//         const isValidNumber = isFinite(indexAsNumber);\n\n//         if (!isValidNumber) {\n//           throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);\n//         } // Knowing that the converted `index` is a valid number,\n//         // we can update the original argument's value.\n\n//         index = indexAsNumber;\n//       }\n\n//       const swiper = this;\n//       let slideIndex = index;\n//       if (slideIndex < 0) slideIndex = 0;\n//       const {params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled} = swiper;\n\n//       if ((swiper.animating && params.preventInteractionOnTransition) || (!enabled && !internal && !initial)) {\n//         return false;\n//       }\n\n//       const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n//       let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n//       if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n//       if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\n//         swiper.emit('beforeSlideChangeStart');\n//       }\n\n//       const translate = -snapGrid[snapIndex]; // Update progress\n\n//       swiper.updateProgress(translate); // Normalize slideIndex\n\n//       if (params.normalizeSlideIndex) {\n//         for (let i = 0; i < slidesGrid.length; i += 1) {\n//           const normalizedTranslate = -Math.floor(translate * 100);\n//           const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n//           const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n\n//           if (typeof slidesGrid[i + 1] !== 'undefined') {\n//             if (\n//               normalizedTranslate >= normalizedGrid &&\n//               normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2\n//             ) {\n//               slideIndex = i;\n//             } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n//               slideIndex = i + 1;\n//             }\n//           } else if (normalizedTranslate >= normalizedGrid) {\n//             slideIndex = i;\n//           }\n//         }\n//       } // Directions locks\n\n//       if (swiper.initialized && slideIndex !== activeIndex) {\n//         if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n//           return false;\n//         }\n\n//         if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n//           if ((activeIndex || 0) !== slideIndex) return false;\n//         }\n//       }\n\n//       let direction;\n//       if (slideIndex > activeIndex) direction = 'next';\n//       else if (slideIndex < activeIndex) direction = 'prev';\n//       else direction = 'reset'; // Update Index\n\n//       if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {\n//         swiper.updateActiveIndex(slideIndex); // Update Height\n\n//         if (params.autoHeight) {\n//           swiper.updateAutoHeight();\n//         }\n\n//         swiper.updateSlidesClasses();\n\n//         if (params.effect !== 'slide') {\n//           swiper.setTranslate(translate);\n//         }\n\n//         if (direction !== 'reset') {\n//           swiper.transitionStart(runCallbacks, direction);\n//           swiper.transitionEnd(runCallbacks, direction);\n//         }\n\n//         return false;\n//       }\n\n//       if (params.cssMode) {\n//         const isH = swiper.isHorizontal();\n//         const t = rtl ? translate : -translate;\n\n//         if (speed === 0) {\n//           const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n//           if (isVirtual) {\n//             swiper.wrapperEl.style.scrollSnapType = 'none';\n//             swiper._immediateVirtual = true;\n//           }\n\n//           wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n\n//           if (isVirtual) {\n//             requestAnimationFrame(() => {\n//               swiper.wrapperEl.style.scrollSnapType = '';\n//               swiper._swiperImmediateVirtual = false;\n//             });\n//           }\n//         } else {\n//           if (!swiper.support.smoothScroll) {\n//             animateCSSModeScroll({\n//               swiper,\n//               targetPosition: t,\n//               side: isH ? 'left' : 'top',\n//             });\n//             return true;\n//           }\n\n//           wrapperEl.scrollTo({\n//             [isH ? 'left' : 'top']: t,\n//             behavior: 'smooth',\n//           });\n//         }\n\n//         return true;\n//       }\n\n//       swiper.setTransition(speed);\n//       swiper.setTranslate(translate);\n//       swiper.updateActiveIndex(slideIndex);\n//       swiper.updateSlidesClasses();\n//       swiper.emit('beforeTransitionStart', speed, internal);\n//       swiper.transitionStart(runCallbacks, direction);\n\n//       if (speed === 0) {\n//         swiper.transitionEnd(runCallbacks, direction);\n//       } else if (!swiper.animating) {\n//         swiper.animating = true;\n\n//         if (!swiper.onSlideToWrapperTransitionEnd) {\n//           swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n//             if (!swiper || swiper.destroyed) return;\n//             if (e.target !== this) return;\n//             swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n//             swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n//             swiper.onSlideToWrapperTransitionEnd = null;\n//             delete swiper.onSlideToWrapperTransitionEnd;\n//             swiper.transitionEnd(runCallbacks, direction);\n//           };\n//         }\n\n//         swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n//         swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n//       }\n\n//       return true;\n//     }\n\n//     function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {\n//       const swiper = this;\n//       let newIndex = index;\n\n//       if (swiper.params.loop) {\n//         newIndex += swiper.loopedSlides;\n//       }\n\n//       return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n//     }\n\n//     /* eslint no-unused-vars: \"off\" */\n//     function slideNext(speed = this.params.speed, runCallbacks = true, internal) {\n//       const swiper = this;\n//       const {animating, enabled, params} = swiper;\n//       if (!enabled) return swiper;\n//       let perGroup = params.slidesPerGroup;\n\n//       if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n//         perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n//       }\n\n//       const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n\n//       if (params.loop) {\n//         if (animating && params.loopPreventsSlide) return false;\n//         swiper.loopFix(); // eslint-disable-next-line\n\n//         swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n//       }\n\n//       if (params.rewind && swiper.isEnd) {\n//         return swiper.slideTo(0, speed, runCallbacks, internal);\n//       }\n\n//       return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n//     }\n\n//     /* eslint no-unused-vars: \"off\" */\n//     function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {\n//       const swiper = this;\n//       const {params, animating, snapGrid, slidesGrid, rtlTranslate, enabled} = swiper;\n//       if (!enabled) return swiper;\n\n//       if (params.loop) {\n//         if (animating && params.loopPreventsSlide) return false;\n//         swiper.loopFix(); // eslint-disable-next-line\n\n//         swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n//       }\n\n//       const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n\n//       function normalize(val) {\n//         if (val < 0) return -Math.floor(Math.abs(val));\n//         return Math.floor(val);\n//       }\n\n//       const normalizedTranslate = normalize(translate);\n//       const normalizedSnapGrid = snapGrid.map((val) => normalize(val));\n//       let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n\n//       if (typeof prevSnap === 'undefined' && params.cssMode) {\n//         let prevSnapIndex;\n//         snapGrid.forEach((snap, snapIndex) => {\n//           if (normalizedTranslate >= snap) {\n//             // prevSnap = snap;\n//             prevSnapIndex = snapIndex;\n//           }\n//         });\n\n//         if (typeof prevSnapIndex !== 'undefined') {\n//           prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n//         }\n//       }\n\n//       let prevIndex = 0;\n\n//       if (typeof prevSnap !== 'undefined') {\n//         prevIndex = slidesGrid.indexOf(prevSnap);\n//         if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n\n//         if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n//           prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n//           prevIndex = Math.max(prevIndex, 0);\n//         }\n//       }\n\n//       if (params.rewind && swiper.isBeginning) {\n//         return swiper.slideTo(swiper.slides.length - 1, speed, runCallbacks, internal);\n//       }\n\n//       return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n//     }\n\n//     /* eslint no-unused-vars: \"off\" */\n//     function slideReset(speed = this.params.speed, runCallbacks = true, internal) {\n//       const swiper = this;\n//       return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n//     }\n\n//     /* eslint no-unused-vars: \"off\" */\n//     function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {\n//       const swiper = this;\n//       let index = swiper.activeIndex;\n//       const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n//       const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n//       const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\n//       if (translate >= swiper.snapGrid[snapIndex]) {\n//         // The current translate is on or after the current snap index, so the choice\n//         // is between the current index and the one after it.\n//         const currentSnap = swiper.snapGrid[snapIndex];\n//         const nextSnap = swiper.snapGrid[snapIndex + 1];\n\n//         if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n//           index += swiper.params.slidesPerGroup;\n//         }\n//       } else {\n//         // The current translate is before the current snap index, so the choice\n//         // is between the current index and the one before it.\n//         const prevSnap = swiper.snapGrid[snapIndex - 1];\n//         const currentSnap = swiper.snapGrid[snapIndex];\n\n//         if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n//           index -= swiper.params.slidesPerGroup;\n//         }\n//       }\n\n//       index = Math.max(index, 0);\n//       index = Math.min(index, swiper.slidesGrid.length - 1);\n//       return swiper.slideTo(index, speed, runCallbacks, internal);\n//     }\n\n//     function slideToClickedSlide() {\n//       const swiper = this;\n//       const {params, $wrapperEl} = swiper;\n//       const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n//       let slideToIndex = swiper.clickedIndex;\n//       let realIndex;\n\n//       if (params.loop) {\n//         if (swiper.animating) return;\n//         realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n\n//         if (params.centeredSlides) {\n//           if (\n//             slideToIndex < swiper.loopedSlides - slidesPerView / 2 ||\n//             slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2\n//           ) {\n//             swiper.loopFix();\n//             slideToIndex = $wrapperEl\n//               .children(\n//                 `.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`,\n//               )\n//               .eq(0)\n//               .index();\n//             nextTick(() => {\n//               swiper.slideTo(slideToIndex);\n//             });\n//           } else {\n//             swiper.slideTo(slideToIndex);\n//           }\n//         } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n//           swiper.loopFix();\n//           slideToIndex = $wrapperEl\n//             .children(\n//               `.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`,\n//             )\n//             .eq(0)\n//             .index();\n//           nextTick(() => {\n//             swiper.slideTo(slideToIndex);\n//           });\n//         } else {\n//           swiper.slideTo(slideToIndex);\n//         }\n//       } else {\n//         swiper.slideTo(slideToIndex);\n//       }\n//     }\n\n//     var slide = {\n//       slideTo,\n//       slideToLoop,\n//       slideNext,\n//       slidePrev,\n//       slideReset,\n//       slideToClosest,\n//       slideToClickedSlide,\n//     };\n\n//     function loopCreate() {\n//       const swiper = this;\n//       const document = getDocument();\n//       const {params, $wrapperEl} = swiper; // Remove duplicated slides\n\n//       const $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;\n//       $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();\n//       let slides = $selector.children(`.${params.slideClass}`);\n\n//       if (params.loopFillGroupWithBlank) {\n//         const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);\n\n//         if (blankSlidesNum !== params.slidesPerGroup) {\n//           for (let i = 0; i < blankSlidesNum; i += 1) {\n//             const blankNode = $(document.createElement('div')).addClass(\n//               `${params.slideClass} ${params.slideBlankClass}`,\n//             );\n//             $selector.append(blankNode);\n//           }\n\n//           slides = $selector.children(`.${params.slideClass}`);\n//         }\n//       }\n\n//       if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;\n//       swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));\n//       swiper.loopedSlides += params.loopAdditionalSlides;\n\n//       if (swiper.loopedSlides > slides.length) {\n//         swiper.loopedSlides = slides.length;\n//       }\n\n//       const prependSlides = [];\n//       const appendSlides = [];\n//       slides.each((el, index) => {\n//         const slide = $(el);\n\n//         if (index < swiper.loopedSlides) {\n//           appendSlides.push(el);\n//         }\n\n//         if (index < slides.length && index >= slides.length - swiper.loopedSlides) {\n//           prependSlides.push(el);\n//         }\n\n//         slide.attr('data-swiper-slide-index', index);\n//       });\n\n//       for (let i = 0; i < appendSlides.length; i += 1) {\n//         $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n//       }\n\n//       for (let i = prependSlides.length - 1; i >= 0; i -= 1) {\n//         $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n//       }\n//     }\n\n//     function loopFix() {\n//       const swiper = this;\n//       swiper.emit('beforeLoopFix');\n//       const {activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl} = swiper;\n//       let newIndex;\n//       swiper.allowSlidePrev = true;\n//       swiper.allowSlideNext = true;\n//       const snapTranslate = -snapGrid[activeIndex];\n//       const diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding\n\n//       if (activeIndex < loopedSlides) {\n//         newIndex = slides.length - loopedSlides * 3 + activeIndex;\n//         newIndex += loopedSlides;\n//         const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n\n//         if (slideChanged && diff !== 0) {\n//           swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n//         }\n//       } else if (activeIndex >= slides.length - loopedSlides) {\n//         // Fix For Positive Oversliding\n//         newIndex = -slides.length + activeIndex + loopedSlides;\n//         newIndex += loopedSlides;\n//         const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n\n//         if (slideChanged && diff !== 0) {\n//           swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n//         }\n//       }\n\n//       swiper.allowSlidePrev = allowSlidePrev;\n//       swiper.allowSlideNext = allowSlideNext;\n//       swiper.emit('loopFix');\n//     }\n\n//     function loopDestroy() {\n//       const swiper = this;\n//       const {$wrapperEl, params, slides} = swiper;\n//       $wrapperEl\n//         .children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`)\n//         .remove();\n//       slides.removeAttr('data-swiper-slide-index');\n//     }\n\n//     var loop = {\n//       loopCreate,\n//       loopFix,\n//       loopDestroy,\n//     };\n\n//     function setGrabCursor(moving) {\n//       const swiper = this;\n//       if (\n//         swiper.support.touch ||\n//         !swiper.params.simulateTouch ||\n//         (swiper.params.watchOverflow && swiper.isLocked) ||\n//         swiper.params.cssMode\n//       )\n//         return;\n//       const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n//       el.style.cursor = 'move';\n//       el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';\n//       el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';\n//       el.style.cursor = moving ? 'grabbing' : 'grab';\n//     }\n\n//     function unsetGrabCursor() {\n//       const swiper = this;\n\n//       if (swiper.support.touch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) {\n//         return;\n//       }\n\n//       swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n//     }\n\n//     var grabCursor = {\n//       setGrabCursor,\n//       unsetGrabCursor,\n//     };\n\n//     function closestElement(selector, base = this) {\n//       function __closestFrom(el) {\n//         if (!el || el === getDocument() || el === getWindow()) return null;\n//         if (el.assignedSlot) el = el.assignedSlot;\n//         const found = el.closest(selector);\n//         return found || __closestFrom(el.getRootNode().host);\n//       }\n\n//       return __closestFrom(base);\n//     }\n\n//     function onTouchStart(event) {\n//       const swiper = this;\n//       const document = getDocument();\n//       const window = getWindow();\n//       const data = swiper.touchEventsData;\n//       const {params, touches, enabled} = swiper;\n//       if (!enabled) return;\n\n//       if (swiper.animating && params.preventInteractionOnTransition) {\n//         return;\n//       }\n\n//       if (!swiper.animating && params.cssMode && params.loop) {\n//         swiper.loopFix();\n//       }\n\n//       let e = event;\n//       if (e.originalEvent) e = e.originalEvent;\n//       let $targetEl = $(e.target);\n\n//       if (params.touchEventsTarget === 'wrapper') {\n//         if (!$targetEl.closest(swiper.wrapperEl).length) return;\n//       }\n\n//       data.isTouchEvent = e.type === 'touchstart';\n//       if (!data.isTouchEvent && 'which' in e && e.which === 3) return;\n//       if (!data.isTouchEvent && 'button' in e && e.button > 0) return;\n//       if (data.isTouched && data.isMoved) return; // change target el for shadow root component\n\n//       const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n\n//       if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {\n//         $targetEl = $(event.path[0]);\n//       }\n\n//       const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n//       const isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element\n\n//       if (\n//         params.noSwiping &&\n//         (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])\n//       ) {\n//         swiper.allowClick = true;\n//         return;\n//       }\n\n//       if (params.swipeHandler) {\n//         if (!$targetEl.closest(params.swipeHandler)[0]) return;\n//       }\n\n//       touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n//       touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n//       const startX = touches.currentX;\n//       const startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n//       const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n//       const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n\n//       if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n//         if (edgeSwipeDetection === 'prevent') {\n//           event.preventDefault();\n//         } else {\n//           return;\n//         }\n//       }\n\n//       Object.assign(data, {\n//         isTouched: true,\n//         isMoved: false,\n//         allowTouchCallbacks: true,\n//         isScrolling: undefined,\n//         startMoving: undefined,\n//       });\n//       touches.startX = startX;\n//       touches.startY = startY;\n//       data.touchStartTime = now();\n//       swiper.allowClick = true;\n//       swiper.updateSize();\n//       swiper.swipeDirection = undefined;\n//       if (params.threshold > 0) data.allowThresholdMove = false;\n\n//       if (e.type !== 'touchstart') {\n//         let preventDefault = true;\n//         if ($targetEl.is(data.focusableElements)) preventDefault = false;\n\n//         if (\n//           document.activeElement &&\n//           $(document.activeElement).is(data.focusableElements) &&\n//           document.activeElement !== $targetEl[0]\n//         ) {\n//           document.activeElement.blur();\n//         }\n\n//         const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n\n//         if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {\n//           e.preventDefault();\n//         }\n//       }\n\n//       swiper.emit('touchStart', e);\n//     }\n\n//     function onTouchMove(event) {\n//       const document = getDocument();\n//       const swiper = this;\n//       const data = swiper.touchEventsData;\n//       const {params, touches, rtlTranslate: rtl, enabled} = swiper;\n//       if (!enabled) return;\n//       let e = event;\n//       if (e.originalEvent) e = e.originalEvent;\n\n//       if (!data.isTouched) {\n//         if (data.startMoving && data.isScrolling) {\n//           swiper.emit('touchMoveOpposite', e);\n//         }\n\n//         return;\n//       }\n\n//       if (data.isTouchEvent && e.type !== 'touchmove') return;\n//       const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);\n//       const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;\n//       const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;\n\n//       if (e.preventedByNestedSwiper) {\n//         touches.startX = pageX;\n//         touches.startY = pageY;\n//         return;\n//       }\n\n//       if (!swiper.allowTouchMove) {\n//         // isMoved = true;\n//         swiper.allowClick = false;\n\n//         if (data.isTouched) {\n//           Object.assign(touches, {\n//             startX: pageX,\n//             startY: pageY,\n//             currentX: pageX,\n//             currentY: pageY,\n//           });\n//           data.touchStartTime = now();\n//         }\n\n//         return;\n//       }\n\n//       if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {\n//         if (swiper.isVertical()) {\n//           // Vertical\n//           if (\n//             (pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) ||\n//             (pageY > touches.startY && swiper.translate >= swiper.minTranslate())\n//           ) {\n//             data.isTouched = false;\n//             data.isMoved = false;\n//             return;\n//           }\n//         } else if (\n//           (pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) ||\n//           (pageX > touches.startX && swiper.translate >= swiper.minTranslate())\n//         ) {\n//           return;\n//         }\n//       }\n\n//       if (data.isTouchEvent && document.activeElement) {\n//         if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {\n//           data.isMoved = true;\n//           swiper.allowClick = false;\n//           return;\n//         }\n//       }\n\n//       if (data.allowTouchCallbacks) {\n//         swiper.emit('touchMove', e);\n//       }\n\n//       if (e.targetTouches && e.targetTouches.length > 1) return;\n//       touches.currentX = pageX;\n//       touches.currentY = pageY;\n//       const diffX = touches.currentX - touches.startX;\n//       const diffY = touches.currentY - touches.startY;\n//       if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n\n//       if (typeof data.isScrolling === 'undefined') {\n//         let touchAngle;\n\n//         if (\n//           (swiper.isHorizontal() && touches.currentY === touches.startY) ||\n//           (swiper.isVertical() && touches.currentX === touches.startX)\n//         ) {\n//           data.isScrolling = false;\n//         } else {\n//           // eslint-disable-next-line\n//           if (diffX * diffX + diffY * diffY >= 25) {\n//             touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;\n//             data.isScrolling = swiper.isHorizontal()\n//               ? touchAngle > params.touchAngle\n//               : 90 - touchAngle > params.touchAngle;\n//           }\n//         }\n//       }\n\n//       if (data.isScrolling) {\n//         swiper.emit('touchMoveOpposite', e);\n//       }\n\n//       if (typeof data.startMoving === 'undefined') {\n//         if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n//           data.startMoving = true;\n//         }\n//       }\n\n//       if (data.isScrolling) {\n//         data.isTouched = false;\n//         return;\n//       }\n\n//       if (!data.startMoving) {\n//         return;\n//       }\n\n//       swiper.allowClick = false;\n\n//       if (!params.cssMode && e.cancelable) {\n//         e.preventDefault();\n//       }\n\n//       if (params.touchMoveStopPropagation && !params.nested) {\n//         e.stopPropagation();\n//       }\n\n//       if (!data.isMoved) {\n//         if (params.loop && !params.cssMode) {\n//           swiper.loopFix();\n//         }\n\n//         data.startTranslate = swiper.getTranslate();\n//         swiper.setTransition(0);\n\n//         if (swiper.animating) {\n//           swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');\n//         }\n\n//         data.allowMomentumBounce = false; // Grab Cursor\n\n//         if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n//           swiper.setGrabCursor(true);\n//         }\n\n//         swiper.emit('sliderFirstMove', e);\n//       }\n\n//       swiper.emit('sliderMove', e);\n//       data.isMoved = true;\n//       let diff = swiper.isHorizontal() ? diffX : diffY;\n//       touches.diff = diff;\n//       diff *= params.touchRatio;\n//       if (rtl) diff = -diff;\n//       swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n//       data.currentTranslate = diff + data.startTranslate;\n//       let disableParentSwiper = true;\n//       let resistanceRatio = params.resistanceRatio;\n\n//       if (params.touchReleaseOnEdges) {\n//         resistanceRatio = 0;\n//       }\n\n//       if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {\n//         disableParentSwiper = false;\n//         if (params.resistance)\n//           data.currentTranslate =\n//             swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n//       } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {\n//         disableParentSwiper = false;\n//         if (params.resistance)\n//           data.currentTranslate =\n//             swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n//       }\n\n//       if (disableParentSwiper) {\n//         e.preventedByNestedSwiper = true;\n//       } // Directions locks\n\n//       if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n//         data.currentTranslate = data.startTranslate;\n//       }\n\n//       if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n//         data.currentTranslate = data.startTranslate;\n//       }\n\n//       if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n//         data.currentTranslate = data.startTranslate;\n//       } // Threshold\n\n//       if (params.threshold > 0) {\n//         if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n//           if (!data.allowThresholdMove) {\n//             data.allowThresholdMove = true;\n//             touches.startX = touches.currentX;\n//             touches.startY = touches.currentY;\n//             data.currentTranslate = data.startTranslate;\n//             touches.diff = swiper.isHorizontal()\n//               ? touches.currentX - touches.startX\n//               : touches.currentY - touches.startY;\n//             return;\n//           }\n//         } else {\n//           data.currentTranslate = data.startTranslate;\n//           return;\n//         }\n//       }\n\n//       if (!params.followFinger || params.cssMode) return; // Update active index in free mode\n\n//       if ((params.freeMode && params.freeMode.enabled && swiper.freeMode) || params.watchSlidesProgress) {\n//         swiper.updateActiveIndex();\n//         swiper.updateSlidesClasses();\n//       }\n\n//       if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n//         swiper.freeMode.onTouchMove();\n//       } // Update progress\n\n//       swiper.updateProgress(data.currentTranslate); // Update translate\n\n//       swiper.setTranslate(data.currentTranslate);\n//     }\n\n//     function onTouchEnd(event) {\n//       const swiper = this;\n//       const data = swiper.touchEventsData;\n//       const {params, touches, rtlTranslate: rtl, slidesGrid, enabled} = swiper;\n//       if (!enabled) return;\n//       let e = event;\n//       if (e.originalEvent) e = e.originalEvent;\n\n//       if (data.allowTouchCallbacks) {\n//         swiper.emit('touchEnd', e);\n//       }\n\n//       data.allowTouchCallbacks = false;\n\n//       if (!data.isTouched) {\n//         if (data.isMoved && params.grabCursor) {\n//           swiper.setGrabCursor(false);\n//         }\n\n//         data.isMoved = false;\n//         data.startMoving = false;\n//         return;\n//       } // Return Grab Cursor\n\n//       if (\n//         params.grabCursor &&\n//         data.isMoved &&\n//         data.isTouched &&\n//         (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)\n//       ) {\n//         swiper.setGrabCursor(false);\n//       } // Time diff\n\n//       const touchEndTime = now();\n//       const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n//       if (swiper.allowClick) {\n//         const pathTree = e.path || (e.composedPath && e.composedPath());\n//         swiper.updateClickedSlide((pathTree && pathTree[0]) || e.target);\n//         swiper.emit('tap click', e);\n\n//         if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n//           swiper.emit('doubleTap doubleClick', e);\n//         }\n//       }\n\n//       data.lastClickTime = now();\n//       nextTick(() => {\n//         if (!swiper.destroyed) swiper.allowClick = true;\n//       });\n\n//       if (\n//         !data.isTouched ||\n//         !data.isMoved ||\n//         !swiper.swipeDirection ||\n//         touches.diff === 0 ||\n//         data.currentTranslate === data.startTranslate\n//       ) {\n//         data.isTouched = false;\n//         data.isMoved = false;\n//         data.startMoving = false;\n//         return;\n//       }\n\n//       data.isTouched = false;\n//       data.isMoved = false;\n//       data.startMoving = false;\n//       let currentPos;\n\n//       if (params.followFinger) {\n//         currentPos = rtl ? swiper.translate : -swiper.translate;\n//       } else {\n//         currentPos = -data.currentTranslate;\n//       }\n\n//       if (params.cssMode) {\n//         return;\n//       }\n\n//       if (swiper.params.freeMode && params.freeMode.enabled) {\n//         swiper.freeMode.onTouchEnd({\n//           currentPos,\n//         });\n//         return;\n//       } // Find current slide\n\n//       let stopIndex = 0;\n//       let groupSize = swiper.slidesSizesGrid[0];\n\n//       for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n//         const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n//         if (typeof slidesGrid[i + increment] !== 'undefined') {\n//           if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n//             stopIndex = i;\n//             groupSize = slidesGrid[i + increment] - slidesGrid[i];\n//           }\n//         } else if (currentPos >= slidesGrid[i]) {\n//           stopIndex = i;\n//           groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n//         }\n//       } // Find current slide size\n\n//       const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n//       const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n//       if (timeDiff > params.longSwipesMs) {\n//         // Long touches\n//         if (!params.longSwipes) {\n//           swiper.slideTo(swiper.activeIndex);\n//           return;\n//         }\n\n//         if (swiper.swipeDirection === 'next') {\n//           if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);\n//           else swiper.slideTo(stopIndex);\n//         }\n\n//         if (swiper.swipeDirection === 'prev') {\n//           if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);\n//           else swiper.slideTo(stopIndex);\n//         }\n//       } else {\n//         // Short swipes\n//         if (!params.shortSwipes) {\n//           swiper.slideTo(swiper.activeIndex);\n//           return;\n//         }\n\n//         const isNavButtonTarget =\n//           swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\n//         if (!isNavButtonTarget) {\n//           if (swiper.swipeDirection === 'next') {\n//             swiper.slideTo(stopIndex + increment);\n//           }\n\n//           if (swiper.swipeDirection === 'prev') {\n//             swiper.slideTo(stopIndex);\n//           }\n//         } else if (e.target === swiper.navigation.nextEl) {\n//           swiper.slideTo(stopIndex + increment);\n//         } else {\n//           swiper.slideTo(stopIndex);\n//         }\n//       }\n//     }\n\n//     function onResize() {\n//       const swiper = this;\n//       const {params, el} = swiper;\n//       if (el && el.offsetWidth === 0) return; // Breakpoints\n\n//       if (params.breakpoints) {\n//         swiper.setBreakpoint();\n//       } // Save locks\n\n//       const {allowSlideNext, allowSlidePrev, snapGrid} = swiper; // Disable locks on resize\n\n//       swiper.allowSlideNext = true;\n//       swiper.allowSlidePrev = true;\n//       swiper.updateSize();\n//       swiper.updateSlides();\n//       swiper.updateSlidesClasses();\n\n//       if (\n//         (params.slidesPerView === 'auto' || params.slidesPerView > 1) &&\n//         swiper.isEnd &&\n//         !swiper.isBeginning &&\n//         !swiper.params.centeredSlides\n//       ) {\n//         swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n//       } else {\n//         swiper.slideTo(swiper.activeIndex, 0, false, true);\n//       }\n\n//       if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n//         swiper.autoplay.run();\n//       } // Return locks after resize\n\n//       swiper.allowSlidePrev = allowSlidePrev;\n//       swiper.allowSlideNext = allowSlideNext;\n\n//       if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n//         swiper.checkOverflow();\n//       }\n//     }\n\n//     function onClick(e) {\n//       const swiper = this;\n//       if (!swiper.enabled) return;\n\n//       if (!swiper.allowClick) {\n//         if (swiper.params.preventClicks) e.preventDefault();\n\n//         if (swiper.params.preventClicksPropagation && swiper.animating) {\n//           e.stopPropagation();\n//           e.stopImmediatePropagation();\n//         }\n//       }\n//     }\n\n//     function onScroll() {\n//       const swiper = this;\n//       const {wrapperEl, rtlTranslate, enabled} = swiper;\n//       if (!enabled) return;\n//       swiper.previousTranslate = swiper.translate;\n\n//       if (swiper.isHorizontal()) {\n//         swiper.translate = -wrapperEl.scrollLeft;\n//       } else {\n//         swiper.translate = -wrapperEl.scrollTop;\n//       } // eslint-disable-next-line\n\n//       if (swiper.translate === -0) swiper.translate = 0;\n//       swiper.updateActiveIndex();\n//       swiper.updateSlidesClasses();\n//       let newProgress;\n//       const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n\n//       if (translatesDiff === 0) {\n//         newProgress = 0;\n//       } else {\n//         newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n//       }\n\n//       if (newProgress !== swiper.progress) {\n//         swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n//       }\n\n//       swiper.emit('setTranslate', swiper.translate, false);\n//     }\n\n//     let dummyEventAttached = false;\n\n//     function dummyEventListener() {}\n\n//     const events = (swiper, method) => {\n//       const document = getDocument();\n//       const {params, touchEvents, el, wrapperEl, device, support} = swiper;\n//       const capture = !!params.nested;\n//       const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n//       const swiperMethod = method; // Touch Events\n\n//       if (!support.touch) {\n//         el[domMethod](touchEvents.start, swiper.onTouchStart, false);\n//         document[domMethod](touchEvents.move, swiper.onTouchMove, capture);\n//         document[domMethod](touchEvents.end, swiper.onTouchEnd, false);\n//       } else {\n//         const passiveListener =\n//           touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners\n//             ? {\n//                 passive: true,\n//                 capture: false,\n//               }\n//             : false;\n//         el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);\n//         el[domMethod](\n//           touchEvents.move,\n//           swiper.onTouchMove,\n//           support.passiveListener\n//             ? {\n//                 passive: false,\n//                 capture,\n//               }\n//             : capture,\n//         );\n//         el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);\n\n//         if (touchEvents.cancel) {\n//           el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);\n//         }\n//       } // Prevent Links Clicks\n\n//       if (params.preventClicks || params.preventClicksPropagation) {\n//         el[domMethod]('click', swiper.onClick, true);\n//       }\n\n//       if (params.cssMode) {\n//         wrapperEl[domMethod]('scroll', swiper.onScroll);\n//       } // Resize handler\n\n//       if (params.updateOnWindowResize) {\n//         swiper[swiperMethod](\n//           device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate',\n//           onResize,\n//           true,\n//         );\n//       } else {\n//         swiper[swiperMethod]('observerUpdate', onResize, true);\n//       }\n//     };\n\n//     function attachEvents() {\n//       const swiper = this;\n//       const document = getDocument();\n//       const {params, support} = swiper;\n//       swiper.onTouchStart = onTouchStart.bind(swiper);\n//       swiper.onTouchMove = onTouchMove.bind(swiper);\n//       swiper.onTouchEnd = onTouchEnd.bind(swiper);\n\n//       if (params.cssMode) {\n//         swiper.onScroll = onScroll.bind(swiper);\n//       }\n\n//       swiper.onClick = onClick.bind(swiper);\n\n//       if (support.touch && !dummyEventAttached) {\n//         document.addEventListener('touchstart', dummyEventListener);\n//         dummyEventAttached = true;\n//       }\n\n//       events(swiper, 'on');\n//     }\n\n//     function detachEvents() {\n//       const swiper = this;\n//       events(swiper, 'off');\n//     }\n\n//     var events$1 = {\n//       attachEvents,\n//       detachEvents,\n//     };\n\n//     const isGridEnabled = (swiper, params) => {\n//       return swiper.grid && params.grid && params.grid.rows > 1;\n//     };\n\n//     function setBreakpoint() {\n//       const swiper = this;\n//       const {activeIndex, initialized, loopedSlides = 0, params, $el} = swiper;\n//       const breakpoints = params.breakpoints;\n//       if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return; // Get breakpoint for window width and update parameters\n\n//       const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n//       if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n//       const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n//       const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n//       const wasMultiRow = isGridEnabled(swiper, params);\n//       const isMultiRow = isGridEnabled(swiper, breakpointParams);\n//       const wasEnabled = params.enabled;\n\n//       if (wasMultiRow && !isMultiRow) {\n//         $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);\n//         swiper.emitContainerClasses();\n//       } else if (!wasMultiRow && isMultiRow) {\n//         $el.addClass(`${params.containerModifierClass}grid`);\n\n//         if (\n//           (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column') ||\n//           (!breakpointParams.grid.fill && params.grid.fill === 'column')\n//         ) {\n//           $el.addClass(`${params.containerModifierClass}grid-column`);\n//         }\n\n//         swiper.emitContainerClasses();\n//       }\n\n//       const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n//       const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n\n//       if (directionChanged && initialized) {\n//         swiper.changeDirection();\n//       }\n\n//       extend(swiper.params, breakpointParams);\n//       const isEnabled = swiper.params.enabled;\n//       Object.assign(swiper, {\n//         allowTouchMove: swiper.params.allowTouchMove,\n//         allowSlideNext: swiper.params.allowSlideNext,\n//         allowSlidePrev: swiper.params.allowSlidePrev,\n//       });\n\n//       if (wasEnabled && !isEnabled) {\n//         swiper.disable();\n//       } else if (!wasEnabled && isEnabled) {\n//         swiper.enable();\n//       }\n\n//       swiper.currentBreakpoint = breakpoint;\n//       swiper.emit('_beforeBreakpoint', breakpointParams);\n\n//       if (needsReLoop && initialized) {\n//         swiper.loopDestroy();\n//         swiper.loopCreate();\n//         swiper.updateSlides();\n//         swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);\n//       }\n\n//       swiper.emit('breakpoint', breakpointParams);\n//     }\n\n//     function getBreakpoint(breakpoints, base = 'window', containerEl) {\n//       if (!breakpoints || (base === 'container' && !containerEl)) return undefined;\n//       let breakpoint = false;\n//       const window = getWindow();\n//       const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n//       const points = Object.keys(breakpoints).map((point) => {\n//         if (typeof point === 'string' && point.indexOf('@') === 0) {\n//           const minRatio = parseFloat(point.substr(1));\n//           const value = currentHeight * minRatio;\n//           return {\n//             value,\n//             point,\n//           };\n//         }\n\n//         return {\n//           value: point,\n//           point,\n//         };\n//       });\n//       points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n\n//       for (let i = 0; i < points.length; i += 1) {\n//         const {point, value} = points[i];\n\n//         if (base === 'window') {\n//           if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n//             breakpoint = point;\n//           }\n//         } else if (value <= containerEl.clientWidth) {\n//           breakpoint = point;\n//         }\n//       }\n\n//       return breakpoint || 'max';\n//     }\n\n//     var breakpoints = {\n//       setBreakpoint,\n//       getBreakpoint,\n//     };\n\n//     function prepareClasses(entries, prefix) {\n//       const resultClasses = [];\n//       entries.forEach((item) => {\n//         if (typeof item === 'object') {\n//           Object.keys(item).forEach((classNames) => {\n//             if (item[classNames]) {\n//               resultClasses.push(prefix + classNames);\n//             }\n//           });\n//         } else if (typeof item === 'string') {\n//           resultClasses.push(prefix + item);\n//         }\n//       });\n//       return resultClasses;\n//     }\n\n//     function addClasses() {\n//       const swiper = this;\n//       const {\n//       classNames,\n//       params,\n//       rtl,\n//       $el,\n//       device,\n//       support\n//     } = swiper; // prettier-ignore\n\n//       const suffixes = prepareClasses(\n//         [\n//           'initialized',\n//           params.direction,\n//           {\n//             'pointer-events': !support.touch,\n//           },\n//           {\n//             'free-mode': swiper.params.freeMode && params.freeMode.enabled,\n//           },\n//           {\n//             autoheight: params.autoHeight,\n//           },\n//           {\n//             rtl: rtl,\n//           },\n//           {\n//             grid: params.grid && params.grid.rows > 1,\n//           },\n//           {\n//             'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column',\n//           },\n//           {\n//             android: device.android,\n//           },\n//           {\n//             ios: device.ios,\n//           },\n//           {\n//             'css-mode': params.cssMode,\n//           },\n//           {\n//             centered: params.cssMode && params.centeredSlides,\n//           },\n//         ],\n//         params.containerModifierClass,\n//       );\n//       classNames.push(...suffixes);\n//       $el.addClass([...classNames].join(' '));\n//       swiper.emitContainerClasses();\n//     }\n\n//     function removeClasses() {\n//       const swiper = this;\n//       const {$el, classNames} = swiper;\n//       $el.removeClass(classNames.join(' '));\n//       swiper.emitContainerClasses();\n//     }\n\n//     var classes = {\n//       addClasses,\n//       removeClasses,\n//     };\n\n//     function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {\n//       const window = getWindow();\n//       let image;\n\n//       function onReady() {\n//         if (callback) callback();\n//       }\n\n//       const isPicture = $(imageEl).parent('picture')[0];\n\n//       if (!isPicture && (!imageEl.complete || !checkForComplete)) {\n//         if (src) {\n//           image = new window.Image();\n//           image.onload = onReady;\n//           image.onerror = onReady;\n\n//           if (sizes) {\n//             image.sizes = sizes;\n//           }\n\n//           if (srcset) {\n//             image.srcset = srcset;\n//           }\n\n//           if (src) {\n//             image.src = src;\n//           }\n//         } else {\n//           onReady();\n//         }\n//       } else {\n//         // image already loaded...\n//         onReady();\n//       }\n//     }\n\n//     function preloadImages() {\n//       const swiper = this;\n//       swiper.imagesToLoad = swiper.$el.find('img');\n\n//       function onReady() {\n//         if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;\n//         if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;\n\n//         if (swiper.imagesLoaded === swiper.imagesToLoad.length) {\n//           if (swiper.params.updateOnImagesReady) swiper.update();\n//           swiper.emit('imagesReady');\n//         }\n//       }\n\n//       for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {\n//         const imageEl = swiper.imagesToLoad[i];\n//         swiper.loadImage(\n//           imageEl,\n//           imageEl.currentSrc || imageEl.getAttribute('src'),\n//           imageEl.srcset || imageEl.getAttribute('srcset'),\n//           imageEl.sizes || imageEl.getAttribute('sizes'),\n//           true,\n//           onReady,\n//         );\n//       }\n//     }\n\n//     var images = {\n//       loadImage,\n//       preloadImages,\n//     };\n\n//     function checkOverflow() {\n//       const swiper = this;\n//       const {isLocked: wasLocked, params} = swiper;\n//       const {slidesOffsetBefore} = params;\n\n//       if (slidesOffsetBefore) {\n//         const lastSlideIndex = swiper.slides.length - 1;\n//         const lastSlideRightEdge =\n//           swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n//         swiper.isLocked = swiper.size > lastSlideRightEdge;\n//       } else {\n//         swiper.isLocked = swiper.snapGrid.length === 1;\n//       }\n\n//       if (params.allowSlideNext === true) {\n//         swiper.allowSlideNext = !swiper.isLocked;\n//       }\n\n//       if (params.allowSlidePrev === true) {\n//         swiper.allowSlidePrev = !swiper.isLocked;\n//       }\n\n//       if (wasLocked && wasLocked !== swiper.isLocked) {\n//         swiper.isEnd = false;\n//       }\n\n//       if (wasLocked !== swiper.isLocked) {\n//         swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n//       }\n//     }\n\n//     var checkOverflow$1 = {\n//       checkOverflow,\n//     };\n\n//     var defaults = {\n//       init: true,\n//       direction: 'horizontal',\n//       touchEventsTarget: 'wrapper',\n//       initialSlide: 0,\n//       speed: 300,\n//       cssMode: false,\n//       updateOnWindowResize: true,\n//       resizeObserver: true,\n//       nested: false,\n//       createElements: false,\n//       enabled: true,\n//       focusableElements: 'input, select, option, textarea, button, video, label',\n//       // Overrides\n//       width: null,\n//       height: null,\n//       //\n//       preventInteractionOnTransition: false,\n//       // ssr\n//       userAgent: null,\n//       url: null,\n//       // To support iOS's swipe-to-go-back gesture (when being used in-app).\n//       edgeSwipeDetection: false,\n//       edgeSwipeThreshold: 20,\n//       // Autoheight\n//       autoHeight: false,\n//       // Set wrapper width\n//       setWrapperSize: false,\n//       // Virtual Translate\n//       virtualTranslate: false,\n//       // Effects\n//       effect: 'slide',\n//       // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n//       // Breakpoints\n//       breakpoints: undefined,\n//       breakpointsBase: 'window',\n//       // Slides grid\n//       spaceBetween: 0,\n//       slidesPerView: 1,\n//       slidesPerGroup: 1,\n//       slidesPerGroupSkip: 0,\n//       slidesPerGroupAuto: false,\n//       centeredSlides: false,\n//       centeredSlidesBounds: false,\n//       slidesOffsetBefore: 0,\n//       // in px\n//       slidesOffsetAfter: 0,\n//       // in px\n//       normalizeSlideIndex: true,\n//       centerInsufficientSlides: false,\n//       // Disable swiper and hide navigation when container not overflow\n//       watchOverflow: true,\n//       // Round length\n//       roundLengths: false,\n//       // Touches\n//       touchRatio: 1,\n//       touchAngle: 45,\n//       simulateTouch: true,\n//       shortSwipes: true,\n//       longSwipes: true,\n//       longSwipesRatio: 0.5,\n//       longSwipesMs: 300,\n//       followFinger: true,\n//       allowTouchMove: true,\n//       threshold: 0,\n//       touchMoveStopPropagation: false,\n//       touchStartPreventDefault: true,\n//       touchStartForcePreventDefault: false,\n//       touchReleaseOnEdges: false,\n//       // Unique Navigation Elements\n//       uniqueNavElements: true,\n//       // Resistance\n//       resistance: true,\n//       resistanceRatio: 0.85,\n//       // Progress\n//       watchSlidesProgress: false,\n//       // Cursor\n//       grabCursor: false,\n//       // Clicks\n//       preventClicks: true,\n//       preventClicksPropagation: true,\n//       slideToClickedSlide: false,\n//       // Images\n//       preloadImages: true,\n//       updateOnImagesReady: true,\n//       // loop\n//       loop: false,\n//       loopAdditionalSlides: 0,\n//       loopedSlides: null,\n//       loopFillGroupWithBlank: false,\n//       loopPreventsSlide: true,\n//       // rewind\n//       rewind: false,\n//       // Swiping/no swiping\n//       allowSlidePrev: true,\n//       allowSlideNext: true,\n//       swipeHandler: null,\n//       // '.swipe-handler',\n//       noSwiping: true,\n//       noSwipingClass: 'swiper-no-swiping',\n//       noSwipingSelector: null,\n//       // Passive Listeners\n//       passiveListeners: true,\n//       // NS\n//       containerModifierClass: 'swiper-',\n//       // NEW\n//       slideClass: 'swiper-slide',\n//       slideBlankClass: 'swiper-slide-invisible-blank',\n//       slideActiveClass: 'swiper-slide-active',\n//       slideDuplicateActiveClass: 'swiper-slide-duplicate-active',\n//       slideVisibleClass: 'swiper-slide-visible',\n//       slideDuplicateClass: 'swiper-slide-duplicate',\n//       slideNextClass: 'swiper-slide-next',\n//       slideDuplicateNextClass: 'swiper-slide-duplicate-next',\n//       slidePrevClass: 'swiper-slide-prev',\n//       slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',\n//       wrapperClass: 'swiper-wrapper',\n//       // Callbacks\n//       runCallbacksOnInit: true,\n//       // Internals\n//       _emitClasses: false,\n//     };\n\n//     function moduleExtendParams(params, allModulesParams) {\n//       return function extendParams(obj = {}) {\n//         const moduleParamName = Object.keys(obj)[0];\n//         const moduleParams = obj[moduleParamName];\n\n//         if (typeof moduleParams !== 'object' || moduleParams === null) {\n//           extend(allModulesParams, obj);\n//           return;\n//         }\n\n//         if (\n//           ['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 &&\n//           params[moduleParamName] === true\n//         ) {\n//           params[moduleParamName] = {\n//             auto: true,\n//           };\n//         }\n\n//         if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n//           extend(allModulesParams, obj);\n//           return;\n//         }\n\n//         if (params[moduleParamName] === true) {\n//           params[moduleParamName] = {\n//             enabled: true,\n//           };\n//         }\n\n//         if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n//           params[moduleParamName].enabled = true;\n//         }\n\n//         if (!params[moduleParamName])\n//           params[moduleParamName] = {\n//             enabled: false,\n//           };\n//         extend(allModulesParams, obj);\n//       };\n//     }\n\n//     /* eslint no-param-reassign: \"off\" */\n//     const prototypes = {\n//       eventsEmitter,\n//       update,\n//       translate,\n//       transition,\n//       slide,\n//       loop,\n//       grabCursor,\n//       events: events$1,\n//       breakpoints,\n//       checkOverflow: checkOverflow$1,\n//       classes,\n//       images,\n//     };\n//     const extendedDefaults = {};\n\n//     class Swiper {\n//       constructor(...args) {\n//         let el;\n//         let params;\n\n//         if (\n//           args.length === 1 &&\n//           args[0].constructor &&\n//           Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object'\n//         ) {\n//           params = args[0];\n//         } else {\n//           [el, params] = args;\n//         }\n\n//         if (!params) params = {};\n//         params = extend({}, params);\n//         if (el && !params.el) params.el = el;\n\n//         if (params.el && $(params.el).length > 1) {\n//           const swipers = [];\n//           $(params.el).each((containerEl) => {\n//             const newParams = extend({}, params, {\n//               el: containerEl,\n//             });\n//             swipers.push(new Swiper(newParams));\n//           });\n//           return swipers;\n//         } // Swiper Instance\n\n//         const swiper = this;\n//         swiper.__swiper__ = true;\n//         swiper.support = getSupport();\n//         swiper.device = getDevice({\n//           userAgent: params.userAgent,\n//         });\n//         swiper.browser = getBrowser();\n//         swiper.eventsListeners = {};\n//         swiper.eventsAnyListeners = [];\n//         swiper.modules = [...swiper.__modules__];\n\n//         if (params.modules && Array.isArray(params.modules)) {\n//           swiper.modules.push(...params.modules);\n//         }\n\n//         const allModulesParams = {};\n//         swiper.modules.forEach((mod) => {\n//           mod({\n//             swiper,\n//             extendParams: moduleExtendParams(params, allModulesParams),\n//             on: swiper.on.bind(swiper),\n//             once: swiper.once.bind(swiper),\n//             off: swiper.off.bind(swiper),\n//             emit: swiper.emit.bind(swiper),\n//           });\n//         }); // Extend defaults with modules params\n\n//         const swiperParams = extend({}, defaults, allModulesParams); // Extend defaults with passed params\n\n//         swiper.params = extend({}, swiperParams, extendedDefaults, params);\n//         swiper.originalParams = extend({}, swiper.params);\n//         swiper.passedParams = extend({}, params); // add event listeners\n\n//         if (swiper.params && swiper.params.on) {\n//           Object.keys(swiper.params.on).forEach((eventName) => {\n//             swiper.on(eventName, swiper.params.on[eventName]);\n//           });\n//         }\n\n//         if (swiper.params && swiper.params.onAny) {\n//           swiper.onAny(swiper.params.onAny);\n//         } // Save Dom lib\n\n//         swiper.$ = $; // Extend Swiper\n\n//         Object.assign(swiper, {\n//           enabled: swiper.params.enabled,\n//           el,\n//           // Classes\n//           classNames: [],\n//           // Slides\n//           slides: $(),\n//           slidesGrid: [],\n//           snapGrid: [],\n//           slidesSizesGrid: [],\n\n//           // isDirection\n//           isHorizontal() {\n//             return swiper.params.direction === 'horizontal';\n//           },\n\n//           isVertical() {\n//             return swiper.params.direction === 'vertical';\n//           },\n\n//           // Indexes\n//           activeIndex: 0,\n//           realIndex: 0,\n//           //\n//           isBeginning: true,\n//           isEnd: false,\n//           // Props\n//           translate: 0,\n//           previousTranslate: 0,\n//           progress: 0,\n//           velocity: 0,\n//           animating: false,\n//           // Locks\n//           allowSlideNext: swiper.params.allowSlideNext,\n//           allowSlidePrev: swiper.params.allowSlidePrev,\n//           // Touch Events\n//           touchEvents: (function touchEvents() {\n//             const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\n//             const desktop = ['pointerdown', 'pointermove', 'pointerup'];\n//             swiper.touchEventsTouch = {\n//               start: touch[0],\n//               move: touch[1],\n//               end: touch[2],\n//               cancel: touch[3],\n//             };\n//             swiper.touchEventsDesktop = {\n//               start: desktop[0],\n//               move: desktop[1],\n//               end: desktop[2],\n//             };\n//             return swiper.support.touch || !swiper.params.simulateTouch\n//               ? swiper.touchEventsTouch\n//               : swiper.touchEventsDesktop;\n//           })(),\n//           touchEventsData: {\n//             isTouched: undefined,\n//             isMoved: undefined,\n//             allowTouchCallbacks: undefined,\n//             touchStartTime: undefined,\n//             isScrolling: undefined,\n//             currentTranslate: undefined,\n//             startTranslate: undefined,\n//             allowThresholdMove: undefined,\n//             // Form elements to match\n//             focusableElements: swiper.params.focusableElements,\n//             // Last click time\n//             lastClickTime: now(),\n//             clickTimeout: undefined,\n//             // Velocities\n//             velocities: [],\n//             allowMomentumBounce: undefined,\n//             isTouchEvent: undefined,\n//             startMoving: undefined,\n//           },\n//           // Clicks\n//           allowClick: true,\n//           // Touches\n//           allowTouchMove: swiper.params.allowTouchMove,\n//           touches: {\n//             startX: 0,\n//             startY: 0,\n//             currentX: 0,\n//             currentY: 0,\n//             diff: 0,\n//           },\n//           // Images\n//           imagesToLoad: [],\n//           imagesLoaded: 0,\n//         });\n//         swiper.emit('_swiper'); // Init\n\n//         if (swiper.params.init) {\n//           swiper.init();\n//         } // Return app instance\n\n//         return swiper;\n//       }\n\n//       enable() {\n//         const swiper = this;\n//         if (swiper.enabled) return;\n//         swiper.enabled = true;\n\n//         if (swiper.params.grabCursor) {\n//           swiper.setGrabCursor();\n//         }\n\n//         swiper.emit('enable');\n//       }\n\n//       disable() {\n//         const swiper = this;\n//         if (!swiper.enabled) return;\n//         swiper.enabled = false;\n\n//         if (swiper.params.grabCursor) {\n//           swiper.unsetGrabCursor();\n//         }\n\n//         swiper.emit('disable');\n//       }\n\n//       setProgress(progress, speed) {\n//         const swiper = this;\n//         progress = Math.min(Math.max(progress, 0), 1);\n//         const min = swiper.minTranslate();\n//         const max = swiper.maxTranslate();\n//         const current = (max - min) * progress + min;\n//         swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n//         swiper.updateActiveIndex();\n//         swiper.updateSlidesClasses();\n//       }\n\n//       emitContainerClasses() {\n//         const swiper = this;\n//         if (!swiper.params._emitClasses || !swiper.el) return;\n//         const cls = swiper.el.className.split(' ').filter((className) => {\n//           return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n//         });\n//         swiper.emit('_containerClasses', cls.join(' '));\n//       }\n\n//       getSlideClasses(slideEl) {\n//         const swiper = this;\n//         return slideEl.className\n//           .split(' ')\n//           .filter((className) => {\n//             return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\n//           })\n//           .join(' ');\n//       }\n\n//       emitSlidesClasses() {\n//         const swiper = this;\n//         if (!swiper.params._emitClasses || !swiper.el) return;\n//         const updates = [];\n//         swiper.slides.each((slideEl) => {\n//           const classNames = swiper.getSlideClasses(slideEl);\n//           updates.push({\n//             slideEl,\n//             classNames,\n//           });\n//           swiper.emit('_slideClass', slideEl, classNames);\n//         });\n//         swiper.emit('_slideClasses', updates);\n//       }\n\n//       slidesPerViewDynamic(view = 'current', exact = false) {\n//         const swiper = this;\n//         const {params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex} = swiper;\n//         let spv = 1;\n\n//         if (params.centeredSlides) {\n//           let slideSize = slides[activeIndex].swiperSlideSize;\n//           let breakLoop;\n\n//           for (let i = activeIndex + 1; i < slides.length; i += 1) {\n//             if (slides[i] && !breakLoop) {\n//               slideSize += slides[i].swiperSlideSize;\n//               spv += 1;\n//               if (slideSize > swiperSize) breakLoop = true;\n//             }\n//           }\n\n//           for (let i = activeIndex - 1; i >= 0; i -= 1) {\n//             if (slides[i] && !breakLoop) {\n//               slideSize += slides[i].swiperSlideSize;\n//               spv += 1;\n//               if (slideSize > swiperSize) breakLoop = true;\n//             }\n//           }\n//         } else {\n//           // eslint-disable-next-line\n//           if (view === 'current') {\n//             for (let i = activeIndex + 1; i < slides.length; i += 1) {\n//               const slideInView = exact\n//                 ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize\n//                 : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n\n//               if (slideInView) {\n//                 spv += 1;\n//               }\n//             }\n//           } else {\n//             // previous\n//             for (let i = activeIndex - 1; i >= 0; i -= 1) {\n//               const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n\n//               if (slideInView) {\n//                 spv += 1;\n//               }\n//             }\n//           }\n//         }\n\n//         return spv;\n//       }\n\n//       update() {\n//         const swiper = this;\n//         if (!swiper || swiper.destroyed) return;\n//         const {snapGrid, params} = swiper; // Breakpoints\n\n//         if (params.breakpoints) {\n//           swiper.setBreakpoint();\n//         }\n\n//         swiper.updateSize();\n//         swiper.updateSlides();\n//         swiper.updateProgress();\n//         swiper.updateSlidesClasses();\n\n//         function setTranslate() {\n//           const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n//           const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n//           swiper.setTranslate(newTranslate);\n//           swiper.updateActiveIndex();\n//           swiper.updateSlidesClasses();\n//         }\n\n//         let translated;\n\n//         if (swiper.params.freeMode && swiper.params.freeMode.enabled) {\n//           setTranslate();\n\n//           if (swiper.params.autoHeight) {\n//             swiper.updateAutoHeight();\n//           }\n//         } else {\n//           if (\n//             (swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) &&\n//             swiper.isEnd &&\n//             !swiper.params.centeredSlides\n//           ) {\n//             translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n//           } else {\n//             translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n//           }\n\n//           if (!translated) {\n//             setTranslate();\n//           }\n//         }\n\n//         if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n//           swiper.checkOverflow();\n//         }\n\n//         swiper.emit('update');\n//       }\n\n//       changeDirection(newDirection, needUpdate = true) {\n//         const swiper = this;\n//         const currentDirection = swiper.params.direction;\n\n//         if (!newDirection) {\n//           // eslint-disable-next-line\n//           newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n//         }\n\n//         if (newDirection === currentDirection || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {\n//           return swiper;\n//         }\n\n//         swiper.$el\n//           .removeClass(`${swiper.params.containerModifierClass}${currentDirection}`)\n//           .addClass(`${swiper.params.containerModifierClass}${newDirection}`);\n//         swiper.emitContainerClasses();\n//         swiper.params.direction = newDirection;\n//         swiper.slides.each((slideEl) => {\n//           if (newDirection === 'vertical') {\n//             slideEl.style.width = '';\n//           } else {\n//             slideEl.style.height = '';\n//           }\n//         });\n//         swiper.emit('changeDirection');\n//         if (needUpdate) swiper.update();\n//         return swiper;\n//       }\n\n//       mount(el) {\n//         const swiper = this;\n//         if (swiper.mounted) return true; // Find el\n\n//         const $el = $(el || swiper.params.el);\n//         el = $el[0];\n\n//         if (!el) {\n//           return false;\n//         }\n\n//         el.swiper = swiper;\n\n//         const getWrapperSelector = () => {\n//           return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n//         };\n\n//         const getWrapper = () => {\n//           if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n//             const res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items\n\n//             res.children = (options) => $el.children(options);\n\n//             return res;\n//           }\n\n//           return $el.children(getWrapperSelector());\n//         }; // Find Wrapper\n\n//         let $wrapperEl = getWrapper();\n\n//         if ($wrapperEl.length === 0 && swiper.params.createElements) {\n//           const document = getDocument();\n//           const wrapper = document.createElement('div');\n//           $wrapperEl = $(wrapper);\n//           wrapper.className = swiper.params.wrapperClass;\n//           $el.append(wrapper);\n//           $el.children(`.${swiper.params.slideClass}`).each((slideEl) => {\n//             $wrapperEl.append(slideEl);\n//           });\n//         }\n\n//         Object.assign(swiper, {\n//           $el,\n//           el,\n//           $wrapperEl,\n//           wrapperEl: $wrapperEl[0],\n//           mounted: true,\n//           // RTL\n//           rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',\n//           rtlTranslate:\n//             swiper.params.direction === 'horizontal' &&\n//             (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\n//           wrongRTL: $wrapperEl.css('display') === '-webkit-box',\n//         });\n//         return true;\n//       }\n\n//       init(el) {\n//         const swiper = this;\n//         if (swiper.initialized) return swiper;\n//         const mounted = swiper.mount(el);\n//         if (mounted === false) return swiper;\n//         swiper.emit('beforeInit'); // Set breakpoint\n\n//         if (swiper.params.breakpoints) {\n//           swiper.setBreakpoint();\n//         } // Add Classes\n\n//         swiper.addClasses(); // Create loop\n\n//         if (swiper.params.loop) {\n//           swiper.loopCreate();\n//         } // Update size\n\n//         swiper.updateSize(); // Update slides\n\n//         swiper.updateSlides();\n\n//         if (swiper.params.watchOverflow) {\n//           swiper.checkOverflow();\n//         } // Set Grab Cursor\n\n//         if (swiper.params.grabCursor && swiper.enabled) {\n//           swiper.setGrabCursor();\n//         }\n\n//         if (swiper.params.preloadImages) {\n//           swiper.preloadImages();\n//         } // Slide To Initial Slide\n\n//         if (swiper.params.loop) {\n//           swiper.slideTo(\n//             swiper.params.initialSlide + swiper.loopedSlides,\n//             0,\n//             swiper.params.runCallbacksOnInit,\n//             false,\n//             true,\n//           );\n//         } else {\n//           swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n//         } // Attach events\n\n//         swiper.attachEvents(); // Init Flag\n\n//         swiper.initialized = true; // Emit\n\n//         swiper.emit('init');\n//         swiper.emit('afterInit');\n//         return swiper;\n//       }\n\n//       destroy(deleteInstance = true, cleanStyles = true) {\n//         const swiper = this;\n//         const {params, $el, $wrapperEl, slides} = swiper;\n\n//         if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n//           return null;\n//         }\n\n//         swiper.emit('beforeDestroy'); // Init Flag\n\n//         swiper.initialized = false; // Detach events\n\n//         swiper.detachEvents(); // Destroy loop\n\n//         if (params.loop) {\n//           swiper.loopDestroy();\n//         } // Cleanup styles\n\n//         if (cleanStyles) {\n//           swiper.removeClasses();\n//           $el.removeAttr('style');\n//           $wrapperEl.removeAttr('style');\n\n//           if (slides && slides.length) {\n//             slides\n//               .removeClass(\n//                 [params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(\n//                   ' ',\n//                 ),\n//               )\n//               .removeAttr('style')\n//               .removeAttr('data-swiper-slide-index');\n//           }\n//         }\n\n//         swiper.emit('destroy'); // Detach emitter events\n\n//         Object.keys(swiper.eventsListeners).forEach((eventName) => {\n//           swiper.off(eventName);\n//         });\n\n//         if (deleteInstance !== false) {\n//           swiper.$el[0].swiper = null;\n//           deleteProps(swiper);\n//         }\n\n//         swiper.destroyed = true;\n//         return null;\n//       }\n\n//       static extendDefaults(newDefaults) {\n//         extend(extendedDefaults, newDefaults);\n//       }\n\n//       static get extendedDefaults() {\n//         return extendedDefaults;\n//       }\n\n//       static get defaults() {\n//         return defaults;\n//       }\n\n//       static installModule(mod) {\n//         if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n//         const modules = Swiper.prototype.__modules__;\n\n//         if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n//           modules.push(mod);\n//         }\n//       }\n\n//       static use(module) {\n//         if (Array.isArray(module)) {\n//           module.forEach((m) => Swiper.installModule(m));\n//           return Swiper;\n//         }\n\n//         Swiper.installModule(module);\n//         return Swiper;\n//       }\n//     }\n\n//     Object.keys(prototypes).forEach((prototypeGroup) => {\n//       Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n//         Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n//       });\n//     });\n//     Swiper.use([Resize, Observer]);\n\n//     function Virtual({swiper, extendParams, on}) {\n//       extendParams({\n//         virtual: {\n//           enabled: false,\n//           slides: [],\n//           cache: true,\n//           renderSlide: null,\n//           renderExternal: null,\n//           renderExternalUpdate: true,\n//           addSlidesBefore: 0,\n//           addSlidesAfter: 0,\n//         },\n//       });\n//       let cssModeTimeout;\n//       swiper.virtual = {\n//         cache: {},\n//         from: undefined,\n//         to: undefined,\n//         slides: [],\n//         offset: 0,\n//         slidesGrid: [],\n//       };\n\n//       function renderSlide(slide, index) {\n//         const params = swiper.params.virtual;\n\n//         if (params.cache && swiper.virtual.cache[index]) {\n//           return swiper.virtual.cache[index];\n//         }\n\n//         const $slideEl = params.renderSlide\n//           ? $(params.renderSlide.call(swiper, slide, index))\n//           : $(`<div class=\"${swiper.params.slideClass}\" data-swiper-slide-index=\"${index}\">${slide}</div>`);\n//         if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);\n//         if (params.cache) swiper.virtual.cache[index] = $slideEl;\n//         return $slideEl;\n//       }\n\n//       function update(force) {\n//         const {slidesPerView, slidesPerGroup, centeredSlides} = swiper.params;\n//         const {addSlidesBefore, addSlidesAfter} = swiper.params.virtual;\n//         const {\n//           from: previousFrom,\n//           to: previousTo,\n//           slides,\n//           slidesGrid: previousSlidesGrid,\n//           offset: previousOffset,\n//         } = swiper.virtual;\n\n//         if (!swiper.params.cssMode) {\n//           swiper.updateActiveIndex();\n//         }\n\n//         const activeIndex = swiper.activeIndex || 0;\n//         let offsetProp;\n//         if (swiper.rtlTranslate) offsetProp = 'right';\n//         else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n//         let slidesAfter;\n//         let slidesBefore;\n\n//         if (centeredSlides) {\n//           slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n//           slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n//         } else {\n//           slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n//           slidesBefore = slidesPerGroup + addSlidesBefore;\n//         }\n\n//         const from = Math.max((activeIndex || 0) - slidesBefore, 0);\n//         const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);\n//         const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n//         Object.assign(swiper.virtual, {\n//           from,\n//           to,\n//           offset,\n//           slidesGrid: swiper.slidesGrid,\n//         });\n\n//         function onRendered() {\n//           swiper.updateSlides();\n//           swiper.updateProgress();\n//           swiper.updateSlidesClasses();\n\n//           if (swiper.lazy && swiper.params.lazy.enabled) {\n//             swiper.lazy.load();\n//           }\n//         }\n\n//         if (previousFrom === from && previousTo === to && !force) {\n//           if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n//             swiper.slides.css(offsetProp, `${offset}px`);\n//           }\n\n//           swiper.updateProgress();\n//           return;\n//         }\n\n//         if (swiper.params.virtual.renderExternal) {\n//           swiper.params.virtual.renderExternal.call(swiper, {\n//             offset,\n//             from,\n//             to,\n//             slides: (function getSlides() {\n//               const slidesToRender = [];\n\n//               for (let i = from; i <= to; i += 1) {\n//                 slidesToRender.push(slides[i]);\n//               }\n\n//               return slidesToRender;\n//             })(),\n//           });\n\n//           if (swiper.params.virtual.renderExternalUpdate) {\n//             onRendered();\n//           }\n\n//           return;\n//         }\n\n//         const prependIndexes = [];\n//         const appendIndexes = [];\n\n//         if (force) {\n//           swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();\n//         } else {\n//           for (let i = previousFrom; i <= previousTo; i += 1) {\n//             if (i < from || i > to) {\n//               swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${i}\"]`).remove();\n//             }\n//           }\n//         }\n\n//         for (let i = 0; i < slides.length; i += 1) {\n//           if (i >= from && i <= to) {\n//             if (typeof previousTo === 'undefined' || force) {\n//               appendIndexes.push(i);\n//             } else {\n//               if (i > previousTo) appendIndexes.push(i);\n//               if (i < previousFrom) prependIndexes.push(i);\n//             }\n//           }\n//         }\n\n//         appendIndexes.forEach((index) => {\n//           swiper.$wrapperEl.append(renderSlide(slides[index], index));\n//         });\n//         prependIndexes\n//           .sort((a, b) => b - a)\n//           .forEach((index) => {\n//             swiper.$wrapperEl.prepend(renderSlide(slides[index], index));\n//           });\n//         swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);\n//         onRendered();\n//       }\n\n//       function appendSlide(slides) {\n//         if (typeof slides === 'object' && 'length' in slides) {\n//           for (let i = 0; i < slides.length; i += 1) {\n//             if (slides[i]) swiper.virtual.slides.push(slides[i]);\n//           }\n//         } else {\n//           swiper.virtual.slides.push(slides);\n//         }\n\n//         update(true);\n//       }\n\n//       function prependSlide(slides) {\n//         const activeIndex = swiper.activeIndex;\n//         let newActiveIndex = activeIndex + 1;\n//         let numberOfNewSlides = 1;\n\n//         if (Array.isArray(slides)) {\n//           for (let i = 0; i < slides.length; i += 1) {\n//             if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n//           }\n\n//           newActiveIndex = activeIndex + slides.length;\n//           numberOfNewSlides = slides.length;\n//         } else {\n//           swiper.virtual.slides.unshift(slides);\n//         }\n\n//         if (swiper.params.virtual.cache) {\n//           const cache = swiper.virtual.cache;\n//           const newCache = {};\n//           Object.keys(cache).forEach((cachedIndex) => {\n//             const $cachedEl = cache[cachedIndex];\n//             const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');\n\n//             if (cachedElIndex) {\n//               $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);\n//             }\n\n//             newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;\n//           });\n//           swiper.virtual.cache = newCache;\n//         }\n\n//         update(true);\n//         swiper.slideTo(newActiveIndex, 0);\n//       }\n\n//       function removeSlide(slidesIndexes) {\n//         if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n//         let activeIndex = swiper.activeIndex;\n\n//         if (Array.isArray(slidesIndexes)) {\n//           for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n//             swiper.virtual.slides.splice(slidesIndexes[i], 1);\n\n//             if (swiper.params.virtual.cache) {\n//               delete swiper.virtual.cache[slidesIndexes[i]];\n//             }\n\n//             if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n//             activeIndex = Math.max(activeIndex, 0);\n//           }\n//         } else {\n//           swiper.virtual.slides.splice(slidesIndexes, 1);\n\n//           if (swiper.params.virtual.cache) {\n//             delete swiper.virtual.cache[slidesIndexes];\n//           }\n\n//           if (slidesIndexes < activeIndex) activeIndex -= 1;\n//           activeIndex = Math.max(activeIndex, 0);\n//         }\n\n//         update(true);\n//         swiper.slideTo(activeIndex, 0);\n//       }\n\n//       function removeAllSlides() {\n//         swiper.virtual.slides = [];\n\n//         if (swiper.params.virtual.cache) {\n//           swiper.virtual.cache = {};\n//         }\n\n//         update(true);\n//         swiper.slideTo(0, 0);\n//       }\n\n//       on('beforeInit', () => {\n//         if (!swiper.params.virtual.enabled) return;\n//         swiper.virtual.slides = swiper.params.virtual.slides;\n//         swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n//         swiper.params.watchSlidesProgress = true;\n//         swiper.originalParams.watchSlidesProgress = true;\n\n//         if (!swiper.params.initialSlide) {\n//           update();\n//         }\n//       });\n//       on('setTranslate', () => {\n//         if (!swiper.params.virtual.enabled) return;\n\n//         if (swiper.params.cssMode && !swiper._immediateVirtual) {\n//           clearTimeout(cssModeTimeout);\n//           cssModeTimeout = setTimeout(() => {\n//             update();\n//           }, 100);\n//         } else {\n//           update();\n//         }\n//       });\n//       on('init update resize', () => {\n//         if (!swiper.params.virtual.enabled) return;\n\n//         if (swiper.params.cssMode) {\n//           setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n//         }\n//       });\n//       Object.assign(swiper.virtual, {\n//         appendSlide,\n//         prependSlide,\n//         removeSlide,\n//         removeAllSlides,\n//         update,\n//       });\n//     }\n\n//     /* eslint-disable consistent-return */\n//     function Keyboard({swiper, extendParams, on, emit}) {\n//       const document = getDocument();\n//       const window = getWindow();\n//       swiper.keyboard = {\n//         enabled: false,\n//       };\n//       extendParams({\n//         keyboard: {\n//           enabled: false,\n//           onlyInViewport: true,\n//           pageUpDown: true,\n//         },\n//       });\n\n//       function handle(event) {\n//         if (!swiper.enabled) return;\n//         const {rtlTranslate: rtl} = swiper;\n//         let e = event;\n//         if (e.originalEvent) e = e.originalEvent; // jquery fix\n\n//         const kc = e.keyCode || e.charCode;\n//         const pageUpDown = swiper.params.keyboard.pageUpDown;\n//         const isPageUp = pageUpDown && kc === 33;\n//         const isPageDown = pageUpDown && kc === 34;\n//         const isArrowLeft = kc === 37;\n//         const isArrowRight = kc === 39;\n//         const isArrowUp = kc === 38;\n//         const isArrowDown = kc === 40; // Directions locks\n\n//         if (\n//           !swiper.allowSlideNext &&\n//           ((swiper.isHorizontal() && isArrowRight) || (swiper.isVertical() && isArrowDown) || isPageDown)\n//         ) {\n//           return false;\n//         }\n\n//         if (\n//           !swiper.allowSlidePrev &&\n//           ((swiper.isHorizontal() && isArrowLeft) || (swiper.isVertical() && isArrowUp) || isPageUp)\n//         ) {\n//           return false;\n//         }\n\n//         if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n//           return undefined;\n//         }\n\n//         if (\n//           document.activeElement &&\n//           document.activeElement.nodeName &&\n//           (document.activeElement.nodeName.toLowerCase() === 'input' ||\n//             document.activeElement.nodeName.toLowerCase() === 'textarea')\n//         ) {\n//           return undefined;\n//         }\n\n//         if (\n//           swiper.params.keyboard.onlyInViewport &&\n//           (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)\n//         ) {\n//           let inView = false; // Check that swiper should be inside of visible area of window\n\n//           if (\n//             swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 &&\n//             swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0\n//           ) {\n//             return undefined;\n//           }\n\n//           const $el = swiper.$el;\n//           const swiperWidth = $el[0].clientWidth;\n//           const swiperHeight = $el[0].clientHeight;\n//           const windowWidth = window.innerWidth;\n//           const windowHeight = window.innerHeight;\n//           const swiperOffset = swiper.$el.offset();\n//           if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;\n//           const swiperCoord = [\n//             [swiperOffset.left, swiperOffset.top],\n//             [swiperOffset.left + swiperWidth, swiperOffset.top],\n//             [swiperOffset.left, swiperOffset.top + swiperHeight],\n//             [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight],\n//           ];\n\n//           for (let i = 0; i < swiperCoord.length; i += 1) {\n//             const point = swiperCoord[i];\n\n//             if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n//               if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n\n//               inView = true;\n//             }\n//           }\n\n//           if (!inView) return undefined;\n//         }\n\n//         if (swiper.isHorizontal()) {\n//           if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n//             if (e.preventDefault) e.preventDefault();\n//             else e.returnValue = false;\n//           }\n\n//           if (((isPageDown || isArrowRight) && !rtl) || ((isPageUp || isArrowLeft) && rtl)) swiper.slideNext();\n//           if (((isPageUp || isArrowLeft) && !rtl) || ((isPageDown || isArrowRight) && rtl)) swiper.slidePrev();\n//         } else {\n//           if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n//             if (e.preventDefault) e.preventDefault();\n//             else e.returnValue = false;\n//           }\n\n//           if (isPageDown || isArrowDown) swiper.slideNext();\n//           if (isPageUp || isArrowUp) swiper.slidePrev();\n//         }\n\n//         emit('keyPress', kc);\n//         return undefined;\n//       }\n\n//       function enable() {\n//         if (swiper.keyboard.enabled) return;\n//         $(document).on('keydown', handle);\n//         swiper.keyboard.enabled = true;\n//       }\n\n//       function disable() {\n//         if (!swiper.keyboard.enabled) return;\n//         $(document).off('keydown', handle);\n//         swiper.keyboard.enabled = false;\n//       }\n\n//       on('init', () => {\n//         if (swiper.params.keyboard.enabled) {\n//           enable();\n//         }\n//       });\n//       on('destroy', () => {\n//         if (swiper.keyboard.enabled) {\n//           disable();\n//         }\n//       });\n//       Object.assign(swiper.keyboard, {\n//         enable,\n//         disable,\n//       });\n//     }\n\n//     /* eslint-disable consistent-return */\n//     function Mousewheel({swiper, extendParams, on, emit}) {\n//       const window = getWindow();\n//       extendParams({\n//         mousewheel: {\n//           enabled: false,\n//           releaseOnEdges: false,\n//           invert: false,\n//           forceToAxis: false,\n//           sensitivity: 1,\n//           eventsTarget: 'container',\n//           thresholdDelta: null,\n//           thresholdTime: null,\n//         },\n//       });\n//       swiper.mousewheel = {\n//         enabled: false,\n//       };\n//       let timeout;\n//       let lastScrollTime = now();\n//       let lastEventBeforeSnap;\n//       const recentWheelEvents = [];\n\n//       function normalize(e) {\n//         // Reasonable defaults\n//         const PIXEL_STEP = 10;\n//         const LINE_HEIGHT = 40;\n//         const PAGE_HEIGHT = 800;\n//         let sX = 0;\n//         let sY = 0; // spinX, spinY\n\n//         let pX = 0;\n//         let pY = 0; // pixelX, pixelY\n//         // Legacy\n\n//         if ('detail' in e) {\n//           sY = e.detail;\n//         }\n\n//         if ('wheelDelta' in e) {\n//           sY = -e.wheelDelta / 120;\n//         }\n\n//         if ('wheelDeltaY' in e) {\n//           sY = -e.wheelDeltaY / 120;\n//         }\n\n//         if ('wheelDeltaX' in e) {\n//           sX = -e.wheelDeltaX / 120;\n//         } // side scrolling on FF with DOMMouseScroll\n\n//         if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n//           sX = sY;\n//           sY = 0;\n//         }\n\n//         pX = sX * PIXEL_STEP;\n//         pY = sY * PIXEL_STEP;\n\n//         if ('deltaY' in e) {\n//           pY = e.deltaY;\n//         }\n\n//         if ('deltaX' in e) {\n//           pX = e.deltaX;\n//         }\n\n//         if (e.shiftKey && !pX) {\n//           // if user scrolls with shift he wants horizontal scroll\n//           pX = pY;\n//           pY = 0;\n//         }\n\n//         if ((pX || pY) && e.deltaMode) {\n//           if (e.deltaMode === 1) {\n//             // delta in LINE units\n//             pX *= LINE_HEIGHT;\n//             pY *= LINE_HEIGHT;\n//           } else {\n//             // delta in PAGE units\n//             pX *= PAGE_HEIGHT;\n//             pY *= PAGE_HEIGHT;\n//           }\n//         } // Fall-back if spin cannot be determined\n\n//         if (pX && !sX) {\n//           sX = pX < 1 ? -1 : 1;\n//         }\n\n//         if (pY && !sY) {\n//           sY = pY < 1 ? -1 : 1;\n//         }\n\n//         return {\n//           spinX: sX,\n//           spinY: sY,\n//           pixelX: pX,\n//           pixelY: pY,\n//         };\n//       }\n\n//       function handleMouseEnter() {\n//         if (!swiper.enabled) return;\n//         swiper.mouseEntered = true;\n//       }\n\n//       function handleMouseLeave() {\n//         if (!swiper.enabled) return;\n//         swiper.mouseEntered = false;\n//       }\n\n//       function animateSlider(newEvent) {\n//         if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n//           // Prevent if delta of wheel scroll delta is below configured threshold\n//           return false;\n//         }\n\n//         if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n//           // Prevent if time between scrolls is below configured threshold\n//           return false;\n//         } // If the movement is NOT big enough and\n//         // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n//         //   Don't go any further (avoid insignificant scroll movement).\n\n//         if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n//           // Return false as a default\n//           return true;\n//         } // If user is scrolling towards the end:\n//         //   If the slider hasn't hit the latest slide or\n//         //   if the slider is a loop and\n//         //   if the slider isn't moving right now:\n//         //     Go to next slide and\n//         //     emit a scroll event.\n//         // Else (the user is scrolling towards the beginning) and\n//         // if the slider hasn't hit the first slide or\n//         // if the slider is a loop and\n//         // if the slider isn't moving right now:\n//         //   Go to prev slide and\n//         //   emit a scroll event.\n\n//         if (newEvent.direction < 0) {\n//           if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n//             swiper.slideNext();\n//             emit('scroll', newEvent.raw);\n//           }\n//         } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n//           swiper.slidePrev();\n//           emit('scroll', newEvent.raw);\n//         } // If you got here is because an animation has been triggered so store the current time\n\n//         lastScrollTime = new window.Date().getTime(); // Return false as a default\n\n//         return false;\n//       }\n\n//       function releaseScroll(newEvent) {\n//         const params = swiper.params.mousewheel;\n\n//         if (newEvent.direction < 0) {\n//           if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n//             // Return true to animate scroll on edges\n//             return true;\n//           }\n//         } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n//           // Return true to animate scroll on edges\n//           return true;\n//         }\n\n//         return false;\n//       }\n\n//       function handle(event) {\n//         let e = event;\n//         let disableParentSwiper = true;\n//         if (!swiper.enabled) return;\n//         const params = swiper.params.mousewheel;\n\n//         if (swiper.params.cssMode) {\n//           e.preventDefault();\n//         }\n\n//         let target = swiper.$el;\n\n//         if (swiper.params.mousewheel.eventsTarget !== 'container') {\n//           target = $(swiper.params.mousewheel.eventsTarget);\n//         }\n\n//         if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;\n//         if (e.originalEvent) e = e.originalEvent; // jquery fix\n\n//         let delta = 0;\n//         const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n//         const data = normalize(e);\n\n//         if (params.forceToAxis) {\n//           if (swiper.isHorizontal()) {\n//             if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;\n//             else return true;\n//           } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;\n//           else return true;\n//         } else {\n//           delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n//         }\n\n//         if (delta === 0) return true;\n//         if (params.invert) delta = -delta; // Get the scroll positions\n\n//         let positions = swiper.getTranslate() + delta * params.sensitivity;\n//         if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n//         if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:\n//         //     the disableParentSwiper will be true.\n//         // When loop is false:\n//         //     if the scroll positions is not on edge,\n//         //     then the disableParentSwiper will be true.\n//         //     if the scroll on edge positions,\n//         //     then the disableParentSwiper will be false.\n\n//         disableParentSwiper = swiper.params.loop\n//           ? true\n//           : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n//         if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n\n//         if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n//           // Register the new event in a variable which stores the relevant data\n//           const newEvent = {\n//             time: now(),\n//             delta: Math.abs(delta),\n//             direction: Math.sign(delta),\n//             raw: event,\n//           }; // Keep the most recent events\n\n//           if (recentWheelEvents.length >= 2) {\n//             recentWheelEvents.shift(); // only store the last N events\n//           }\n\n//           const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n//           recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:\n//           //   If direction has changed or\n//           //   if the scroll is quicker than the previous one:\n//           //     Animate the slider.\n//           // Else (this is the first time the wheel is moved):\n//           //     Animate the slider.\n\n//           if (prevEvent) {\n//             if (\n//               newEvent.direction !== prevEvent.direction ||\n//               newEvent.delta > prevEvent.delta ||\n//               newEvent.time > prevEvent.time + 150\n//             ) {\n//               animateSlider(newEvent);\n//             }\n//           } else {\n//             animateSlider(newEvent);\n//           } // If it's time to release the scroll:\n//           //   Return now so you don't hit the preventDefault.\n\n//           if (releaseScroll(newEvent)) {\n//             return true;\n//           }\n//         } else {\n//           // Freemode or scrollContainer:\n//           // If we recently snapped after a momentum scroll, then ignore wheel events\n//           // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n//           // or if it's a new scroll (larger delta or inverse sign as last event before\n//           // an end-of-momentum snap).\n//           const newEvent = {\n//             time: now(),\n//             delta: Math.abs(delta),\n//             direction: Math.sign(delta),\n//           };\n//           const ignoreWheelEvents =\n//             lastEventBeforeSnap &&\n//             newEvent.time < lastEventBeforeSnap.time + 500 &&\n//             newEvent.delta <= lastEventBeforeSnap.delta &&\n//             newEvent.direction === lastEventBeforeSnap.direction;\n\n//           if (!ignoreWheelEvents) {\n//             lastEventBeforeSnap = undefined;\n\n//             if (swiper.params.loop) {\n//               swiper.loopFix();\n//             }\n\n//             let position = swiper.getTranslate() + delta * params.sensitivity;\n//             const wasBeginning = swiper.isBeginning;\n//             const wasEnd = swiper.isEnd;\n//             if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n//             if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n//             swiper.setTransition(0);\n//             swiper.setTranslate(position);\n//             swiper.updateProgress();\n//             swiper.updateActiveIndex();\n//             swiper.updateSlidesClasses();\n\n//             if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {\n//               swiper.updateSlidesClasses();\n//             }\n\n//             if (swiper.params.freeMode.sticky) {\n//               // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n//               // the end of a momentum scroll by storing recent (N=15?) wheel events.\n//               // 1. do all N events have decreasing or same (absolute value) delta?\n//               // 2. did all N events arrive in the last M (M=500?) msecs?\n//               // 3. does the earliest event have an (absolute value) delta that's\n//               //    at least P (P=1?) larger than the most recent event's delta?\n//               // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n//               // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n//               // Snap immediately and ignore remaining wheel events in this scroll.\n//               // See comment above for \"remaining wheel events in this scroll\" determination.\n//               // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n//               clearTimeout(timeout);\n//               timeout = undefined;\n\n//               if (recentWheelEvents.length >= 15) {\n//                 recentWheelEvents.shift(); // only store the last N events\n//               }\n\n//               const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n//               const firstEvent = recentWheelEvents[0];\n//               recentWheelEvents.push(newEvent);\n\n//               if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n//                 // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n//                 recentWheelEvents.splice(0);\n//               } else if (\n//                 recentWheelEvents.length >= 15 &&\n//                 newEvent.time - firstEvent.time < 500 &&\n//                 firstEvent.delta - newEvent.delta >= 1 &&\n//                 newEvent.delta <= 6\n//               ) {\n//                 // We're at the end of the deceleration of a momentum scroll, so there's no need\n//                 // to wait for more events. Snap ASAP on the next tick.\n//                 // Also, because there's some remaining momentum we'll bias the snap in the\n//                 // direction of the ongoing scroll because it's better UX for the scroll to snap\n//                 // in the same direction as the scroll instead of reversing to snap.  Therefore,\n//                 // if it's already scrolled more than 20% in the current direction, keep going.\n//                 const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n//                 lastEventBeforeSnap = newEvent;\n//                 recentWheelEvents.splice(0);\n//                 timeout = nextTick(() => {\n//                   swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n//                 }, 0); // no delay; move on next tick\n//               }\n\n//               if (!timeout) {\n//                 // if we get here, then we haven't detected the end of a momentum scroll, so\n//                 // we'll consider a scroll \"complete\" when there haven't been any wheel events\n//                 // for 500ms.\n//                 timeout = nextTick(() => {\n//                   const snapToThreshold = 0.5;\n//                   lastEventBeforeSnap = newEvent;\n//                   recentWheelEvents.splice(0);\n//                   swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n//                 }, 500);\n//               }\n//             } // Emit event\n\n//             if (!ignoreWheelEvents) emit('scroll', e); // Stop autoplay\n\n//             if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions\n\n//             if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n//           }\n//         }\n\n//         if (e.preventDefault) e.preventDefault();\n//         else e.returnValue = false;\n//         return false;\n//       }\n\n//       function events(method) {\n//         let target = swiper.$el;\n\n//         if (swiper.params.mousewheel.eventsTarget !== 'container') {\n//           target = $(swiper.params.mousewheel.eventsTarget);\n//         }\n\n//         target[method]('mouseenter', handleMouseEnter);\n//         target[method]('mouseleave', handleMouseLeave);\n//         target[method]('wheel', handle);\n//       }\n\n//       function enable() {\n//         if (swiper.params.cssMode) {\n//           swiper.wrapperEl.removeEventListener('wheel', handle);\n//           return true;\n//         }\n\n//         if (swiper.mousewheel.enabled) return false;\n//         events('on');\n//         swiper.mousewheel.enabled = true;\n//         return true;\n//       }\n\n//       function disable() {\n//         if (swiper.params.cssMode) {\n//           swiper.wrapperEl.addEventListener(event, handle);\n//           return true;\n//         }\n\n//         if (!swiper.mousewheel.enabled) return false;\n//         events('off');\n//         swiper.mousewheel.enabled = false;\n//         return true;\n//       }\n\n//       on('init', () => {\n//         if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n//           disable();\n//         }\n\n//         if (swiper.params.mousewheel.enabled) enable();\n//       });\n//       on('destroy', () => {\n//         if (swiper.params.cssMode) {\n//           enable();\n//         }\n\n//         if (swiper.mousewheel.enabled) disable();\n//       });\n//       Object.assign(swiper.mousewheel, {\n//         enable,\n//         disable,\n//       });\n//     }\n\n//     function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n//       const document = getDocument();\n\n//       if (swiper.params.createElements) {\n//         Object.keys(checkProps).forEach((key) => {\n//           if (!params[key] && params.auto === true) {\n//             let element = swiper.$el.children(`.${checkProps[key]}`)[0];\n\n//             if (!element) {\n//               element = document.createElement('div');\n//               element.className = checkProps[key];\n//               swiper.$el.append(element);\n//             }\n\n//             params[key] = element;\n//             originalParams[key] = element;\n//           }\n//         });\n//       }\n\n//       return params;\n//     }\n\n//     function Navigation({swiper, extendParams, on, emit}) {\n//       extendParams({\n//         navigation: {\n//           nextEl: null,\n//           prevEl: null,\n//           hideOnClick: false,\n//           disabledClass: 'swiper-button-disabled',\n//           hiddenClass: 'swiper-button-hidden',\n//           lockClass: 'swiper-button-lock',\n//         },\n//       });\n//       swiper.navigation = {\n//         nextEl: null,\n//         $nextEl: null,\n//         prevEl: null,\n//         $prevEl: null,\n//       };\n\n//       function getEl(el) {\n//         let $el;\n\n//         if (el) {\n//           $el = $(el);\n\n//           if (\n//             swiper.params.uniqueNavElements &&\n//             typeof el === 'string' &&\n//             $el.length > 1 &&\n//             swiper.$el.find(el).length === 1\n//           ) {\n//             $el = swiper.$el.find(el);\n//           }\n//         }\n\n//         return $el;\n//       }\n\n//       function toggleEl($el, disabled) {\n//         const params = swiper.params.navigation;\n\n//         if ($el && $el.length > 0) {\n//           $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);\n//           if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;\n\n//           if (swiper.params.watchOverflow && swiper.enabled) {\n//             $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n//           }\n//         }\n//       }\n\n//       function update() {\n//         // Update Navigation Buttons\n//         if (swiper.params.loop) return;\n//         const {$nextEl, $prevEl} = swiper.navigation;\n//         toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);\n//         toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);\n//       }\n\n//       function onPrevClick(e) {\n//         e.preventDefault();\n//         if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n//         swiper.slidePrev();\n//       }\n\n//       function onNextClick(e) {\n//         e.preventDefault();\n//         if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n//         swiper.slideNext();\n//       }\n\n//       function init() {\n//         const params = swiper.params.navigation;\n//         swiper.params.navigation = createElementIfNotDefined(\n//           swiper,\n//           swiper.originalParams.navigation,\n//           swiper.params.navigation,\n//           {\n//             nextEl: 'swiper-button-next',\n//             prevEl: 'swiper-button-prev',\n//           },\n//         );\n//         if (!(params.nextEl || params.prevEl)) return;\n//         const $nextEl = getEl(params.nextEl);\n//         const $prevEl = getEl(params.prevEl);\n\n//         if ($nextEl && $nextEl.length > 0) {\n//           $nextEl.on('click', onNextClick);\n//         }\n\n//         if ($prevEl && $prevEl.length > 0) {\n//           $prevEl.on('click', onPrevClick);\n//         }\n\n//         Object.assign(swiper.navigation, {\n//           $nextEl,\n//           nextEl: $nextEl && $nextEl[0],\n//           $prevEl,\n//           prevEl: $prevEl && $prevEl[0],\n//         });\n\n//         if (!swiper.enabled) {\n//           if ($nextEl) $nextEl.addClass(params.lockClass);\n//           if ($prevEl) $prevEl.addClass(params.lockClass);\n//         }\n//       }\n\n//       function destroy() {\n//         const {$nextEl, $prevEl} = swiper.navigation;\n\n//         if ($nextEl && $nextEl.length) {\n//           $nextEl.off('click', onNextClick);\n//           $nextEl.removeClass(swiper.params.navigation.disabledClass);\n//         }\n\n//         if ($prevEl && $prevEl.length) {\n//           $prevEl.off('click', onPrevClick);\n//           $prevEl.removeClass(swiper.params.navigation.disabledClass);\n//         }\n//       }\n\n//       on('init', () => {\n//         init();\n//         update();\n//       });\n//       on('toEdge fromEdge lock unlock', () => {\n//         update();\n//       });\n//       on('destroy', () => {\n//         destroy();\n//       });\n//       on('enable disable', () => {\n//         const {$nextEl, $prevEl} = swiper.navigation;\n\n//         if ($nextEl) {\n//           $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);\n//         }\n\n//         if ($prevEl) {\n//           $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);\n//         }\n//       });\n//       on('click', (_s, e) => {\n//         const {$nextEl, $prevEl} = swiper.navigation;\n//         const targetEl = e.target;\n\n//         if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {\n//           if (\n//             swiper.pagination &&\n//             swiper.params.pagination &&\n//             swiper.params.pagination.clickable &&\n//             (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))\n//           )\n//             return;\n//           let isHidden;\n\n//           if ($nextEl) {\n//             isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);\n//           } else if ($prevEl) {\n//             isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);\n//           }\n\n//           if (isHidden === true) {\n//             emit('navigationShow');\n//           } else {\n//             emit('navigationHide');\n//           }\n\n//           if ($nextEl) {\n//             $nextEl.toggleClass(swiper.params.navigation.hiddenClass);\n//           }\n\n//           if ($prevEl) {\n//             $prevEl.toggleClass(swiper.params.navigation.hiddenClass);\n//           }\n//         }\n//       });\n//       Object.assign(swiper.navigation, {\n//         update,\n//         init,\n//         destroy,\n//       });\n//     }\n\n//     function classesToSelector(classes = '') {\n//       return `.${classes\n//         .trim()\n//         .replace(/([\\.:!\\/])/g, '\\\\$1') // eslint-disable-line\n//         .replace(/ /g, '.')}`;\n//     }\n\n//     function Pagination({swiper, extendParams, on, emit}) {\n//       const pfx = 'swiper-pagination';\n//       extendParams({\n//         pagination: {\n//           el: null,\n//           bulletElement: 'span',\n//           clickable: false,\n//           hideOnClick: false,\n//           renderBullet: null,\n//           renderProgressbar: null,\n//           renderFraction: null,\n//           renderCustom: null,\n//           progressbarOpposite: false,\n//           type: 'bullets',\n//           // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n//           dynamicBullets: false,\n//           dynamicMainBullets: 1,\n//           formatFractionCurrent: (number) => number,\n//           formatFractionTotal: (number) => number,\n//           bulletClass: `${pfx}-bullet`,\n//           bulletActiveClass: `${pfx}-bullet-active`,\n//           modifierClass: `${pfx}-`,\n//           currentClass: `${pfx}-current`,\n//           totalClass: `${pfx}-total`,\n//           hiddenClass: `${pfx}-hidden`,\n//           progressbarFillClass: `${pfx}-progressbar-fill`,\n//           progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n//           clickableClass: `${pfx}-clickable`,\n//           lockClass: `${pfx}-lock`,\n//           horizontalClass: `${pfx}-horizontal`,\n//           verticalClass: `${pfx}-vertical`,\n//         },\n//       });\n//       swiper.pagination = {\n//         el: null,\n//         $el: null,\n//         bullets: [],\n//       };\n//       let bulletSize;\n//       let dynamicBulletIndex = 0;\n\n//       function isPaginationDisabled() {\n//         return (\n//           !swiper.params.pagination.el ||\n//           !swiper.pagination.el ||\n//           !swiper.pagination.$el ||\n//           swiper.pagination.$el.length === 0\n//         );\n//       }\n\n//       function setSideBullets($bulletEl, position) {\n//         const {bulletActiveClass} = swiper.params.pagination;\n//         $bulletEl[position]()\n//           .addClass(`${bulletActiveClass}-${position}`)\n//           [position]()\n//           .addClass(`${bulletActiveClass}-${position}-${position}`);\n//       }\n\n//       function update() {\n//         // Render || Update Pagination bullets/items\n//         const rtl = swiper.rtl;\n//         const params = swiper.params.pagination;\n//         if (isPaginationDisabled()) return;\n//         const slidesLength =\n//           swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n//         const $el = swiper.pagination.$el; // Current/Total\n\n//         let current;\n//         const total = swiper.params.loop\n//           ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup)\n//           : swiper.snapGrid.length;\n\n//         if (swiper.params.loop) {\n//           current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);\n\n//           if (current > slidesLength - 1 - swiper.loopedSlides * 2) {\n//             current -= slidesLength - swiper.loopedSlides * 2;\n//           }\n\n//           if (current > total - 1) current -= total;\n//           if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;\n//         } else if (typeof swiper.snapIndex !== 'undefined') {\n//           current = swiper.snapIndex;\n//         } else {\n//           current = swiper.activeIndex || 0;\n//         } // Types\n\n//         if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n//           const bullets = swiper.pagination.bullets;\n//           let firstIndex;\n//           let lastIndex;\n//           let midIndex;\n\n//           if (params.dynamicBullets) {\n//             bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);\n//             $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);\n\n//             if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {\n//               dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);\n\n//               if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n//                 dynamicBulletIndex = params.dynamicMainBullets - 1;\n//               } else if (dynamicBulletIndex < 0) {\n//                 dynamicBulletIndex = 0;\n//               }\n//             }\n\n//             firstIndex = Math.max(current - dynamicBulletIndex, 0);\n//             lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n//             midIndex = (lastIndex + firstIndex) / 2;\n//           }\n\n//           bullets.removeClass(\n//             ['', '-next', '-next-next', '-prev', '-prev-prev', '-main']\n//               .map((suffix) => `${params.bulletActiveClass}${suffix}`)\n//               .join(' '),\n//           );\n\n//           if ($el.length > 1) {\n//             bullets.each((bullet) => {\n//               const $bullet = $(bullet);\n//               const bulletIndex = $bullet.index();\n\n//               if (bulletIndex === current) {\n//                 $bullet.addClass(params.bulletActiveClass);\n//               }\n\n//               if (params.dynamicBullets) {\n//                 if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n//                   $bullet.addClass(`${params.bulletActiveClass}-main`);\n//                 }\n\n//                 if (bulletIndex === firstIndex) {\n//                   setSideBullets($bullet, 'prev');\n//                 }\n\n//                 if (bulletIndex === lastIndex) {\n//                   setSideBullets($bullet, 'next');\n//                 }\n//               }\n//             });\n//           } else {\n//             const $bullet = bullets.eq(current);\n//             const bulletIndex = $bullet.index();\n//             $bullet.addClass(params.bulletActiveClass);\n\n//             if (params.dynamicBullets) {\n//               const $firstDisplayedBullet = bullets.eq(firstIndex);\n//               const $lastDisplayedBullet = bullets.eq(lastIndex);\n\n//               for (let i = firstIndex; i <= lastIndex; i += 1) {\n//                 bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);\n//               }\n\n//               if (swiper.params.loop) {\n//                 if (bulletIndex >= bullets.length) {\n//                   for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {\n//                     bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);\n//                   }\n\n//                   bullets\n//                     .eq(bullets.length - params.dynamicMainBullets - 1)\n//                     .addClass(`${params.bulletActiveClass}-prev`);\n//                 } else {\n//                   setSideBullets($firstDisplayedBullet, 'prev');\n//                   setSideBullets($lastDisplayedBullet, 'next');\n//                 }\n//               } else {\n//                 setSideBullets($firstDisplayedBullet, 'prev');\n//                 setSideBullets($lastDisplayedBullet, 'next');\n//               }\n//             }\n//           }\n\n//           if (params.dynamicBullets) {\n//             const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n//             const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n//             const offsetProp = rtl ? 'right' : 'left';\n//             bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);\n//           }\n//         }\n\n//         if (params.type === 'fraction') {\n//           $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));\n//           $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));\n//         }\n\n//         if (params.type === 'progressbar') {\n//           let progressbarDirection;\n\n//           if (params.progressbarOpposite) {\n//             progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n//           } else {\n//             progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n//           }\n\n//           const scale = (current + 1) / total;\n//           let scaleX = 1;\n//           let scaleY = 1;\n\n//           if (progressbarDirection === 'horizontal') {\n//             scaleX = scale;\n//           } else {\n//             scaleY = scale;\n//           }\n\n//           $el\n//             .find(classesToSelector(params.progressbarFillClass))\n//             .transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`)\n//             .transition(swiper.params.speed);\n//         }\n\n//         if (params.type === 'custom' && params.renderCustom) {\n//           $el.html(params.renderCustom(swiper, current + 1, total));\n//           emit('paginationRender', $el[0]);\n//         } else {\n//           emit('paginationUpdate', $el[0]);\n//         }\n\n//         if (swiper.params.watchOverflow && swiper.enabled) {\n//           $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n//         }\n//       }\n\n//       function render() {\n//         // Render Container\n//         const params = swiper.params.pagination;\n//         if (isPaginationDisabled()) return;\n//         const slidesLength =\n//           swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n//         const $el = swiper.pagination.$el;\n//         let paginationHTML = '';\n\n//         if (params.type === 'bullets') {\n//           let numberOfBullets = swiper.params.loop\n//             ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup)\n//             : swiper.snapGrid.length;\n\n//           if (\n//             swiper.params.freeMode &&\n//             swiper.params.freeMode.enabled &&\n//             !swiper.params.loop &&\n//             numberOfBullets > slidesLength\n//           ) {\n//             numberOfBullets = slidesLength;\n//           }\n\n//           for (let i = 0; i < numberOfBullets; i += 1) {\n//             if (params.renderBullet) {\n//               paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n//             } else {\n//               paginationHTML += `<${params.bulletElement} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n//             }\n//           }\n\n//           $el.html(paginationHTML);\n//           swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));\n//         }\n\n//         if (params.type === 'fraction') {\n//           if (params.renderFraction) {\n//             paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n//           } else {\n//             paginationHTML =\n//               `<span class=\"${params.currentClass}\"></span>` + ' / ' + `<span class=\"${params.totalClass}\"></span>`;\n//           }\n\n//           $el.html(paginationHTML);\n//         }\n\n//         if (params.type === 'progressbar') {\n//           if (params.renderProgressbar) {\n//             paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n//           } else {\n//             paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n//           }\n\n//           $el.html(paginationHTML);\n//         }\n\n//         if (params.type !== 'custom') {\n//           emit('paginationRender', swiper.pagination.$el[0]);\n//         }\n//       }\n\n//       function init() {\n//         swiper.params.pagination = createElementIfNotDefined(\n//           swiper,\n//           swiper.originalParams.pagination,\n//           swiper.params.pagination,\n//           {\n//             el: 'swiper-pagination',\n//           },\n//         );\n//         const params = swiper.params.pagination;\n//         if (!params.el) return;\n//         let $el = $(params.el);\n//         if ($el.length === 0) return;\n\n//         if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {\n//           $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper\n\n//           if ($el.length > 1) {\n//             $el = $el.filter((el) => {\n//               if ($(el).parents('.swiper')[0] !== swiper.el) return false;\n//               return true;\n//             });\n//           }\n//         }\n\n//         if (params.type === 'bullets' && params.clickable) {\n//           $el.addClass(params.clickableClass);\n//         }\n\n//         $el.addClass(params.modifierClass + params.type);\n//         $el.addClass(params.modifierClass + swiper.params.direction);\n\n//         if (params.type === 'bullets' && params.dynamicBullets) {\n//           $el.addClass(`${params.modifierClass}${params.type}-dynamic`);\n//           dynamicBulletIndex = 0;\n\n//           if (params.dynamicMainBullets < 1) {\n//             params.dynamicMainBullets = 1;\n//           }\n//         }\n\n//         if (params.type === 'progressbar' && params.progressbarOpposite) {\n//           $el.addClass(params.progressbarOppositeClass);\n//         }\n\n//         if (params.clickable) {\n//           $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {\n//             e.preventDefault();\n//             let index = $(this).index() * swiper.params.slidesPerGroup;\n//             if (swiper.params.loop) index += swiper.loopedSlides;\n//             swiper.slideTo(index);\n//           });\n//         }\n\n//         Object.assign(swiper.pagination, {\n//           $el,\n//           el: $el[0],\n//         });\n\n//         if (!swiper.enabled) {\n//           $el.addClass(params.lockClass);\n//         }\n//       }\n\n//       function destroy() {\n//         const params = swiper.params.pagination;\n//         if (isPaginationDisabled()) return;\n//         const $el = swiper.pagination.$el;\n//         $el.removeClass(params.hiddenClass);\n//         $el.removeClass(params.modifierClass + params.type);\n//         $el.removeClass(params.modifierClass + swiper.params.direction);\n//         if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass)\n//           swiper.pagination.bullets.removeClass(params.bulletActiveClass);\n\n//         if (params.clickable) {\n//           $el.off('click', classesToSelector(params.bulletClass));\n//         }\n//       }\n\n//       on('init', () => {\n//         init();\n//         render();\n//         update();\n//       });\n//       on('activeIndexChange', () => {\n//         if (swiper.params.loop) {\n//           update();\n//         } else if (typeof swiper.snapIndex === 'undefined') {\n//           update();\n//         }\n//       });\n//       on('snapIndexChange', () => {\n//         if (!swiper.params.loop) {\n//           update();\n//         }\n//       });\n//       on('slidesLengthChange', () => {\n//         if (swiper.params.loop) {\n//           render();\n//           update();\n//         }\n//       });\n//       on('snapGridLengthChange', () => {\n//         if (!swiper.params.loop) {\n//           render();\n//           update();\n//         }\n//       });\n//       on('destroy', () => {\n//         destroy();\n//       });\n//       on('enable disable', () => {\n//         const {$el} = swiper.pagination;\n\n//         if ($el) {\n//           $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);\n//         }\n//       });\n//       on('lock unlock', () => {\n//         update();\n//       });\n//       on('click', (_s, e) => {\n//         const targetEl = e.target;\n//         const {$el} = swiper.pagination;\n\n//         if (\n//           swiper.params.pagination.el &&\n//           swiper.params.pagination.hideOnClick &&\n//           $el.length > 0 &&\n//           !$(targetEl).hasClass(swiper.params.pagination.bulletClass)\n//         ) {\n//           if (\n//             swiper.navigation &&\n//             ((swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) ||\n//               (swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))\n//           )\n//             return;\n//           const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);\n\n//           if (isHidden === true) {\n//             emit('paginationShow');\n//           } else {\n//             emit('paginationHide');\n//           }\n\n//           $el.toggleClass(swiper.params.pagination.hiddenClass);\n//         }\n//       });\n//       Object.assign(swiper.pagination, {\n//         render,\n//         update,\n//         init,\n//         destroy,\n//       });\n//     }\n\n//     function Scrollbar({swiper, extendParams, on, emit}) {\n//       const document = getDocument();\n//       let isTouched = false;\n//       let timeout = null;\n//       let dragTimeout = null;\n//       let dragStartPos;\n//       let dragSize;\n//       let trackSize;\n//       let divider;\n//       extendParams({\n//         scrollbar: {\n//           el: null,\n//           dragSize: 'auto',\n//           hide: false,\n//           draggable: false,\n//           snapOnRelease: true,\n//           lockClass: 'swiper-scrollbar-lock',\n//           dragClass: 'swiper-scrollbar-drag',\n//         },\n//       });\n//       swiper.scrollbar = {\n//         el: null,\n//         dragEl: null,\n//         $el: null,\n//         $dragEl: null,\n//       };\n\n//       function setTranslate() {\n//         if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n//         const {scrollbar, rtlTranslate: rtl, progress} = swiper;\n//         const {$dragEl, $el} = scrollbar;\n//         const params = swiper.params.scrollbar;\n//         let newSize = dragSize;\n//         let newPos = (trackSize - dragSize) * progress;\n\n//         if (rtl) {\n//           newPos = -newPos;\n\n//           if (newPos > 0) {\n//             newSize = dragSize - newPos;\n//             newPos = 0;\n//           } else if (-newPos + dragSize > trackSize) {\n//             newSize = trackSize + newPos;\n//           }\n//         } else if (newPos < 0) {\n//           newSize = dragSize + newPos;\n//           newPos = 0;\n//         } else if (newPos + dragSize > trackSize) {\n//           newSize = trackSize - newPos;\n//         }\n\n//         if (swiper.isHorizontal()) {\n//           $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);\n//           $dragEl[0].style.width = `${newSize}px`;\n//         } else {\n//           $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);\n//           $dragEl[0].style.height = `${newSize}px`;\n//         }\n\n//         if (params.hide) {\n//           clearTimeout(timeout);\n//           $el[0].style.opacity = 1;\n//           timeout = setTimeout(() => {\n//             $el[0].style.opacity = 0;\n//             $el.transition(400);\n//           }, 1000);\n//         }\n//       }\n\n//       function setTransition(duration) {\n//         if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n//         swiper.scrollbar.$dragEl.transition(duration);\n//       }\n\n//       function updateSize() {\n//         if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n//         const {scrollbar} = swiper;\n//         const {$dragEl, $el} = scrollbar;\n//         $dragEl[0].style.width = '';\n//         $dragEl[0].style.height = '';\n//         trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;\n//         divider =\n//           swiper.size /\n//           (swiper.virtualSize +\n//             swiper.params.slidesOffsetBefore -\n//             (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n\n//         if (swiper.params.scrollbar.dragSize === 'auto') {\n//           dragSize = trackSize * divider;\n//         } else {\n//           dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n//         }\n\n//         if (swiper.isHorizontal()) {\n//           $dragEl[0].style.width = `${dragSize}px`;\n//         } else {\n//           $dragEl[0].style.height = `${dragSize}px`;\n//         }\n\n//         if (divider >= 1) {\n//           $el[0].style.display = 'none';\n//         } else {\n//           $el[0].style.display = '';\n//         }\n\n//         if (swiper.params.scrollbar.hide) {\n//           $el[0].style.opacity = 0;\n//         }\n\n//         if (swiper.params.watchOverflow && swiper.enabled) {\n//           scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);\n//         }\n//       }\n\n//       function getPointerPosition(e) {\n//         if (swiper.isHorizontal()) {\n//           return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;\n//         }\n\n//         return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;\n//       }\n\n//       function setDragPosition(e) {\n//         const {scrollbar, rtlTranslate: rtl} = swiper;\n//         const {$el} = scrollbar;\n//         let positionRatio;\n//         positionRatio =\n//           (getPointerPosition(e) -\n//             $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] -\n//             (dragStartPos !== null ? dragStartPos : dragSize / 2)) /\n//           (trackSize - dragSize);\n//         positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n\n//         if (rtl) {\n//           positionRatio = 1 - positionRatio;\n//         }\n\n//         const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n//         swiper.updateProgress(position);\n//         swiper.setTranslate(position);\n//         swiper.updateActiveIndex();\n//         swiper.updateSlidesClasses();\n//       }\n\n//       function onDragStart(e) {\n//         const params = swiper.params.scrollbar;\n//         const {scrollbar, $wrapperEl} = swiper;\n//         const {$el, $dragEl} = scrollbar;\n//         isTouched = true;\n//         dragStartPos =\n//           e.target === $dragEl[0] || e.target === $dragEl\n//             ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top']\n//             : null;\n//         e.preventDefault();\n//         e.stopPropagation();\n//         $wrapperEl.transition(100);\n//         $dragEl.transition(100);\n//         setDragPosition(e);\n//         clearTimeout(dragTimeout);\n//         $el.transition(0);\n\n//         if (params.hide) {\n//           $el.css('opacity', 1);\n//         }\n\n//         if (swiper.params.cssMode) {\n//           swiper.$wrapperEl.css('scroll-snap-type', 'none');\n//         }\n\n//         emit('scrollbarDragStart', e);\n//       }\n\n//       function onDragMove(e) {\n//         const {scrollbar, $wrapperEl} = swiper;\n//         const {$el, $dragEl} = scrollbar;\n//         if (!isTouched) return;\n//         if (e.preventDefault) e.preventDefault();\n//         else e.returnValue = false;\n//         setDragPosition(e);\n//         $wrapperEl.transition(0);\n//         $el.transition(0);\n//         $dragEl.transition(0);\n//         emit('scrollbarDragMove', e);\n//       }\n\n//       function onDragEnd(e) {\n//         const params = swiper.params.scrollbar;\n//         const {scrollbar, $wrapperEl} = swiper;\n//         const {$el} = scrollbar;\n//         if (!isTouched) return;\n//         isTouched = false;\n\n//         if (swiper.params.cssMode) {\n//           swiper.$wrapperEl.css('scroll-snap-type', '');\n//           $wrapperEl.transition('');\n//         }\n\n//         if (params.hide) {\n//           clearTimeout(dragTimeout);\n//           dragTimeout = nextTick(() => {\n//             $el.css('opacity', 0);\n//             $el.transition(400);\n//           }, 1000);\n//         }\n\n//         emit('scrollbarDragEnd', e);\n\n//         if (params.snapOnRelease) {\n//           swiper.slideToClosest();\n//         }\n//       }\n\n//       function events(method) {\n//         const {scrollbar, touchEventsTouch, touchEventsDesktop, params, support} = swiper;\n//         const $el = scrollbar.$el;\n//         const target = $el[0];\n//         const activeListener =\n//           support.passiveListener && params.passiveListeners\n//             ? {\n//                 passive: false,\n//                 capture: false,\n//               }\n//             : false;\n//         const passiveListener =\n//           support.passiveListener && params.passiveListeners\n//             ? {\n//                 passive: true,\n//                 capture: false,\n//               }\n//             : false;\n//         if (!target) return;\n//         const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n\n//         if (!support.touch) {\n//           target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);\n//           document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);\n//           document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);\n//         } else {\n//           target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);\n//           target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);\n//           target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);\n//         }\n//       }\n\n//       function enableDraggable() {\n//         if (!swiper.params.scrollbar.el) return;\n//         events('on');\n//       }\n\n//       function disableDraggable() {\n//         if (!swiper.params.scrollbar.el) return;\n//         events('off');\n//       }\n\n//       function init() {\n//         const {scrollbar, $el: $swiperEl} = swiper;\n//         swiper.params.scrollbar = createElementIfNotDefined(\n//           swiper,\n//           swiper.originalParams.scrollbar,\n//           swiper.params.scrollbar,\n//           {\n//             el: 'swiper-scrollbar',\n//           },\n//         );\n//         const params = swiper.params.scrollbar;\n//         if (!params.el) return;\n//         let $el = $(params.el);\n\n//         if (\n//           swiper.params.uniqueNavElements &&\n//           typeof params.el === 'string' &&\n//           $el.length > 1 &&\n//           $swiperEl.find(params.el).length === 1\n//         ) {\n//           $el = $swiperEl.find(params.el);\n//         }\n\n//         let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);\n\n//         if ($dragEl.length === 0) {\n//           $dragEl = $(`<div class=\"${swiper.params.scrollbar.dragClass}\"></div>`);\n//           $el.append($dragEl);\n//         }\n\n//         Object.assign(scrollbar, {\n//           $el,\n//           el: $el[0],\n//           $dragEl,\n//           dragEl: $dragEl[0],\n//         });\n\n//         if (params.draggable) {\n//           enableDraggable();\n//         }\n\n//         if ($el) {\n//           $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);\n//         }\n//       }\n\n//       function destroy() {\n//         disableDraggable();\n//       }\n\n//       on('init', () => {\n//         init();\n//         updateSize();\n//         setTranslate();\n//       });\n//       on('update resize observerUpdate lock unlock', () => {\n//         updateSize();\n//       });\n//       on('setTranslate', () => {\n//         setTranslate();\n//       });\n//       on('setTransition', (_s, duration) => {\n//         setTransition(duration);\n//       });\n//       on('enable disable', () => {\n//         const {$el} = swiper.scrollbar;\n\n//         if ($el) {\n//           $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);\n//         }\n//       });\n//       on('destroy', () => {\n//         destroy();\n//       });\n//       Object.assign(swiper.scrollbar, {\n//         updateSize,\n//         setTranslate,\n//         init,\n//         destroy,\n//       });\n//     }\n\n//     function Parallax({swiper, extendParams, on}) {\n//       extendParams({\n//         parallax: {\n//           enabled: false,\n//         },\n//       });\n\n//       const setTransform = (el, progress) => {\n//         const {rtl} = swiper;\n//         const $el = $(el);\n//         const rtlFactor = rtl ? -1 : 1;\n//         const p = $el.attr('data-swiper-parallax') || '0';\n//         let x = $el.attr('data-swiper-parallax-x');\n//         let y = $el.attr('data-swiper-parallax-y');\n//         const scale = $el.attr('data-swiper-parallax-scale');\n//         const opacity = $el.attr('data-swiper-parallax-opacity');\n\n//         if (x || y) {\n//           x = x || '0';\n//           y = y || '0';\n//         } else if (swiper.isHorizontal()) {\n//           x = p;\n//           y = '0';\n//         } else {\n//           y = p;\n//           x = '0';\n//         }\n\n//         if (x.indexOf('%') >= 0) {\n//           x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n//         } else {\n//           x = `${x * progress * rtlFactor}px`;\n//         }\n\n//         if (y.indexOf('%') >= 0) {\n//           y = `${parseInt(y, 10) * progress}%`;\n//         } else {\n//           y = `${y * progress}px`;\n//         }\n\n//         if (typeof opacity !== 'undefined' && opacity !== null) {\n//           const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n//           $el[0].style.opacity = currentOpacity;\n//         }\n\n//         if (typeof scale === 'undefined' || scale === null) {\n//           $el.transform(`translate3d(${x}, ${y}, 0px)`);\n//         } else {\n//           const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n//           $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);\n//         }\n//       };\n\n//       const setTranslate = () => {\n//         const {$el, slides, progress, snapGrid} = swiper;\n//         $el\n//           .children(\n//             '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',\n//           )\n//           .each((el) => {\n//             setTransform(el, progress);\n//           });\n//         slides.each((slideEl, slideIndex) => {\n//           let slideProgress = slideEl.progress;\n\n//           if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n//             slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n//           }\n\n//           slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n//           $(slideEl)\n//             .find(\n//               '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',\n//             )\n//             .each((el) => {\n//               setTransform(el, slideProgress);\n//             });\n//         });\n//       };\n\n//       const setTransition = (duration = swiper.params.speed) => {\n//         const {$el} = swiper;\n//         $el\n//           .find(\n//             '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',\n//           )\n//           .each((parallaxEl) => {\n//             const $parallaxEl = $(parallaxEl);\n//             let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;\n//             if (duration === 0) parallaxDuration = 0;\n//             $parallaxEl.transition(parallaxDuration);\n//           });\n//       };\n\n//       on('beforeInit', () => {\n//         if (!swiper.params.parallax.enabled) return;\n//         swiper.params.watchSlidesProgress = true;\n//         swiper.originalParams.watchSlidesProgress = true;\n//       });\n//       on('init', () => {\n//         if (!swiper.params.parallax.enabled) return;\n//         setTranslate();\n//       });\n//       on('setTranslate', () => {\n//         if (!swiper.params.parallax.enabled) return;\n//         setTranslate();\n//       });\n//       on('setTransition', (_swiper, duration) => {\n//         if (!swiper.params.parallax.enabled) return;\n//         setTransition(duration);\n//       });\n//     }\n\n//     function Zoom({swiper, extendParams, on, emit}) {\n//       const window = getWindow();\n//       extendParams({\n//         zoom: {\n//           enabled: false,\n//           maxRatio: 3,\n//           minRatio: 1,\n//           toggle: true,\n//           containerClass: 'swiper-zoom-container',\n//           zoomedSlideClass: 'swiper-slide-zoomed',\n//         },\n//       });\n//       swiper.zoom = {\n//         enabled: false,\n//       };\n//       let currentScale = 1;\n//       let isScaling = false;\n//       let gesturesEnabled;\n//       let fakeGestureTouched;\n//       let fakeGestureMoved;\n//       const gesture = {\n//         $slideEl: undefined,\n//         slideWidth: undefined,\n//         slideHeight: undefined,\n//         $imageEl: undefined,\n//         $imageWrapEl: undefined,\n//         maxRatio: 3,\n//       };\n//       const image = {\n//         isTouched: undefined,\n//         isMoved: undefined,\n//         currentX: undefined,\n//         currentY: undefined,\n//         minX: undefined,\n//         minY: undefined,\n//         maxX: undefined,\n//         maxY: undefined,\n//         width: undefined,\n//         height: undefined,\n//         startX: undefined,\n//         startY: undefined,\n//         touchesStart: {},\n//         touchesCurrent: {},\n//       };\n//       const velocity = {\n//         x: undefined,\n//         y: undefined,\n//         prevPositionX: undefined,\n//         prevPositionY: undefined,\n//         prevTime: undefined,\n//       };\n//       let scale = 1;\n//       Object.defineProperty(swiper.zoom, 'scale', {\n//         get() {\n//           return scale;\n//         },\n\n//         set(value) {\n//           if (scale !== value) {\n//             const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;\n//             const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;\n//             emit('zoomChange', value, imageEl, slideEl);\n//           }\n\n//           scale = value;\n//         },\n//       });\n\n//       function getDistanceBetweenTouches(e) {\n//         if (e.targetTouches.length < 2) return 1;\n//         const x1 = e.targetTouches[0].pageX;\n//         const y1 = e.targetTouches[0].pageY;\n//         const x2 = e.targetTouches[1].pageX;\n//         const y2 = e.targetTouches[1].pageY;\n//         const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n//         return distance;\n//       } // Events\n\n//       function onGestureStart(e) {\n//         const support = swiper.support;\n//         const params = swiper.params.zoom;\n//         fakeGestureTouched = false;\n//         fakeGestureMoved = false;\n\n//         if (!support.gestures) {\n//           if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {\n//             return;\n//           }\n\n//           fakeGestureTouched = true;\n//           gesture.scaleStart = getDistanceBetweenTouches(e);\n//         }\n\n//         if (!gesture.$slideEl || !gesture.$slideEl.length) {\n//           gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);\n//           if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n//           gesture.$imageEl = gesture.$slideEl\n//             .find(`.${params.containerClass}`)\n//             .eq(0)\n//             .find('picture, img, svg, canvas, .swiper-zoom-target')\n//             .eq(0);\n//           gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n//           gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n\n//           if (gesture.$imageWrapEl.length === 0) {\n//             gesture.$imageEl = undefined;\n//             return;\n//           }\n//         }\n\n//         if (gesture.$imageEl) {\n//           gesture.$imageEl.transition(0);\n//         }\n\n//         isScaling = true;\n//       }\n\n//       function onGestureChange(e) {\n//         const support = swiper.support;\n//         const params = swiper.params.zoom;\n//         const zoom = swiper.zoom;\n\n//         if (!support.gestures) {\n//           if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {\n//             return;\n//           }\n\n//           fakeGestureMoved = true;\n//           gesture.scaleMove = getDistanceBetweenTouches(e);\n//         }\n\n//         if (!gesture.$imageEl || gesture.$imageEl.length === 0) {\n//           if (e.type === 'gesturechange') onGestureStart(e);\n//           return;\n//         }\n\n//         if (support.gestures) {\n//           zoom.scale = e.scale * currentScale;\n//         } else {\n//           zoom.scale = (gesture.scaleMove / gesture.scaleStart) * currentScale;\n//         }\n\n//         if (zoom.scale > gesture.maxRatio) {\n//           zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n//         }\n\n//         if (zoom.scale < params.minRatio) {\n//           zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n//         }\n\n//         gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n//       }\n\n//       function onGestureEnd(e) {\n//         const device = swiper.device;\n//         const support = swiper.support;\n//         const params = swiper.params.zoom;\n//         const zoom = swiper.zoom;\n\n//         if (!support.gestures) {\n//           if (!fakeGestureTouched || !fakeGestureMoved) {\n//             return;\n//           }\n\n//           if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !device.android)) {\n//             return;\n//           }\n\n//           fakeGestureTouched = false;\n//           fakeGestureMoved = false;\n//         }\n\n//         if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n//         zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n//         gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n//         currentScale = zoom.scale;\n//         isScaling = false;\n//         if (zoom.scale === 1) gesture.$slideEl = undefined;\n//       }\n\n//       function onTouchStart(e) {\n//         const device = swiper.device;\n//         if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n//         if (image.isTouched) return;\n//         if (device.android && e.cancelable) e.preventDefault();\n//         image.isTouched = true;\n//         image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n//         image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n//       }\n\n//       function onTouchMove(e) {\n//         const zoom = swiper.zoom;\n//         if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n//         swiper.allowClick = false;\n//         if (!image.isTouched || !gesture.$slideEl) return;\n\n//         if (!image.isMoved) {\n//           image.width = gesture.$imageEl[0].offsetWidth;\n//           image.height = gesture.$imageEl[0].offsetHeight;\n//           image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;\n//           image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;\n//           gesture.slideWidth = gesture.$slideEl[0].offsetWidth;\n//           gesture.slideHeight = gesture.$slideEl[0].offsetHeight;\n//           gesture.$imageWrapEl.transition(0);\n//         } // Define if we need image drag\n\n//         const scaledWidth = image.width * zoom.scale;\n//         const scaledHeight = image.height * zoom.scale;\n//         if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n//         image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n//         image.maxX = -image.minX;\n//         image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n//         image.maxY = -image.minY;\n//         image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\n//         image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\n\n//         if (!image.isMoved && !isScaling) {\n//           if (\n//             swiper.isHorizontal() &&\n//             ((Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x) ||\n//               (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x))\n//           ) {\n//             image.isTouched = false;\n//             return;\n//           }\n\n//           if (\n//             !swiper.isHorizontal() &&\n//             ((Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y) ||\n//               (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y))\n//           ) {\n//             image.isTouched = false;\n//             return;\n//           }\n//         }\n\n//         if (e.cancelable) {\n//           e.preventDefault();\n//         }\n\n//         e.stopPropagation();\n//         image.isMoved = true;\n//         image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;\n//         image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;\n\n//         if (image.currentX < image.minX) {\n//           image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n//         }\n\n//         if (image.currentX > image.maxX) {\n//           image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n//         }\n\n//         if (image.currentY < image.minY) {\n//           image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n//         }\n\n//         if (image.currentY > image.maxY) {\n//           image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n//         } // Velocity\n\n//         if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n//         if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n//         if (!velocity.prevTime) velocity.prevTime = Date.now();\n//         velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n//         velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n//         if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n//         if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n//         velocity.prevPositionX = image.touchesCurrent.x;\n//         velocity.prevPositionY = image.touchesCurrent.y;\n//         velocity.prevTime = Date.now();\n//         gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);\n//       }\n\n//       function onTouchEnd() {\n//         const zoom = swiper.zoom;\n//         if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n\n//         if (!image.isTouched || !image.isMoved) {\n//           image.isTouched = false;\n//           image.isMoved = false;\n//           return;\n//         }\n\n//         image.isTouched = false;\n//         image.isMoved = false;\n//         let momentumDurationX = 300;\n//         let momentumDurationY = 300;\n//         const momentumDistanceX = velocity.x * momentumDurationX;\n//         const newPositionX = image.currentX + momentumDistanceX;\n//         const momentumDistanceY = velocity.y * momentumDurationY;\n//         const newPositionY = image.currentY + momentumDistanceY; // Fix duration\n\n//         if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n//         if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n//         const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n//         image.currentX = newPositionX;\n//         image.currentY = newPositionY; // Define if we need image drag\n\n//         const scaledWidth = image.width * zoom.scale;\n//         const scaledHeight = image.height * zoom.scale;\n//         image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n//         image.maxX = -image.minX;\n//         image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n//         image.maxY = -image.minY;\n//         image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n//         image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n//         gesture.$imageWrapEl\n//           .transition(momentumDuration)\n//           .transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);\n//       }\n\n//       function onTransitionEnd() {\n//         const zoom = swiper.zoom;\n\n//         if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {\n//           if (gesture.$imageEl) {\n//             gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');\n//           }\n\n//           if (gesture.$imageWrapEl) {\n//             gesture.$imageWrapEl.transform('translate3d(0,0,0)');\n//           }\n\n//           zoom.scale = 1;\n//           currentScale = 1;\n//           gesture.$slideEl = undefined;\n//           gesture.$imageEl = undefined;\n//           gesture.$imageWrapEl = undefined;\n//         }\n//       }\n\n//       function zoomIn(e) {\n//         const zoom = swiper.zoom;\n//         const params = swiper.params.zoom;\n\n//         if (!gesture.$slideEl) {\n//           if (e && e.target) {\n//             gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);\n//           }\n\n//           if (!gesture.$slideEl) {\n//             if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n//               gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);\n//             } else {\n//               gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n//             }\n//           }\n\n//           gesture.$imageEl = gesture.$slideEl\n//             .find(`.${params.containerClass}`)\n//             .eq(0)\n//             .find('picture, img, svg, canvas, .swiper-zoom-target')\n//             .eq(0);\n//           gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n//         }\n\n//         if (\n//           !gesture.$imageEl ||\n//           gesture.$imageEl.length === 0 ||\n//           !gesture.$imageWrapEl ||\n//           gesture.$imageWrapEl.length === 0\n//         )\n//           return;\n\n//         if (swiper.params.cssMode) {\n//           swiper.wrapperEl.style.overflow = 'hidden';\n//           swiper.wrapperEl.style.touchAction = 'none';\n//         }\n\n//         gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);\n//         let touchX;\n//         let touchY;\n//         let offsetX;\n//         let offsetY;\n//         let diffX;\n//         let diffY;\n//         let translateX;\n//         let translateY;\n//         let imageWidth;\n//         let imageHeight;\n//         let scaledWidth;\n//         let scaledHeight;\n//         let translateMinX;\n//         let translateMinY;\n//         let translateMaxX;\n//         let translateMaxY;\n//         let slideWidth;\n//         let slideHeight;\n\n//         if (typeof image.touchesStart.x === 'undefined' && e) {\n//           touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;\n//           touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;\n//         } else {\n//           touchX = image.touchesStart.x;\n//           touchY = image.touchesStart.y;\n//         }\n\n//         zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n//         currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n\n//         if (e) {\n//           slideWidth = gesture.$slideEl[0].offsetWidth;\n//           slideHeight = gesture.$slideEl[0].offsetHeight;\n//           offsetX = gesture.$slideEl.offset().left + window.scrollX;\n//           offsetY = gesture.$slideEl.offset().top + window.scrollY;\n//           diffX = offsetX + slideWidth / 2 - touchX;\n//           diffY = offsetY + slideHeight / 2 - touchY;\n//           imageWidth = gesture.$imageEl[0].offsetWidth;\n//           imageHeight = gesture.$imageEl[0].offsetHeight;\n//           scaledWidth = imageWidth * zoom.scale;\n//           scaledHeight = imageHeight * zoom.scale;\n//           translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n//           translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n//           translateMaxX = -translateMinX;\n//           translateMaxY = -translateMinY;\n//           translateX = diffX * zoom.scale;\n//           translateY = diffY * zoom.scale;\n\n//           if (translateX < translateMinX) {\n//             translateX = translateMinX;\n//           }\n\n//           if (translateX > translateMaxX) {\n//             translateX = translateMaxX;\n//           }\n\n//           if (translateY < translateMinY) {\n//             translateY = translateMinY;\n//           }\n\n//           if (translateY > translateMaxY) {\n//             translateY = translateMaxY;\n//           }\n//         } else {\n//           translateX = 0;\n//           translateY = 0;\n//         }\n\n//         gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);\n//         gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n//       }\n\n//       function zoomOut() {\n//         const zoom = swiper.zoom;\n//         const params = swiper.params.zoom;\n\n//         if (!gesture.$slideEl) {\n//           if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n//             gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);\n//           } else {\n//             gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n//           }\n\n//           gesture.$imageEl = gesture.$slideEl\n//             .find(`.${params.containerClass}`)\n//             .eq(0)\n//             .find('picture, img, svg, canvas, .swiper-zoom-target')\n//             .eq(0);\n//           gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n//         }\n\n//         if (\n//           !gesture.$imageEl ||\n//           gesture.$imageEl.length === 0 ||\n//           !gesture.$imageWrapEl ||\n//           gesture.$imageWrapEl.length === 0\n//         )\n//           return;\n\n//         if (swiper.params.cssMode) {\n//           swiper.wrapperEl.style.overflow = '';\n//           swiper.wrapperEl.style.touchAction = '';\n//         }\n\n//         zoom.scale = 1;\n//         currentScale = 1;\n//         gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');\n//         gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');\n//         gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);\n//         gesture.$slideEl = undefined;\n//       } // Toggle Zoom\n\n//       function zoomToggle(e) {\n//         const zoom = swiper.zoom;\n\n//         if (zoom.scale && zoom.scale !== 1) {\n//           // Zoom Out\n//           zoomOut();\n//         } else {\n//           // Zoom In\n//           zoomIn(e);\n//         }\n//       }\n\n//       function getListeners() {\n//         const support = swiper.support;\n//         const passiveListener =\n//           swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners\n//             ? {\n//                 passive: true,\n//                 capture: false,\n//               }\n//             : false;\n//         const activeListenerWithCapture = support.passiveListener\n//           ? {\n//               passive: false,\n//               capture: true,\n//             }\n//           : true;\n//         return {\n//           passiveListener,\n//           activeListenerWithCapture,\n//         };\n//       }\n\n//       function getSlideSelector() {\n//         return `.${swiper.params.slideClass}`;\n//       }\n\n//       function toggleGestures(method) {\n//         const {passiveListener} = getListeners();\n//         const slideSelector = getSlideSelector();\n//         swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);\n//         swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);\n//         swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);\n//       }\n\n//       function enableGestures() {\n//         if (gesturesEnabled) return;\n//         gesturesEnabled = true;\n//         toggleGestures('on');\n//       }\n\n//       function disableGestures() {\n//         if (!gesturesEnabled) return;\n//         gesturesEnabled = false;\n//         toggleGestures('off');\n//       } // Attach/Detach Events\n\n//       function enable() {\n//         const zoom = swiper.zoom;\n//         if (zoom.enabled) return;\n//         zoom.enabled = true;\n//         const support = swiper.support;\n//         const {passiveListener, activeListenerWithCapture} = getListeners();\n//         const slideSelector = getSlideSelector(); // Scale image\n\n//         if (support.gestures) {\n//           swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);\n//           swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);\n//         } else if (swiper.touchEvents.start === 'touchstart') {\n//           swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);\n//           swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);\n//           swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);\n\n//           if (swiper.touchEvents.cancel) {\n//             swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);\n//           }\n//         } // Move image\n\n//         swiper.$wrapperEl.on(\n//           swiper.touchEvents.move,\n//           `.${swiper.params.zoom.containerClass}`,\n//           onTouchMove,\n//           activeListenerWithCapture,\n//         );\n//       }\n\n//       function disable() {\n//         const zoom = swiper.zoom;\n//         if (!zoom.enabled) return;\n//         const support = swiper.support;\n//         zoom.enabled = false;\n//         const {passiveListener, activeListenerWithCapture} = getListeners();\n//         const slideSelector = getSlideSelector(); // Scale image\n\n//         if (support.gestures) {\n//           swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);\n//           swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);\n//         } else if (swiper.touchEvents.start === 'touchstart') {\n//           swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);\n//           swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);\n//           swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);\n\n//           if (swiper.touchEvents.cancel) {\n//             swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);\n//           }\n//         } // Move image\n\n//         swiper.$wrapperEl.off(\n//           swiper.touchEvents.move,\n//           `.${swiper.params.zoom.containerClass}`,\n//           onTouchMove,\n//           activeListenerWithCapture,\n//         );\n//       }\n\n//       on('init', () => {\n//         if (swiper.params.zoom.enabled) {\n//           enable();\n//         }\n//       });\n//       on('destroy', () => {\n//         disable();\n//       });\n//       on('touchStart', (_s, e) => {\n//         if (!swiper.zoom.enabled) return;\n//         onTouchStart(e);\n//       });\n//       on('touchEnd', (_s, e) => {\n//         if (!swiper.zoom.enabled) return;\n//         onTouchEnd();\n//       });\n//       on('doubleTap', (_s, e) => {\n//         if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n//           zoomToggle(e);\n//         }\n//       });\n//       on('transitionEnd', () => {\n//         if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n//           onTransitionEnd();\n//         }\n//       });\n//       on('slideChange', () => {\n//         if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n//           onTransitionEnd();\n//         }\n//       });\n//       Object.assign(swiper.zoom, {\n//         enable,\n//         disable,\n//         in: zoomIn,\n//         out: zoomOut,\n//         toggle: zoomToggle,\n//       });\n//     }\n\n//     function Lazy({swiper, extendParams, on, emit}) {\n//       extendParams({\n//         lazy: {\n//           checkInView: false,\n//           enabled: false,\n//           loadPrevNext: false,\n//           loadPrevNextAmount: 1,\n//           loadOnTransitionStart: false,\n//           scrollingElement: '',\n//           elementClass: 'swiper-lazy',\n//           loadingClass: 'swiper-lazy-loading',\n//           loadedClass: 'swiper-lazy-loaded',\n//           preloaderClass: 'swiper-lazy-preloader',\n//         },\n//       });\n//       swiper.lazy = {};\n//       let scrollHandlerAttached = false;\n//       let initialImageLoaded = false;\n\n//       function loadInSlide(index, loadInDuplicate = true) {\n//         const params = swiper.params.lazy;\n//         if (typeof index === 'undefined') return;\n//         if (swiper.slides.length === 0) return;\n//         const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n//         const $slideEl = isVirtual\n//           ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${index}\"]`)\n//           : swiper.slides.eq(index);\n//         const $images = $slideEl.find(\n//           `.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`,\n//         );\n\n//         if (\n//           $slideEl.hasClass(params.elementClass) &&\n//           !$slideEl.hasClass(params.loadedClass) &&\n//           !$slideEl.hasClass(params.loadingClass)\n//         ) {\n//           $images.push($slideEl[0]);\n//         }\n\n//         if ($images.length === 0) return;\n//         $images.each((imageEl) => {\n//           const $imageEl = $(imageEl);\n//           $imageEl.addClass(params.loadingClass);\n//           const background = $imageEl.attr('data-background');\n//           const src = $imageEl.attr('data-src');\n//           const srcset = $imageEl.attr('data-srcset');\n//           const sizes = $imageEl.attr('data-sizes');\n//           const $pictureEl = $imageEl.parent('picture');\n//           swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {\n//             if (\n//               typeof swiper === 'undefined' ||\n//               swiper === null ||\n//               !swiper ||\n//               (swiper && !swiper.params) ||\n//               swiper.destroyed\n//             )\n//               return;\n\n//             if (background) {\n//               $imageEl.css('background-image', `url(\"${background}\")`);\n//               $imageEl.removeAttr('data-background');\n//             } else {\n//               if (srcset) {\n//                 $imageEl.attr('srcset', srcset);\n//                 $imageEl.removeAttr('data-srcset');\n//               }\n\n//               if (sizes) {\n//                 $imageEl.attr('sizes', sizes);\n//                 $imageEl.removeAttr('data-sizes');\n//               }\n\n//               if ($pictureEl.length) {\n//                 $pictureEl.children('source').each((sourceEl) => {\n//                   const $source = $(sourceEl);\n\n//                   if ($source.attr('data-srcset')) {\n//                     $source.attr('srcset', $source.attr('data-srcset'));\n//                     $source.removeAttr('data-srcset');\n//                   }\n//                 });\n//               }\n\n//               if (src) {\n//                 $imageEl.attr('src', src);\n//                 $imageEl.removeAttr('data-src');\n//               }\n//             }\n\n//             $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);\n//             $slideEl.find(`.${params.preloaderClass}`).remove();\n\n//             if (swiper.params.loop && loadInDuplicate) {\n//               const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');\n\n//               if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {\n//                 const originalSlide = swiper.$wrapperEl.children(\n//                   `[data-swiper-slide-index=\"${slideOriginalIndex}\"]:not(.${swiper.params.slideDuplicateClass})`,\n//                 );\n//                 loadInSlide(originalSlide.index(), false);\n//               } else {\n//                 const duplicatedSlide = swiper.$wrapperEl.children(\n//                   `.${swiper.params.slideDuplicateClass}[data-swiper-slide-index=\"${slideOriginalIndex}\"]`,\n//                 );\n//                 loadInSlide(duplicatedSlide.index(), false);\n//               }\n//             }\n\n//             emit('lazyImageReady', $slideEl[0], $imageEl[0]);\n\n//             if (swiper.params.autoHeight) {\n//               swiper.updateAutoHeight();\n//             }\n//           });\n//           emit('lazyImageLoad', $slideEl[0], $imageEl[0]);\n//         });\n//       }\n\n//       function load() {\n//         const {$wrapperEl, params: swiperParams, slides, activeIndex} = swiper;\n//         const isVirtual = swiper.virtual && swiperParams.virtual.enabled;\n//         const params = swiperParams.lazy;\n//         let slidesPerView = swiperParams.slidesPerView;\n\n//         if (slidesPerView === 'auto') {\n//           slidesPerView = 0;\n//         }\n\n//         function slideExist(index) {\n//           if (isVirtual) {\n//             if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index=\"${index}\"]`).length) {\n//               return true;\n//             }\n//           } else if (slides[index]) return true;\n\n//           return false;\n//         }\n\n//         function slideIndex(slideEl) {\n//           if (isVirtual) {\n//             return $(slideEl).attr('data-swiper-slide-index');\n//           }\n\n//           return $(slideEl).index();\n//         }\n\n//         if (!initialImageLoaded) initialImageLoaded = true;\n\n//         if (swiper.params.watchSlidesProgress) {\n//           $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((slideEl) => {\n//             const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();\n//             loadInSlide(index);\n//           });\n//         } else if (slidesPerView > 1) {\n//           for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {\n//             if (slideExist(i)) loadInSlide(i);\n//           }\n//         } else {\n//           loadInSlide(activeIndex);\n//         }\n\n//         if (params.loadPrevNext) {\n//           if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {\n//             const amount = params.loadPrevNextAmount;\n//             const spv = slidesPerView;\n//             const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);\n//             const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides\n\n//             for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {\n//               if (slideExist(i)) loadInSlide(i);\n//             } // Prev Slides\n\n//             for (let i = minIndex; i < activeIndex; i += 1) {\n//               if (slideExist(i)) loadInSlide(i);\n//             }\n//           } else {\n//             const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);\n//             if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));\n//             const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);\n//             if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));\n//           }\n//         }\n//       }\n\n//       function checkInViewOnLoad() {\n//         const window = getWindow();\n//         if (!swiper || swiper.destroyed) return;\n//         const $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window);\n//         const isWindow = $scrollElement[0] === window;\n//         const scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;\n//         const scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;\n//         const swiperOffset = swiper.$el.offset();\n//         const {rtlTranslate: rtl} = swiper;\n//         let inView = false;\n//         if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;\n//         const swiperCoord = [\n//           [swiperOffset.left, swiperOffset.top],\n//           [swiperOffset.left + swiper.width, swiperOffset.top],\n//           [swiperOffset.left, swiperOffset.top + swiper.height],\n//           [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],\n//         ];\n\n//         for (let i = 0; i < swiperCoord.length; i += 1) {\n//           const point = swiperCoord[i];\n\n//           if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {\n//             if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n\n//             inView = true;\n//           }\n//         }\n\n//         const passiveListener =\n//           swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners\n//             ? {\n//                 passive: true,\n//                 capture: false,\n//               }\n//             : false;\n\n//         if (inView) {\n//           load();\n//           $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);\n//         } else if (!scrollHandlerAttached) {\n//           scrollHandlerAttached = true;\n//           $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);\n//         }\n//       }\n\n//       on('beforeInit', () => {\n//         if (swiper.params.lazy.enabled && swiper.params.preloadImages) {\n//           swiper.params.preloadImages = false;\n//         }\n//       });\n//       on('init', () => {\n//         if (swiper.params.lazy.enabled) {\n//           if (swiper.params.lazy.checkInView) {\n//             checkInViewOnLoad();\n//           } else {\n//             load();\n//           }\n//         }\n//       });\n//       on('scroll', () => {\n//         if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {\n//           load();\n//         }\n//       });\n//       on('scrollbarDragMove resize _freeModeNoMomentumRelease', () => {\n//         if (swiper.params.lazy.enabled) {\n//           if (swiper.params.lazy.checkInView) {\n//             checkInViewOnLoad();\n//           } else {\n//             load();\n//           }\n//         }\n//       });\n//       on('transitionStart', () => {\n//         if (swiper.params.lazy.enabled) {\n//           if (\n//             swiper.params.lazy.loadOnTransitionStart ||\n//             (!swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded)\n//           ) {\n//             if (swiper.params.lazy.checkInView) {\n//               checkInViewOnLoad();\n//             } else {\n//               load();\n//             }\n//           }\n//         }\n//       });\n//       on('transitionEnd', () => {\n//         if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {\n//           if (swiper.params.lazy.checkInView) {\n//             checkInViewOnLoad();\n//           } else {\n//             load();\n//           }\n//         }\n//       });\n//       on('slideChange', () => {\n//         const {lazy, cssMode, watchSlidesProgress, touchReleaseOnEdges, resistanceRatio} = swiper.params;\n\n//         if (lazy.enabled && (cssMode || (watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0)))) {\n//           load();\n//         }\n//       });\n//       Object.assign(swiper.lazy, {\n//         load,\n//         loadInSlide,\n//       });\n//     }\n\n//     /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n//     function Controller({swiper, extendParams, on}) {\n//       extendParams({\n//         controller: {\n//           control: undefined,\n//           inverse: false,\n//           by: 'slide', // or 'container'\n//         },\n//       });\n//       swiper.controller = {\n//         control: undefined,\n//       };\n\n//       function LinearSpline(x, y) {\n//         const binarySearch = (function search() {\n//           let maxIndex;\n//           let minIndex;\n//           let guess;\n//           return (array, val) => {\n//             minIndex = -1;\n//             maxIndex = array.length;\n\n//             while (maxIndex - minIndex > 1) {\n//               guess = (maxIndex + minIndex) >> 1;\n\n//               if (array[guess] <= val) {\n//                 minIndex = guess;\n//               } else {\n//                 maxIndex = guess;\n//               }\n//             }\n\n//             return maxIndex;\n//           };\n//         })();\n\n//         this.x = x;\n//         this.y = y;\n//         this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:\n//         // (x1,y1) is the known point before given value,\n//         // (x3,y3) is the known point after given value.\n\n//         let i1;\n//         let i3;\n\n//         this.interpolate = function interpolate(x2) {\n//           if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n\n//           i3 = binarySearch(this.x, x2);\n//           i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:\n//           // y2 := ((x2x1)  (y3y1))  (x3x1) + y1\n\n//           return ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1];\n//         };\n\n//         return this;\n//       } // xxx: for now i will just save one spline function to to\n\n//       function getInterpolateFunction(c) {\n//         if (!swiper.controller.spline) {\n//           swiper.controller.spline = swiper.params.loop\n//             ? new LinearSpline(swiper.slidesGrid, c.slidesGrid)\n//             : new LinearSpline(swiper.snapGrid, c.snapGrid);\n//         }\n//       }\n\n//       function setTranslate(_t, byController) {\n//         const controlled = swiper.controller.control;\n//         let multiplier;\n//         let controlledTranslate;\n//         const Swiper = swiper.constructor;\n\n//         function setControlledTranslate(c) {\n//           // this will create an Interpolate function based on the snapGrids\n//           // x is the Grid of the scrolled scroller and y will be the controlled scroller\n//           // it makes sense to create this only once and recall it for the interpolation\n//           // the function does a lot of value caching for performance\n//           const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n\n//           if (swiper.params.controller.by === 'slide') {\n//             getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n//             // but it did not work out\n\n//             controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n//           }\n\n//           if (!controlledTranslate || swiper.params.controller.by === 'container') {\n//             multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n//             controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n//           }\n\n//           if (swiper.params.controller.inverse) {\n//             controlledTranslate = c.maxTranslate() - controlledTranslate;\n//           }\n\n//           c.updateProgress(controlledTranslate);\n//           c.setTranslate(controlledTranslate, swiper);\n//           c.updateActiveIndex();\n//           c.updateSlidesClasses();\n//         }\n\n//         if (Array.isArray(controlled)) {\n//           for (let i = 0; i < controlled.length; i += 1) {\n//             if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n//               setControlledTranslate(controlled[i]);\n//             }\n//           }\n//         } else if (controlled instanceof Swiper && byController !== controlled) {\n//           setControlledTranslate(controlled);\n//         }\n//       }\n\n//       function setTransition(duration, byController) {\n//         const Swiper = swiper.constructor;\n//         const controlled = swiper.controller.control;\n//         let i;\n\n//         function setControlledTransition(c) {\n//           c.setTransition(duration, swiper);\n\n//           if (duration !== 0) {\n//             c.transitionStart();\n\n//             if (c.params.autoHeight) {\n//               nextTick(() => {\n//                 c.updateAutoHeight();\n//               });\n//             }\n\n//             c.$wrapperEl.transitionEnd(() => {\n//               if (!controlled) return;\n\n//               if (c.params.loop && swiper.params.controller.by === 'slide') {\n//                 c.loopFix();\n//               }\n\n//               c.transitionEnd();\n//             });\n//           }\n//         }\n\n//         if (Array.isArray(controlled)) {\n//           for (i = 0; i < controlled.length; i += 1) {\n//             if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n//               setControlledTransition(controlled[i]);\n//             }\n//           }\n//         } else if (controlled instanceof Swiper && byController !== controlled) {\n//           setControlledTransition(controlled);\n//         }\n//       }\n\n//       function removeSpline() {\n//         if (!swiper.controller.control) return;\n\n//         if (swiper.controller.spline) {\n//           swiper.controller.spline = undefined;\n//           delete swiper.controller.spline;\n//         }\n//       }\n\n//       on('beforeInit', () => {\n//         swiper.controller.control = swiper.params.controller.control;\n//       });\n//       on('update', () => {\n//         removeSpline();\n//       });\n//       on('resize', () => {\n//         removeSpline();\n//       });\n//       on('observerUpdate', () => {\n//         removeSpline();\n//       });\n//       on('setTranslate', (_s, translate, byController) => {\n//         if (!swiper.controller.control) return;\n//         swiper.controller.setTranslate(translate, byController);\n//       });\n//       on('setTransition', (_s, duration, byController) => {\n//         if (!swiper.controller.control) return;\n//         swiper.controller.setTransition(duration, byController);\n//       });\n//       Object.assign(swiper.controller, {\n//         setTranslate,\n//         setTransition,\n//       });\n//     }\n\n//     function A11y({swiper, extendParams, on}) {\n//       extendParams({\n//         a11y: {\n//           enabled: true,\n//           notificationClass: 'swiper-notification',\n//           prevSlideMessage: 'Previous slide',\n//           nextSlideMessage: 'Next slide',\n//           firstSlideMessage: 'This is the first slide',\n//           lastSlideMessage: 'This is the last slide',\n//           paginationBulletMessage: 'Go to slide {{index}}',\n//           slideLabelMessage: '{{index}} / {{slidesLength}}',\n//           containerMessage: null,\n//           containerRoleDescriptionMessage: null,\n//           itemRoleDescriptionMessage: null,\n//           slideRole: 'group',\n//         },\n//       });\n//       let liveRegion = null;\n\n//       function notify(message) {\n//         const notification = liveRegion;\n//         if (notification.length === 0) return;\n//         notification.html('');\n//         notification.html(message);\n//       }\n\n//       function getRandomNumber(size = 16) {\n//         const randomChar = () => Math.round(16 * Math.random()).toString(16);\n\n//         return 'x'.repeat(size).replace(/x/g, randomChar);\n//       }\n\n//       function makeElFocusable($el) {\n//         $el.attr('tabIndex', '0');\n//       }\n\n//       function makeElNotFocusable($el) {\n//         $el.attr('tabIndex', '-1');\n//       }\n\n//       function addElRole($el, role) {\n//         $el.attr('role', role);\n//       }\n\n//       function addElRoleDescription($el, description) {\n//         $el.attr('aria-roledescription', description);\n//       }\n\n//       function addElControls($el, controls) {\n//         $el.attr('aria-controls', controls);\n//       }\n\n//       function addElLabel($el, label) {\n//         $el.attr('aria-label', label);\n//       }\n\n//       function addElId($el, id) {\n//         $el.attr('id', id);\n//       }\n\n//       function addElLive($el, live) {\n//         $el.attr('aria-live', live);\n//       }\n\n//       function disableEl($el) {\n//         $el.attr('aria-disabled', true);\n//       }\n\n//       function enableEl($el) {\n//         $el.attr('aria-disabled', false);\n//       }\n\n//       function onEnterOrSpaceKey(e) {\n//         if (e.keyCode !== 13 && e.keyCode !== 32) return;\n//         const params = swiper.params.a11y;\n//         const $targetEl = $(e.target);\n\n//         if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {\n//           if (!(swiper.isEnd && !swiper.params.loop)) {\n//             swiper.slideNext();\n//           }\n\n//           if (swiper.isEnd) {\n//             notify(params.lastSlideMessage);\n//           } else {\n//             notify(params.nextSlideMessage);\n//           }\n//         }\n\n//         if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {\n//           if (!(swiper.isBeginning && !swiper.params.loop)) {\n//             swiper.slidePrev();\n//           }\n\n//           if (swiper.isBeginning) {\n//             notify(params.firstSlideMessage);\n//           } else {\n//             notify(params.prevSlideMessage);\n//           }\n//         }\n\n//         if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {\n//           $targetEl[0].click();\n//         }\n//       }\n\n//       function updateNavigation() {\n//         if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n//         const {$nextEl, $prevEl} = swiper.navigation;\n\n//         if ($prevEl && $prevEl.length > 0) {\n//           if (swiper.isBeginning) {\n//             disableEl($prevEl);\n//             makeElNotFocusable($prevEl);\n//           } else {\n//             enableEl($prevEl);\n//             makeElFocusable($prevEl);\n//           }\n//         }\n\n//         if ($nextEl && $nextEl.length > 0) {\n//           if (swiper.isEnd) {\n//             disableEl($nextEl);\n//             makeElNotFocusable($nextEl);\n//           } else {\n//             enableEl($nextEl);\n//             makeElFocusable($nextEl);\n//           }\n//         }\n//       }\n\n//       function hasPagination() {\n//         return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n//       }\n\n//       function hasClickablePagination() {\n//         return hasPagination() && swiper.params.pagination.clickable;\n//       }\n\n//       function updatePagination() {\n//         const params = swiper.params.a11y;\n//         if (!hasPagination()) return;\n//         swiper.pagination.bullets.each((bulletEl) => {\n//           const $bulletEl = $(bulletEl);\n\n//           if (swiper.params.pagination.clickable) {\n//             makeElFocusable($bulletEl);\n\n//             if (!swiper.params.pagination.renderBullet) {\n//               addElRole($bulletEl, 'button');\n//               addElLabel($bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, $bulletEl.index() + 1));\n//             }\n//           }\n\n//           if ($bulletEl.is(`.${swiper.params.pagination.bulletActiveClass}`)) {\n//             $bulletEl.attr('aria-current', 'true');\n//           } else {\n//             $bulletEl.removeAttr('aria-current');\n//           }\n//         });\n//       }\n\n//       const initNavEl = ($el, wrapperId, message) => {\n//         makeElFocusable($el);\n\n//         if ($el[0].tagName !== 'BUTTON') {\n//           addElRole($el, 'button');\n//           $el.on('keydown', onEnterOrSpaceKey);\n//         }\n\n//         addElLabel($el, message);\n//         addElControls($el, wrapperId);\n//       };\n\n//       function init() {\n//         const params = swiper.params.a11y;\n//         swiper.$el.append(liveRegion); // Container\n\n//         const $containerEl = swiper.$el;\n\n//         if (params.containerRoleDescriptionMessage) {\n//           addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);\n//         }\n\n//         if (params.containerMessage) {\n//           addElLabel($containerEl, params.containerMessage);\n//         } // Wrapper\n\n//         const $wrapperEl = swiper.$wrapperEl;\n//         const wrapperId = $wrapperEl.attr('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n//         const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n//         addElId($wrapperEl, wrapperId);\n//         addElLive($wrapperEl, live); // Slide\n\n//         if (params.itemRoleDescriptionMessage) {\n//           addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);\n//         }\n\n//         addElRole($(swiper.slides), params.slideRole);\n//         const slidesLength = swiper.params.loop\n//           ? swiper.slides.filter((el) => !el.classList.contains(swiper.params.slideDuplicateClass)).length\n//           : swiper.slides.length;\n//         swiper.slides.each((slideEl, index) => {\n//           const $slideEl = $(slideEl);\n//           const slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;\n//           const ariaLabelMessage = params.slideLabelMessage\n//             .replace(/\\{\\{index\\}\\}/, slideIndex + 1)\n//             .replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n//           addElLabel($slideEl, ariaLabelMessage);\n//         }); // Navigation\n\n//         let $nextEl;\n//         let $prevEl;\n\n//         if (swiper.navigation && swiper.navigation.$nextEl) {\n//           $nextEl = swiper.navigation.$nextEl;\n//         }\n\n//         if (swiper.navigation && swiper.navigation.$prevEl) {\n//           $prevEl = swiper.navigation.$prevEl;\n//         }\n\n//         if ($nextEl && $nextEl.length) {\n//           initNavEl($nextEl, wrapperId, params.nextSlideMessage);\n//         }\n\n//         if ($prevEl && $prevEl.length) {\n//           initNavEl($prevEl, wrapperId, params.prevSlideMessage);\n//         } // Pagination\n\n//         if (hasClickablePagination()) {\n//           swiper.pagination.$el.on(\n//             'keydown',\n//             classesToSelector(swiper.params.pagination.bulletClass),\n//             onEnterOrSpaceKey,\n//           );\n//         }\n//       }\n\n//       function destroy() {\n//         if (liveRegion && liveRegion.length > 0) liveRegion.remove();\n//         let $nextEl;\n//         let $prevEl;\n\n//         if (swiper.navigation && swiper.navigation.$nextEl) {\n//           $nextEl = swiper.navigation.$nextEl;\n//         }\n\n//         if (swiper.navigation && swiper.navigation.$prevEl) {\n//           $prevEl = swiper.navigation.$prevEl;\n//         }\n\n//         if ($nextEl) {\n//           $nextEl.off('keydown', onEnterOrSpaceKey);\n//         }\n\n//         if ($prevEl) {\n//           $prevEl.off('keydown', onEnterOrSpaceKey);\n//         } // Pagination\n\n//         if (hasClickablePagination()) {\n//           swiper.pagination.$el.off(\n//             'keydown',\n//             classesToSelector(swiper.params.pagination.bulletClass),\n//             onEnterOrSpaceKey,\n//           );\n//         }\n//       }\n\n//       on('beforeInit', () => {\n//         liveRegion = $(\n//           `<span class=\"${swiper.params.a11y.notificationClass}\" aria-live=\"assertive\" aria-atomic=\"true\"></span>`,\n//         );\n//       });\n//       on('afterInit', () => {\n//         if (!swiper.params.a11y.enabled) return;\n//         init();\n//         updateNavigation();\n//       });\n//       on('toEdge', () => {\n//         if (!swiper.params.a11y.enabled) return;\n//         updateNavigation();\n//       });\n//       on('fromEdge', () => {\n//         if (!swiper.params.a11y.enabled) return;\n//         updateNavigation();\n//       });\n//       on('paginationUpdate', () => {\n//         if (!swiper.params.a11y.enabled) return;\n//         updatePagination();\n//       });\n//       on('destroy', () => {\n//         if (!swiper.params.a11y.enabled) return;\n//         destroy();\n//       });\n//     }\n\n//     function History({swiper, extendParams, on}) {\n//       extendParams({\n//         history: {\n//           enabled: false,\n//           root: '',\n//           replaceState: false,\n//           key: 'slides',\n//         },\n//       });\n//       let initialized = false;\n//       let paths = {};\n\n//       const slugify = (text) => {\n//         return text\n//           .toString()\n//           .replace(/\\s+/g, '-')\n//           .replace(/[^\\w-]+/g, '')\n//           .replace(/--+/g, '-')\n//           .replace(/^-+/, '')\n//           .replace(/-+$/, '');\n//       };\n\n//       const getPathValues = (urlOverride) => {\n//         const window = getWindow();\n//         let location;\n\n//         if (urlOverride) {\n//           location = new URL(urlOverride);\n//         } else {\n//           location = window.location;\n//         }\n\n//         const pathArray = location.pathname\n//           .slice(1)\n//           .split('/')\n//           .filter((part) => part !== '');\n//         const total = pathArray.length;\n//         const key = pathArray[total - 2];\n//         const value = pathArray[total - 1];\n//         return {\n//           key,\n//           value,\n//         };\n//       };\n\n//       const setHistory = (key, index) => {\n//         const window = getWindow();\n//         if (!initialized || !swiper.params.history.enabled) return;\n//         let location;\n\n//         if (swiper.params.url) {\n//           location = new URL(swiper.params.url);\n//         } else {\n//           location = window.location;\n//         }\n\n//         const slide = swiper.slides.eq(index);\n//         let value = slugify(slide.attr('data-history'));\n\n//         if (swiper.params.history.root.length > 0) {\n//           let root = swiper.params.history.root;\n//           if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n//           value = `${root}/${key}/${value}`;\n//         } else if (!location.pathname.includes(key)) {\n//           value = `${key}/${value}`;\n//         }\n\n//         const currentState = window.history.state;\n\n//         if (currentState && currentState.value === value) {\n//           return;\n//         }\n\n//         if (swiper.params.history.replaceState) {\n//           window.history.replaceState(\n//             {\n//               value,\n//             },\n//             null,\n//             value,\n//           );\n//         } else {\n//           window.history.pushState(\n//             {\n//               value,\n//             },\n//             null,\n//             value,\n//           );\n//         }\n//       };\n\n//       const scrollToSlide = (speed, value, runCallbacks) => {\n//         if (value) {\n//           for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n//             const slide = swiper.slides.eq(i);\n//             const slideHistory = slugify(slide.attr('data-history'));\n\n//             if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n//               const index = slide.index();\n//               swiper.slideTo(index, speed, runCallbacks);\n//             }\n//           }\n//         } else {\n//           swiper.slideTo(0, speed, runCallbacks);\n//         }\n//       };\n\n//       const setHistoryPopState = () => {\n//         paths = getPathValues(swiper.params.url);\n//         scrollToSlide(swiper.params.speed, swiper.paths.value, false);\n//       };\n\n//       const init = () => {\n//         const window = getWindow();\n//         if (!swiper.params.history) return;\n\n//         if (!window.history || !window.history.pushState) {\n//           swiper.params.history.enabled = false;\n//           swiper.params.hashNavigation.enabled = true;\n//           return;\n//         }\n\n//         initialized = true;\n//         paths = getPathValues(swiper.params.url);\n//         if (!paths.key && !paths.value) return;\n//         scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n\n//         if (!swiper.params.history.replaceState) {\n//           window.addEventListener('popstate', setHistoryPopState);\n//         }\n//       };\n\n//       const destroy = () => {\n//         const window = getWindow();\n\n//         if (!swiper.params.history.replaceState) {\n//           window.removeEventListener('popstate', setHistoryPopState);\n//         }\n//       };\n\n//       on('init', () => {\n//         if (swiper.params.history.enabled) {\n//           init();\n//         }\n//       });\n//       on('destroy', () => {\n//         if (swiper.params.history.enabled) {\n//           destroy();\n//         }\n//       });\n//       on('transitionEnd _freeModeNoMomentumRelease', () => {\n//         if (initialized) {\n//           setHistory(swiper.params.history.key, swiper.activeIndex);\n//         }\n//       });\n//       on('slideChange', () => {\n//         if (initialized && swiper.params.cssMode) {\n//           setHistory(swiper.params.history.key, swiper.activeIndex);\n//         }\n//       });\n//     }\n\n//     function HashNavigation({swiper, extendParams, emit, on}) {\n//       let initialized = false;\n//       const document = getDocument();\n//       const window = getWindow();\n//       extendParams({\n//         hashNavigation: {\n//           enabled: false,\n//           replaceState: false,\n//           watchState: false,\n//         },\n//       });\n\n//       const onHashChange = () => {\n//         emit('hashChange');\n//         const newHash = document.location.hash.replace('#', '');\n//         const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');\n\n//         if (newHash !== activeSlideHash) {\n//           const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash=\"${newHash}\"]`).index();\n//           if (typeof newIndex === 'undefined') return;\n//           swiper.slideTo(newIndex);\n//         }\n//       };\n\n//       const setHash = () => {\n//         if (!initialized || !swiper.params.hashNavigation.enabled) return;\n\n//         if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\n//           window.history.replaceState(null, null, `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '');\n//           emit('hashSet');\n//         } else {\n//           const slide = swiper.slides.eq(swiper.activeIndex);\n//           const hash = slide.attr('data-hash') || slide.attr('data-history');\n//           document.location.hash = hash || '';\n//           emit('hashSet');\n//         }\n//       };\n\n//       const init = () => {\n//         if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) return;\n//         initialized = true;\n//         const hash = document.location.hash.replace('#', '');\n\n//         if (hash) {\n//           const speed = 0;\n\n//           for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n//             const slide = swiper.slides.eq(i);\n//             const slideHash = slide.attr('data-hash') || slide.attr('data-history');\n\n//             if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n//               const index = slide.index();\n//               swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);\n//             }\n//           }\n//         }\n\n//         if (swiper.params.hashNavigation.watchState) {\n//           $(window).on('hashchange', onHashChange);\n//         }\n//       };\n\n//       const destroy = () => {\n//         if (swiper.params.hashNavigation.watchState) {\n//           $(window).off('hashchange', onHashChange);\n//         }\n//       };\n\n//       on('init', () => {\n//         if (swiper.params.hashNavigation.enabled) {\n//           init();\n//         }\n//       });\n//       on('destroy', () => {\n//         if (swiper.params.hashNavigation.enabled) {\n//           destroy();\n//         }\n//       });\n//       on('transitionEnd _freeModeNoMomentumRelease', () => {\n//         if (initialized) {\n//           setHash();\n//         }\n//       });\n//       on('slideChange', () => {\n//         if (initialized && swiper.params.cssMode) {\n//           setHash();\n//         }\n//       });\n//     }\n\n//     /* eslint no-underscore-dangle: \"off\" */\n//     function Autoplay({swiper, extendParams, on, emit}) {\n//       let timeout;\n//       swiper.autoplay = {\n//         running: false,\n//         paused: false,\n//       };\n//       extendParams({\n//         autoplay: {\n//           enabled: false,\n//           delay: 3000,\n//           waitForTransition: true,\n//           disableOnInteraction: true,\n//           stopOnLastSlide: false,\n//           reverseDirection: false,\n//           pauseOnMouseEnter: false,\n//         },\n//       });\n\n//       function run() {\n//         const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);\n//         let delay = swiper.params.autoplay.delay;\n\n//         if ($activeSlideEl.attr('data-swiper-autoplay')) {\n//           delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;\n//         }\n\n//         clearTimeout(timeout);\n//         timeout = nextTick(() => {\n//           let autoplayResult;\n\n//           if (swiper.params.autoplay.reverseDirection) {\n//             if (swiper.params.loop) {\n//               swiper.loopFix();\n//               autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);\n//               emit('autoplay');\n//             } else if (!swiper.isBeginning) {\n//               autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);\n//               emit('autoplay');\n//             } else if (!swiper.params.autoplay.stopOnLastSlide) {\n//               autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);\n//               emit('autoplay');\n//             } else {\n//               stop();\n//             }\n//           } else if (swiper.params.loop) {\n//             swiper.loopFix();\n//             autoplayResult = swiper.slideNext(swiper.params.speed, true, true);\n//             emit('autoplay');\n//           } else if (!swiper.isEnd) {\n//             autoplayResult = swiper.slideNext(swiper.params.speed, true, true);\n//             emit('autoplay');\n//           } else if (!swiper.params.autoplay.stopOnLastSlide) {\n//             autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);\n//             emit('autoplay');\n//           } else {\n//             stop();\n//           }\n\n//           if (swiper.params.cssMode && swiper.autoplay.running) run();\n//           else if (autoplayResult === false) {\n//             run();\n//           }\n//         }, delay);\n//       }\n\n//       function start() {\n//         if (typeof timeout !== 'undefined') return false;\n//         if (swiper.autoplay.running) return false;\n//         swiper.autoplay.running = true;\n//         emit('autoplayStart');\n//         run();\n//         return true;\n//       }\n\n//       function stop() {\n//         if (!swiper.autoplay.running) return false;\n//         if (typeof timeout === 'undefined') return false;\n\n//         if (timeout) {\n//           clearTimeout(timeout);\n//           timeout = undefined;\n//         }\n\n//         swiper.autoplay.running = false;\n//         emit('autoplayStop');\n//         return true;\n//       }\n\n//       function pause(speed) {\n//         if (!swiper.autoplay.running) return;\n//         if (swiper.autoplay.paused) return;\n//         if (timeout) clearTimeout(timeout);\n//         swiper.autoplay.paused = true;\n\n//         if (speed === 0 || !swiper.params.autoplay.waitForTransition) {\n//           swiper.autoplay.paused = false;\n//           run();\n//         } else {\n//           ['transitionend', 'webkitTransitionEnd'].forEach((event) => {\n//             swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);\n//           });\n//         }\n//       }\n\n//       function onVisibilityChange() {\n//         const document = getDocument();\n\n//         if (document.visibilityState === 'hidden' && swiper.autoplay.running) {\n//           pause();\n//         }\n\n//         if (document.visibilityState === 'visible' && swiper.autoplay.paused) {\n//           run();\n//           swiper.autoplay.paused = false;\n//         }\n//       }\n\n//       function onTransitionEnd(e) {\n//         if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;\n//         if (e.target !== swiper.$wrapperEl[0]) return;\n//         ['transitionend', 'webkitTransitionEnd'].forEach((event) => {\n//           swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);\n//         });\n//         swiper.autoplay.paused = false;\n\n//         if (!swiper.autoplay.running) {\n//           stop();\n//         } else {\n//           run();\n//         }\n//       }\n\n//       function onMouseEnter() {\n//         if (swiper.params.autoplay.disableOnInteraction) {\n//           stop();\n//         } else {\n//           pause();\n//         }\n\n//         ['transitionend', 'webkitTransitionEnd'].forEach((event) => {\n//           swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);\n//         });\n//       }\n\n//       function onMouseLeave() {\n//         if (swiper.params.autoplay.disableOnInteraction) {\n//           return;\n//         }\n\n//         swiper.autoplay.paused = false;\n//         run();\n//       }\n\n//       function attachMouseEvents() {\n//         if (swiper.params.autoplay.pauseOnMouseEnter) {\n//           swiper.$el.on('mouseenter', onMouseEnter);\n//           swiper.$el.on('mouseleave', onMouseLeave);\n//         }\n//       }\n\n//       function detachMouseEvents() {\n//         swiper.$el.off('mouseenter', onMouseEnter);\n//         swiper.$el.off('mouseleave', onMouseLeave);\n//       }\n\n//       on('init', () => {\n//         if (swiper.params.autoplay.enabled) {\n//           start();\n//           const document = getDocument();\n//           document.addEventListener('visibilitychange', onVisibilityChange);\n//           attachMouseEvents();\n//         }\n//       });\n//       on('beforeTransitionStart', (_s, speed, internal) => {\n//         if (swiper.autoplay.running) {\n//           if (internal || !swiper.params.autoplay.disableOnInteraction) {\n//             swiper.autoplay.pause(speed);\n//           } else {\n//             stop();\n//           }\n//         }\n//       });\n//       on('sliderFirstMove', () => {\n//         if (swiper.autoplay.running) {\n//           if (swiper.params.autoplay.disableOnInteraction) {\n//             stop();\n//           } else {\n//             pause();\n//           }\n//         }\n//       });\n//       on('touchEnd', () => {\n//         if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {\n//           run();\n//         }\n//       });\n//       on('destroy', () => {\n//         detachMouseEvents();\n\n//         if (swiper.autoplay.running) {\n//           stop();\n//         }\n\n//         const document = getDocument();\n//         document.removeEventListener('visibilitychange', onVisibilityChange);\n//       });\n//       Object.assign(swiper.autoplay, {\n//         pause,\n//         run,\n//         start,\n//         stop,\n//       });\n//     }\n\n//     function Thumb({swiper, extendParams, on}) {\n//       extendParams({\n//         thumbs: {\n//           swiper: null,\n//           multipleActiveThumbs: true,\n//           autoScrollOffset: 0,\n//           slideThumbActiveClass: 'swiper-slide-thumb-active',\n//           thumbsContainerClass: 'swiper-thumbs',\n//         },\n//       });\n//       let initialized = false;\n//       let swiperCreated = false;\n//       swiper.thumbs = {\n//         swiper: null,\n//       };\n\n//       function onThumbClick() {\n//         const thumbsSwiper = swiper.thumbs.swiper;\n//         if (!thumbsSwiper) return;\n//         const clickedIndex = thumbsSwiper.clickedIndex;\n//         const clickedSlide = thumbsSwiper.clickedSlide;\n//         if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;\n//         if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n//         let slideToIndex;\n\n//         if (thumbsSwiper.params.loop) {\n//           slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n//         } else {\n//           slideToIndex = clickedIndex;\n//         }\n\n//         if (swiper.params.loop) {\n//           let currentIndex = swiper.activeIndex;\n\n//           if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {\n//             swiper.loopFix(); // eslint-disable-next-line\n\n//             swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n//             currentIndex = swiper.activeIndex;\n//           }\n\n//           const prevIndex = swiper.slides\n//             .eq(currentIndex)\n//             .prevAll(`[data-swiper-slide-index=\"${slideToIndex}\"]`)\n//             .eq(0)\n//             .index();\n//           const nextIndex = swiper.slides\n//             .eq(currentIndex)\n//             .nextAll(`[data-swiper-slide-index=\"${slideToIndex}\"]`)\n//             .eq(0)\n//             .index();\n//           if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;\n//           else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;\n//           else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;\n//           else slideToIndex = prevIndex;\n//         }\n\n//         swiper.slideTo(slideToIndex);\n//       }\n\n//       function init() {\n//         const {thumbs: thumbsParams} = swiper.params;\n//         if (initialized) return false;\n//         initialized = true;\n//         const SwiperClass = swiper.constructor;\n\n//         if (thumbsParams.swiper instanceof SwiperClass) {\n//           swiper.thumbs.swiper = thumbsParams.swiper;\n//           Object.assign(swiper.thumbs.swiper.originalParams, {\n//             watchSlidesProgress: true,\n//             slideToClickedSlide: false,\n//           });\n//           Object.assign(swiper.thumbs.swiper.params, {\n//             watchSlidesProgress: true,\n//             slideToClickedSlide: false,\n//           });\n//         } else if (isObject(thumbsParams.swiper)) {\n//           const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n//           Object.assign(thumbsSwiperParams, {\n//             watchSlidesProgress: true,\n//             slideToClickedSlide: false,\n//           });\n//           swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n//           swiperCreated = true;\n//         }\n\n//         swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);\n//         swiper.thumbs.swiper.on('tap', onThumbClick);\n//         return true;\n//       }\n\n//       function update(initial) {\n//         const thumbsSwiper = swiper.thumbs.swiper;\n//         if (!thumbsSwiper) return;\n//         const slidesPerView =\n//           thumbsSwiper.params.slidesPerView === 'auto'\n//             ? thumbsSwiper.slidesPerViewDynamic()\n//             : thumbsSwiper.params.slidesPerView;\n//         const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n//         const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n\n//         if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n//           let currentThumbsIndex = thumbsSwiper.activeIndex;\n//           let newThumbsIndex;\n//           let direction;\n\n//           if (thumbsSwiper.params.loop) {\n//             if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {\n//               thumbsSwiper.loopFix(); // eslint-disable-next-line\n\n//               thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;\n//               currentThumbsIndex = thumbsSwiper.activeIndex;\n//             } // Find actual thumbs index to slide to\n\n//             const prevThumbsIndex = thumbsSwiper.slides\n//               .eq(currentThumbsIndex)\n//               .prevAll(`[data-swiper-slide-index=\"${swiper.realIndex}\"]`)\n//               .eq(0)\n//               .index();\n//             const nextThumbsIndex = thumbsSwiper.slides\n//               .eq(currentThumbsIndex)\n//               .nextAll(`[data-swiper-slide-index=\"${swiper.realIndex}\"]`)\n//               .eq(0)\n//               .index();\n\n//             if (typeof prevThumbsIndex === 'undefined') {\n//               newThumbsIndex = nextThumbsIndex;\n//             } else if (typeof nextThumbsIndex === 'undefined') {\n//               newThumbsIndex = prevThumbsIndex;\n//             } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {\n//               newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;\n//             } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {\n//               newThumbsIndex = nextThumbsIndex;\n//             } else {\n//               newThumbsIndex = prevThumbsIndex;\n//             }\n\n//             direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n//           } else {\n//             newThumbsIndex = swiper.realIndex;\n//             direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n//           }\n\n//           if (useOffset) {\n//             newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n//           }\n\n//           if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n//             if (thumbsSwiper.params.centeredSlides) {\n//               if (newThumbsIndex > currentThumbsIndex) {\n//                 newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n//               } else {\n//                 newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n//               }\n//             } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1);\n\n//             thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n//           }\n//         } // Activate thumbs\n\n//         let thumbsToActivate = 1;\n//         const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n\n//         if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n//           thumbsToActivate = swiper.params.slidesPerView;\n//         }\n\n//         if (!swiper.params.thumbs.multipleActiveThumbs) {\n//           thumbsToActivate = 1;\n//         }\n\n//         thumbsToActivate = Math.floor(thumbsToActivate);\n//         thumbsSwiper.slides.removeClass(thumbActiveClass);\n\n//         if (thumbsSwiper.params.loop || (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)) {\n//           for (let i = 0; i < thumbsToActivate; i += 1) {\n//             thumbsSwiper.$wrapperEl\n//               .children(`[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`)\n//               .addClass(thumbActiveClass);\n//           }\n//         } else {\n//           for (let i = 0; i < thumbsToActivate; i += 1) {\n//             thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);\n//           }\n//         }\n//       }\n\n//       on('beforeInit', () => {\n//         const {thumbs} = swiper.params;\n//         if (!thumbs || !thumbs.swiper) return;\n//         init();\n//         update(true);\n//       });\n//       on('slideChange update resize observerUpdate', () => {\n//         if (!swiper.thumbs.swiper) return;\n//         update();\n//       });\n//       on('setTransition', (_s, duration) => {\n//         const thumbsSwiper = swiper.thumbs.swiper;\n//         if (!thumbsSwiper) return;\n//         thumbsSwiper.setTransition(duration);\n//       });\n//       on('beforeDestroy', () => {\n//         const thumbsSwiper = swiper.thumbs.swiper;\n//         if (!thumbsSwiper) return;\n\n//         if (swiperCreated && thumbsSwiper) {\n//           thumbsSwiper.destroy();\n//         }\n//       });\n//       Object.assign(swiper.thumbs, {\n//         init,\n//         update,\n//       });\n//     }\n\n//     function freeMode({swiper, extendParams, emit, once}) {\n//       extendParams({\n//         freeMode: {\n//           enabled: false,\n//           momentum: true,\n//           momentumRatio: 1,\n//           momentumBounce: true,\n//           momentumBounceRatio: 1,\n//           momentumVelocityRatio: 1,\n//           sticky: false,\n//           minimumVelocity: 0.02,\n//         },\n//       });\n\n//       function onTouchMove() {\n//         const {touchEventsData: data, touches} = swiper; // Velocity\n\n//         if (data.velocities.length === 0) {\n//           data.velocities.push({\n//             position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n//             time: data.touchStartTime,\n//           });\n//         }\n\n//         data.velocities.push({\n//           position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n//           time: now(),\n//         });\n//       }\n\n//       function onTouchEnd({currentPos}) {\n//         const {params, $wrapperEl, rtlTranslate: rtl, snapGrid, touchEventsData: data} = swiper; // Time diff\n\n//         const touchEndTime = now();\n//         const timeDiff = touchEndTime - data.touchStartTime;\n\n//         if (currentPos < -swiper.minTranslate()) {\n//           swiper.slideTo(swiper.activeIndex);\n//           return;\n//         }\n\n//         if (currentPos > -swiper.maxTranslate()) {\n//           if (swiper.slides.length < snapGrid.length) {\n//             swiper.slideTo(snapGrid.length - 1);\n//           } else {\n//             swiper.slideTo(swiper.slides.length - 1);\n//           }\n\n//           return;\n//         }\n\n//         if (params.freeMode.momentum) {\n//           if (data.velocities.length > 1) {\n//             const lastMoveEvent = data.velocities.pop();\n//             const velocityEvent = data.velocities.pop();\n//             const distance = lastMoveEvent.position - velocityEvent.position;\n//             const time = lastMoveEvent.time - velocityEvent.time;\n//             swiper.velocity = distance / time;\n//             swiper.velocity /= 2;\n\n//             if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n//               swiper.velocity = 0;\n//             } // this implies that the user stopped moving a finger then released.\n//             // There would be no events with distance zero, so the last event is stale.\n\n//             if (time > 150 || now() - lastMoveEvent.time > 300) {\n//               swiper.velocity = 0;\n//             }\n//           } else {\n//             swiper.velocity = 0;\n//           }\n\n//           swiper.velocity *= params.freeMode.momentumVelocityRatio;\n//           data.velocities.length = 0;\n//           let momentumDuration = 1000 * params.freeMode.momentumRatio;\n//           const momentumDistance = swiper.velocity * momentumDuration;\n//           let newPosition = swiper.translate + momentumDistance;\n//           if (rtl) newPosition = -newPosition;\n//           let doBounce = false;\n//           let afterBouncePosition;\n//           const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n//           let needsLoopFix;\n\n//           if (newPosition < swiper.maxTranslate()) {\n//             if (params.freeMode.momentumBounce) {\n//               if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n//                 newPosition = swiper.maxTranslate() - bounceAmount;\n//               }\n\n//               afterBouncePosition = swiper.maxTranslate();\n//               doBounce = true;\n//               data.allowMomentumBounce = true;\n//             } else {\n//               newPosition = swiper.maxTranslate();\n//             }\n\n//             if (params.loop && params.centeredSlides) needsLoopFix = true;\n//           } else if (newPosition > swiper.minTranslate()) {\n//             if (params.freeMode.momentumBounce) {\n//               if (newPosition - swiper.minTranslate() > bounceAmount) {\n//                 newPosition = swiper.minTranslate() + bounceAmount;\n//               }\n\n//               afterBouncePosition = swiper.minTranslate();\n//               doBounce = true;\n//               data.allowMomentumBounce = true;\n//             } else {\n//               newPosition = swiper.minTranslate();\n//             }\n\n//             if (params.loop && params.centeredSlides) needsLoopFix = true;\n//           } else if (params.freeMode.sticky) {\n//             let nextSlide;\n\n//             for (let j = 0; j < snapGrid.length; j += 1) {\n//               if (snapGrid[j] > -newPosition) {\n//                 nextSlide = j;\n//                 break;\n//               }\n//             }\n\n//             if (\n//               Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) ||\n//               swiper.swipeDirection === 'next'\n//             ) {\n//               newPosition = snapGrid[nextSlide];\n//             } else {\n//               newPosition = snapGrid[nextSlide - 1];\n//             }\n\n//             newPosition = -newPosition;\n//           }\n\n//           if (needsLoopFix) {\n//             once('transitionEnd', () => {\n//               swiper.loopFix();\n//             });\n//           } // Fix duration\n\n//           if (swiper.velocity !== 0) {\n//             if (rtl) {\n//               momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n//             } else {\n//               momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n//             }\n\n//             if (params.freeMode.sticky) {\n//               // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n//               // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n//               // It's easy to see this when simulating touch with mouse events. To fix this,\n//               // limit single-slide swipes to the default slide duration. This also has the\n//               // nice side effect of matching slide speed if the user stopped moving before\n//               // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n//               // For faster swipes, also apply limits (albeit higher ones).\n//               const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n//               const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n//               if (moveDistance < currentSlideSize) {\n//                 momentumDuration = params.speed;\n//               } else if (moveDistance < 2 * currentSlideSize) {\n//                 momentumDuration = params.speed * 1.5;\n//               } else {\n//                 momentumDuration = params.speed * 2.5;\n//               }\n//             }\n//           } else if (params.freeMode.sticky) {\n//             swiper.slideToClosest();\n//             return;\n//           }\n\n//           if (params.freeMode.momentumBounce && doBounce) {\n//             swiper.updateProgress(afterBouncePosition);\n//             swiper.setTransition(momentumDuration);\n//             swiper.setTranslate(newPosition);\n//             swiper.transitionStart(true, swiper.swipeDirection);\n//             swiper.animating = true;\n//             $wrapperEl.transitionEnd(() => {\n//               if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n//               emit('momentumBounce');\n//               swiper.setTransition(params.speed);\n//               setTimeout(() => {\n//                 swiper.setTranslate(afterBouncePosition);\n//                 $wrapperEl.transitionEnd(() => {\n//                   if (!swiper || swiper.destroyed) return;\n//                   swiper.transitionEnd();\n//                 });\n//               }, 0);\n//             });\n//           } else if (swiper.velocity) {\n//             emit('_freeModeNoMomentumRelease');\n//             swiper.updateProgress(newPosition);\n//             swiper.setTransition(momentumDuration);\n//             swiper.setTranslate(newPosition);\n//             swiper.transitionStart(true, swiper.swipeDirection);\n\n//             if (!swiper.animating) {\n//               swiper.animating = true;\n//               $wrapperEl.transitionEnd(() => {\n//                 if (!swiper || swiper.destroyed) return;\n//                 swiper.transitionEnd();\n//               });\n//             }\n//           } else {\n//             swiper.updateProgress(newPosition);\n//           }\n\n//           swiper.updateActiveIndex();\n//           swiper.updateSlidesClasses();\n//         } else if (params.freeMode.sticky) {\n//           swiper.slideToClosest();\n//           return;\n//         } else if (params.freeMode) {\n//           emit('_freeModeNoMomentumRelease');\n//         }\n\n//         if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n//           swiper.updateProgress();\n//           swiper.updateActiveIndex();\n//           swiper.updateSlidesClasses();\n//         }\n//       }\n\n//       Object.assign(swiper, {\n//         freeMode: {\n//           onTouchMove,\n//           onTouchEnd,\n//         },\n//       });\n//     }\n\n//     function Grid({swiper, extendParams}) {\n//       extendParams({\n//         grid: {\n//           rows: 1,\n//           fill: 'column',\n//         },\n//       });\n//       let slidesNumberEvenToRows;\n//       let slidesPerRow;\n//       let numFullColumns;\n\n//       const initSlides = (slidesLength) => {\n//         const {slidesPerView} = swiper.params;\n//         const {rows, fill} = swiper.params.grid;\n//         slidesPerRow = slidesNumberEvenToRows / rows;\n//         numFullColumns = Math.floor(slidesLength / rows);\n\n//         if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n//           slidesNumberEvenToRows = slidesLength;\n//         } else {\n//           slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n//         }\n\n//         if (slidesPerView !== 'auto' && fill === 'row') {\n//           slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n//         }\n//       };\n\n//       const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {\n//         const {slidesPerGroup, spaceBetween} = swiper.params;\n//         const {rows, fill} = swiper.params.grid; // Set slides order\n\n//         let newSlideOrderIndex;\n//         let column;\n//         let row;\n\n//         if (fill === 'row' && slidesPerGroup > 1) {\n//           const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n//           const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n//           const columnsInGroup =\n//             groupIndex === 0\n//               ? slidesPerGroup\n//               : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n//           row = Math.floor(slideIndexInGroup / columnsInGroup);\n//           column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n//           newSlideOrderIndex = column + (row * slidesNumberEvenToRows) / rows;\n//           slide.css({\n//             '-webkit-order': newSlideOrderIndex,\n//             order: newSlideOrderIndex,\n//           });\n//         } else if (fill === 'column') {\n//           column = Math.floor(i / rows);\n//           row = i - column * rows;\n\n//           if (column > numFullColumns || (column === numFullColumns && row === rows - 1)) {\n//             row += 1;\n\n//             if (row >= rows) {\n//               row = 0;\n//               column += 1;\n//             }\n//           }\n//         } else {\n//           row = Math.floor(i / slidesPerRow);\n//           column = i - row * slidesPerRow;\n//         }\n\n//         slide.css(getDirectionLabel('margin-top'), row !== 0 ? spaceBetween && `${spaceBetween}px` : '');\n//       };\n\n//       const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n//         const {spaceBetween, centeredSlides, roundLengths} = swiper.params;\n//         const {rows} = swiper.params.grid;\n//         swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n//         swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n//         swiper.$wrapperEl.css({\n//           [getDirectionLabel('width')]: `${swiper.virtualSize + spaceBetween}px`,\n//         });\n\n//         if (centeredSlides) {\n//           snapGrid.splice(0, snapGrid.length);\n//           const newSlidesGrid = [];\n\n//           for (let i = 0; i < snapGrid.length; i += 1) {\n//             let slidesGridItem = snapGrid[i];\n//             if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n//             if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n//           }\n\n//           snapGrid.push(...newSlidesGrid);\n//         }\n//       };\n\n//       swiper.grid = {\n//         initSlides,\n//         updateSlide,\n//         updateWrapperSize,\n//       };\n//     }\n\n//     function appendSlide(slides) {\n//       const swiper = this;\n//       const {$wrapperEl, params} = swiper;\n\n//       if (params.loop) {\n//         swiper.loopDestroy();\n//       }\n\n//       if (typeof slides === 'object' && 'length' in slides) {\n//         for (let i = 0; i < slides.length; i += 1) {\n//           if (slides[i]) $wrapperEl.append(slides[i]);\n//         }\n//       } else {\n//         $wrapperEl.append(slides);\n//       }\n\n//       if (params.loop) {\n//         swiper.loopCreate();\n//       }\n\n//       if (!params.observer) {\n//         swiper.update();\n//       }\n//     }\n\n//     function prependSlide(slides) {\n//       const swiper = this;\n//       const {params, $wrapperEl, activeIndex} = swiper;\n\n//       if (params.loop) {\n//         swiper.loopDestroy();\n//       }\n\n//       let newActiveIndex = activeIndex + 1;\n\n//       if (typeof slides === 'object' && 'length' in slides) {\n//         for (let i = 0; i < slides.length; i += 1) {\n//           if (slides[i]) $wrapperEl.prepend(slides[i]);\n//         }\n\n//         newActiveIndex = activeIndex + slides.length;\n//       } else {\n//         $wrapperEl.prepend(slides);\n//       }\n\n//       if (params.loop) {\n//         swiper.loopCreate();\n//       }\n\n//       if (!params.observer) {\n//         swiper.update();\n//       }\n\n//       swiper.slideTo(newActiveIndex, 0, false);\n//     }\n\n//     function addSlide(index, slides) {\n//       const swiper = this;\n//       const {$wrapperEl, params, activeIndex} = swiper;\n//       let activeIndexBuffer = activeIndex;\n\n//       if (params.loop) {\n//         activeIndexBuffer -= swiper.loopedSlides;\n//         swiper.loopDestroy();\n//         swiper.slides = $wrapperEl.children(`.${params.slideClass}`);\n//       }\n\n//       const baseLength = swiper.slides.length;\n\n//       if (index <= 0) {\n//         swiper.prependSlide(slides);\n//         return;\n//       }\n\n//       if (index >= baseLength) {\n//         swiper.appendSlide(slides);\n//         return;\n//       }\n\n//       let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n//       const slidesBuffer = [];\n\n//       for (let i = baseLength - 1; i >= index; i -= 1) {\n//         const currentSlide = swiper.slides.eq(i);\n//         currentSlide.remove();\n//         slidesBuffer.unshift(currentSlide);\n//       }\n\n//       if (typeof slides === 'object' && 'length' in slides) {\n//         for (let i = 0; i < slides.length; i += 1) {\n//           if (slides[i]) $wrapperEl.append(slides[i]);\n//         }\n\n//         newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n//       } else {\n//         $wrapperEl.append(slides);\n//       }\n\n//       for (let i = 0; i < slidesBuffer.length; i += 1) {\n//         $wrapperEl.append(slidesBuffer[i]);\n//       }\n\n//       if (params.loop) {\n//         swiper.loopCreate();\n//       }\n\n//       if (!params.observer) {\n//         swiper.update();\n//       }\n\n//       if (params.loop) {\n//         swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n//       } else {\n//         swiper.slideTo(newActiveIndex, 0, false);\n//       }\n//     }\n\n//     function removeSlide(slidesIndexes) {\n//       const swiper = this;\n//       const {params, $wrapperEl, activeIndex} = swiper;\n//       let activeIndexBuffer = activeIndex;\n\n//       if (params.loop) {\n//         activeIndexBuffer -= swiper.loopedSlides;\n//         swiper.loopDestroy();\n//         swiper.slides = $wrapperEl.children(`.${params.slideClass}`);\n//       }\n\n//       let newActiveIndex = activeIndexBuffer;\n//       let indexToRemove;\n\n//       if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n//         for (let i = 0; i < slidesIndexes.length; i += 1) {\n//           indexToRemove = slidesIndexes[i];\n//           if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n//           if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n//         }\n\n//         newActiveIndex = Math.max(newActiveIndex, 0);\n//       } else {\n//         indexToRemove = slidesIndexes;\n//         if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n//         if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n//         newActiveIndex = Math.max(newActiveIndex, 0);\n//       }\n\n//       if (params.loop) {\n//         swiper.loopCreate();\n//       }\n\n//       if (!params.observer) {\n//         swiper.update();\n//       }\n\n//       if (params.loop) {\n//         swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n//       } else {\n//         swiper.slideTo(newActiveIndex, 0, false);\n//       }\n//     }\n\n//     function removeAllSlides() {\n//       const swiper = this;\n//       const slidesIndexes = [];\n\n//       for (let i = 0; i < swiper.slides.length; i += 1) {\n//         slidesIndexes.push(i);\n//       }\n\n//       swiper.removeSlide(slidesIndexes);\n//     }\n\n//     function Manipulation({swiper}) {\n//       Object.assign(swiper, {\n//         appendSlide: appendSlide.bind(swiper),\n//         prependSlide: prependSlide.bind(swiper),\n//         addSlide: addSlide.bind(swiper),\n//         removeSlide: removeSlide.bind(swiper),\n//         removeAllSlides: removeAllSlides.bind(swiper),\n//       });\n//     }\n\n//     function effectInit(params) {\n//       const {effect, swiper, on, setTranslate, setTransition, overwriteParams, perspective} = params;\n//       on('beforeInit', () => {\n//         if (swiper.params.effect !== effect) return;\n//         swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n\n//         if (perspective && perspective()) {\n//           swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n//         }\n\n//         const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n//         Object.assign(swiper.params, overwriteParamsResult);\n//         Object.assign(swiper.originalParams, overwriteParamsResult);\n//       });\n//       on('setTranslate', () => {\n//         if (swiper.params.effect !== effect) return;\n//         setTranslate();\n//       });\n//       on('setTransition', (_s, duration) => {\n//         if (swiper.params.effect !== effect) return;\n//         setTransition(duration);\n//       });\n//     }\n\n//     function effectTarget(effectParams, $slideEl) {\n//       if (effectParams.transformEl) {\n//         return $slideEl.find(effectParams.transformEl).css({\n//           'backface-visibility': 'hidden',\n//           '-webkit-backface-visibility': 'hidden',\n//         });\n//       }\n\n//       return $slideEl;\n//     }\n\n//     function effectVirtualTransitionEnd({swiper, duration, transformEl, allSlides}) {\n//       const {slides, activeIndex, $wrapperEl} = swiper;\n\n//       if (swiper.params.virtualTranslate && duration !== 0) {\n//         let eventTriggered = false;\n//         let $transitionEndTarget;\n\n//         if (allSlides) {\n//           $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;\n//         } else {\n//           $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);\n//         }\n\n//         $transitionEndTarget.transitionEnd(() => {\n//           if (eventTriggered) return;\n//           if (!swiper || swiper.destroyed) return;\n//           eventTriggered = true;\n//           swiper.animating = false;\n//           const triggerEvents = ['webkitTransitionEnd', 'transitionend'];\n\n//           for (let i = 0; i < triggerEvents.length; i += 1) {\n//             $wrapperEl.trigger(triggerEvents[i]);\n//           }\n//         });\n//       }\n//     }\n\n//     function EffectFade({swiper, extendParams, on}) {\n//       extendParams({\n//         fadeEffect: {\n//           crossFade: false,\n//           transformEl: null,\n//         },\n//       });\n\n//       const setTranslate = () => {\n//         const {slides} = swiper;\n//         const params = swiper.params.fadeEffect;\n\n//         for (let i = 0; i < slides.length; i += 1) {\n//           const $slideEl = swiper.slides.eq(i);\n//           const offset = $slideEl[0].swiperSlideOffset;\n//           let tx = -offset;\n//           if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n//           let ty = 0;\n\n//           if (!swiper.isHorizontal()) {\n//             ty = tx;\n//             tx = 0;\n//           }\n\n//           const slideOpacity = swiper.params.fadeEffect.crossFade\n//             ? Math.max(1 - Math.abs($slideEl[0].progress), 0)\n//             : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);\n//           const $targetEl = effectTarget(params, $slideEl);\n//           $targetEl\n//             .css({\n//               opacity: slideOpacity,\n//             })\n//             .transform(`translate3d(${tx}px, ${ty}px, 0px)`);\n//         }\n//       };\n\n//       const setTransition = (duration) => {\n//         const {transformEl} = swiper.params.fadeEffect;\n//         const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n//         $transitionElements.transition(duration);\n//         effectVirtualTransitionEnd({\n//           swiper,\n//           duration,\n//           transformEl,\n//           allSlides: true,\n//         });\n//       };\n\n//       effectInit({\n//         effect: 'fade',\n//         swiper,\n//         on,\n//         setTranslate,\n//         setTransition,\n//         overwriteParams: () => ({\n//           slidesPerView: 1,\n//           slidesPerGroup: 1,\n//           watchSlidesProgress: true,\n//           spaceBetween: 0,\n//           virtualTranslate: !swiper.params.cssMode,\n//         }),\n//       });\n//     }\n\n//     function EffectCube({swiper, extendParams, on}) {\n//       extendParams({\n//         cubeEffect: {\n//           slideShadows: true,\n//           shadow: true,\n//           shadowOffset: 20,\n//           shadowScale: 0.94,\n//         },\n//       });\n\n//       const setTranslate = () => {\n//         const {\n//           $el,\n//           $wrapperEl,\n//           slides,\n//           width: swiperWidth,\n//           height: swiperHeight,\n//           rtlTranslate: rtl,\n//           size: swiperSize,\n//           browser,\n//         } = swiper;\n//         const params = swiper.params.cubeEffect;\n//         const isHorizontal = swiper.isHorizontal();\n//         const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n//         let wrapperRotate = 0;\n//         let $cubeShadowEl;\n\n//         if (params.shadow) {\n//           if (isHorizontal) {\n//             $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');\n\n//             if ($cubeShadowEl.length === 0) {\n//               $cubeShadowEl = $('<div class=\"swiper-cube-shadow\"></div>');\n//               $wrapperEl.append($cubeShadowEl);\n//             }\n\n//             $cubeShadowEl.css({\n//               height: `${swiperWidth}px`,\n//             });\n//           } else {\n//             $cubeShadowEl = $el.find('.swiper-cube-shadow');\n\n//             if ($cubeShadowEl.length === 0) {\n//               $cubeShadowEl = $('<div class=\"swiper-cube-shadow\"></div>');\n//               $el.append($cubeShadowEl);\n//             }\n//           }\n//         }\n\n//         for (let i = 0; i < slides.length; i += 1) {\n//           const $slideEl = slides.eq(i);\n//           let slideIndex = i;\n\n//           if (isVirtual) {\n//             slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);\n//           }\n\n//           let slideAngle = slideIndex * 90;\n//           let round = Math.floor(slideAngle / 360);\n\n//           if (rtl) {\n//             slideAngle = -slideAngle;\n//             round = Math.floor(-slideAngle / 360);\n//           }\n\n//           const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n//           let tx = 0;\n//           let ty = 0;\n//           let tz = 0;\n\n//           if (slideIndex % 4 === 0) {\n//             tx = -round * 4 * swiperSize;\n//             tz = 0;\n//           } else if ((slideIndex - 1) % 4 === 0) {\n//             tx = 0;\n//             tz = -round * 4 * swiperSize;\n//           } else if ((slideIndex - 2) % 4 === 0) {\n//             tx = swiperSize + round * 4 * swiperSize;\n//             tz = swiperSize;\n//           } else if ((slideIndex - 3) % 4 === 0) {\n//             tx = -swiperSize;\n//             tz = 3 * swiperSize + swiperSize * 4 * round;\n//           }\n\n//           if (rtl) {\n//             tx = -tx;\n//           }\n\n//           if (!isHorizontal) {\n//             ty = tx;\n//             tx = 0;\n//           }\n\n//           const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${\n//             isHorizontal ? slideAngle : 0\n//           }deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n\n//           if (progress <= 1 && progress > -1) {\n//             wrapperRotate = slideIndex * 90 + progress * 90;\n//             if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n//           }\n\n//           $slideEl.transform(transform);\n\n//           if (params.slideShadows) {\n//             // Set shadows\n//             let shadowBefore = isHorizontal\n//               ? $slideEl.find('.swiper-slide-shadow-left')\n//               : $slideEl.find('.swiper-slide-shadow-top');\n//             let shadowAfter = isHorizontal\n//               ? $slideEl.find('.swiper-slide-shadow-right')\n//               : $slideEl.find('.swiper-slide-shadow-bottom');\n\n//             if (shadowBefore.length === 0) {\n//               shadowBefore = $(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}\"></div>`);\n//               $slideEl.append(shadowBefore);\n//             }\n\n//             if (shadowAfter.length === 0) {\n//               shadowAfter = $(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}\"></div>`);\n//               $slideEl.append(shadowAfter);\n//             }\n\n//             if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);\n//             if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);\n//           }\n//         }\n\n//         $wrapperEl.css({\n//           '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,\n//           'transform-origin': `50% 50% -${swiperSize / 2}px`,\n//         });\n\n//         if (params.shadow) {\n//           if (isHorizontal) {\n//             $cubeShadowEl.transform(\n//               `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${\n//                 -swiperWidth / 2\n//               }px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`,\n//             );\n//           } else {\n//             const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n//             const multiplier =\n//               1.5 - (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2 + Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2);\n//             const scale1 = params.shadowScale;\n//             const scale2 = params.shadowScale / multiplier;\n//             const offset = params.shadowOffset;\n//             $cubeShadowEl.transform(\n//               `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${\n//                 -swiperHeight / 2 / scale2\n//               }px) rotateX(-90deg)`,\n//             );\n//           }\n//         }\n\n//         const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;\n//         $wrapperEl.transform(\n//           `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${\n//             swiper.isHorizontal() ? -wrapperRotate : 0\n//           }deg)`,\n//         );\n//       };\n\n//       const setTransition = (duration) => {\n//         const {$el, slides} = swiper;\n//         slides\n//           .transition(duration)\n//           .find(\n//             '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n//           )\n//           .transition(duration);\n\n//         if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n//           $el.find('.swiper-cube-shadow').transition(duration);\n//         }\n//       };\n\n//       effectInit({\n//         effect: 'cube',\n//         swiper,\n//         on,\n//         setTranslate,\n//         setTransition,\n//         perspective: () => true,\n//         overwriteParams: () => ({\n//           slidesPerView: 1,\n//           slidesPerGroup: 1,\n//           watchSlidesProgress: true,\n//           resistanceRatio: 0,\n//           spaceBetween: 0,\n//           centeredSlides: false,\n//           virtualTranslate: true,\n//         }),\n//       });\n//     }\n\n//     function createShadow(params, $slideEl, side) {\n//       const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;\n//       const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;\n//       let $shadowEl = $shadowContainer.children(`.${shadowClass}`);\n\n//       if (!$shadowEl.length) {\n//         $shadowEl = $(`<div class=\"swiper-slide-shadow${side ? `-${side}` : ''}\"></div>`);\n//         $shadowContainer.append($shadowEl);\n//       }\n\n//       return $shadowEl;\n//     }\n\n//     function EffectFlip({swiper, extendParams, on}) {\n//       extendParams({\n//         flipEffect: {\n//           slideShadows: true,\n//           limitRotation: true,\n//           transformEl: null,\n//         },\n//       });\n\n//       const setTranslate = () => {\n//         const {slides, rtlTranslate: rtl} = swiper;\n//         const params = swiper.params.flipEffect;\n\n//         for (let i = 0; i < slides.length; i += 1) {\n//           const $slideEl = slides.eq(i);\n//           let progress = $slideEl[0].progress;\n\n//           if (swiper.params.flipEffect.limitRotation) {\n//             progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n//           }\n\n//           const offset = $slideEl[0].swiperSlideOffset;\n//           const rotate = -180 * progress;\n//           let rotateY = rotate;\n//           let rotateX = 0;\n//           let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n//           let ty = 0;\n\n//           if (!swiper.isHorizontal()) {\n//             ty = tx;\n//             tx = 0;\n//             rotateX = -rotateY;\n//             rotateY = 0;\n//           } else if (rtl) {\n//             rotateY = -rotateY;\n//           }\n\n//           $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n\n//           if (params.slideShadows) {\n//             // Set shadows\n//             let shadowBefore = swiper.isHorizontal()\n//               ? $slideEl.find('.swiper-slide-shadow-left')\n//               : $slideEl.find('.swiper-slide-shadow-top');\n//             let shadowAfter = swiper.isHorizontal()\n//               ? $slideEl.find('.swiper-slide-shadow-right')\n//               : $slideEl.find('.swiper-slide-shadow-bottom');\n\n//             if (shadowBefore.length === 0) {\n//               shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');\n//             }\n\n//             if (shadowAfter.length === 0) {\n//               shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n//             }\n\n//             if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);\n//             if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);\n//           }\n\n//           const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n//           const $targetEl = effectTarget(params, $slideEl);\n//           $targetEl.transform(transform);\n//         }\n//       };\n\n//       const setTransition = (duration) => {\n//         const {transformEl} = swiper.params.flipEffect;\n//         const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n//         $transitionElements\n//           .transition(duration)\n//           .find(\n//             '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n//           )\n//           .transition(duration);\n//         effectVirtualTransitionEnd({\n//           swiper,\n//           duration,\n//           transformEl,\n//         });\n//       };\n\n//       effectInit({\n//         effect: 'flip',\n//         swiper,\n//         on,\n//         setTranslate,\n//         setTransition,\n//         perspective: () => true,\n//         overwriteParams: () => ({\n//           slidesPerView: 1,\n//           slidesPerGroup: 1,\n//           watchSlidesProgress: true,\n//           spaceBetween: 0,\n//           virtualTranslate: !swiper.params.cssMode,\n//         }),\n//       });\n//     }\n\n//     function EffectCoverflow({swiper, extendParams, on}) {\n//       extendParams({\n//         coverflowEffect: {\n//           rotate: 50,\n//           stretch: 0,\n//           depth: 100,\n//           scale: 1,\n//           modifier: 1,\n//           slideShadows: true,\n//           transformEl: null,\n//         },\n//       });\n\n//       const setTranslate = () => {\n//         const {width: swiperWidth, height: swiperHeight, slides, slidesSizesGrid} = swiper;\n//         const params = swiper.params.coverflowEffect;\n//         const isHorizontal = swiper.isHorizontal();\n//         const transform = swiper.translate;\n//         const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n//         const rotate = isHorizontal ? params.rotate : -params.rotate;\n//         const translate = params.depth; // Each slide offset from center\n\n//         for (let i = 0, length = slides.length; i < length; i += 1) {\n//           const $slideEl = slides.eq(i);\n//           const slideSize = slidesSizesGrid[i];\n//           const slideOffset = $slideEl[0].swiperSlideOffset;\n//           const offsetMultiplier = ((center - slideOffset - slideSize / 2) / slideSize) * params.modifier;\n//           let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n//           let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0\n\n//           let translateZ = -translate * Math.abs(offsetMultiplier);\n//           let stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders\n\n//           if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n//             stretch = (parseFloat(params.stretch) / 100) * slideSize;\n//           }\n\n//           let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n//           let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n//           let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values\n\n//           if (Math.abs(translateX) < 0.001) translateX = 0;\n//           if (Math.abs(translateY) < 0.001) translateY = 0;\n//           if (Math.abs(translateZ) < 0.001) translateZ = 0;\n//           if (Math.abs(rotateY) < 0.001) rotateY = 0;\n//           if (Math.abs(rotateX) < 0.001) rotateX = 0;\n//           if (Math.abs(scale) < 0.001) scale = 0;\n//           const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n//           const $targetEl = effectTarget(params, $slideEl);\n//           $targetEl.transform(slideTransform);\n//           $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n\n//           if (params.slideShadows) {\n//             // Set shadows\n//             let $shadowBeforeEl = isHorizontal\n//               ? $slideEl.find('.swiper-slide-shadow-left')\n//               : $slideEl.find('.swiper-slide-shadow-top');\n//             let $shadowAfterEl = isHorizontal\n//               ? $slideEl.find('.swiper-slide-shadow-right')\n//               : $slideEl.find('.swiper-slide-shadow-bottom');\n\n//             if ($shadowBeforeEl.length === 0) {\n//               $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? 'left' : 'top');\n//             }\n\n//             if ($shadowAfterEl.length === 0) {\n//               $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? 'right' : 'bottom');\n//             }\n\n//             if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n//             if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n//           }\n//         }\n//       };\n\n//       const setTransition = (duration) => {\n//         const {transformEl} = swiper.params.coverflowEffect;\n//         const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n//         $transitionElements\n//           .transition(duration)\n//           .find(\n//             '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',\n//           )\n//           .transition(duration);\n//       };\n\n//       effectInit({\n//         effect: 'coverflow',\n//         swiper,\n//         on,\n//         setTranslate,\n//         setTransition,\n//         perspective: () => true,\n//         overwriteParams: () => ({\n//           watchSlidesProgress: true,\n//         }),\n//       });\n//     }\n\n//     function EffectCreative({swiper, extendParams, on}) {\n//       extendParams({\n//         creativeEffect: {\n//           transformEl: null,\n//           limitProgress: 1,\n//           shadowPerProgress: false,\n//           progressMultiplier: 1,\n//           perspective: true,\n//           prev: {\n//             translate: [0, 0, 0],\n//             rotate: [0, 0, 0],\n//             opacity: 1,\n//             scale: 1,\n//           },\n//           next: {\n//             translate: [0, 0, 0],\n//             rotate: [0, 0, 0],\n//             opacity: 1,\n//             scale: 1,\n//           },\n//         },\n//       });\n\n//       const getTranslateValue = (value) => {\n//         if (typeof value === 'string') return value;\n//         return `${value}px`;\n//       };\n\n//       const setTranslate = () => {\n//         const {slides, $wrapperEl, slidesSizesGrid} = swiper;\n//         const params = swiper.params.creativeEffect;\n//         const {progressMultiplier: multiplier} = params;\n//         const isCenteredSlides = swiper.params.centeredSlides;\n\n//         if (isCenteredSlides) {\n//           const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n//           $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);\n//         }\n\n//         for (let i = 0; i < slides.length; i += 1) {\n//           const $slideEl = slides.eq(i);\n//           const slideProgress = $slideEl[0].progress;\n//           const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);\n//           let originalProgress = progress;\n\n//           if (!isCenteredSlides) {\n//             originalProgress = Math.min(\n//               Math.max($slideEl[0].originalProgress, -params.limitProgress),\n//               params.limitProgress,\n//             );\n//           }\n\n//           const offset = $slideEl[0].swiperSlideOffset;\n//           const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n//           const r = [0, 0, 0];\n//           let custom = false;\n\n//           if (!swiper.isHorizontal()) {\n//             t[1] = t[0];\n//             t[0] = 0;\n//           }\n\n//           let data = {\n//             translate: [0, 0, 0],\n//             rotate: [0, 0, 0],\n//             scale: 1,\n//             opacity: 1,\n//           };\n\n//           if (progress < 0) {\n//             data = params.next;\n//             custom = true;\n//           } else if (progress > 0) {\n//             data = params.prev;\n//             custom = true;\n//           } // set translate\n\n//           t.forEach((value, index) => {\n//             t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(\n//               progress * multiplier,\n//             )}))`;\n//           }); // set rotates\n\n//           r.forEach((value, index) => {\n//             r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n//           });\n//           $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n//           const translateString = t.join(', ');\n//           const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n//           const scaleString =\n//             originalProgress < 0\n//               ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})`\n//               : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n//           const opacityString =\n//             originalProgress < 0\n//               ? 1 + (1 - data.opacity) * originalProgress * multiplier\n//               : 1 - (1 - data.opacity) * originalProgress * multiplier;\n//           const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`; // Set shadows\n\n//           if ((custom && data.shadow) || !custom) {\n//             let $shadowEl = $slideEl.children('.swiper-slide-shadow');\n\n//             if ($shadowEl.length === 0 && data.shadow) {\n//               $shadowEl = createShadow(params, $slideEl);\n//             }\n\n//             if ($shadowEl.length) {\n//               const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n//               $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n//             }\n//           }\n\n//           const $targetEl = effectTarget(params, $slideEl);\n//           $targetEl.transform(transform).css({\n//             opacity: opacityString,\n//           });\n\n//           if (data.origin) {\n//             $targetEl.css('transform-origin', data.origin);\n//           }\n//         }\n//       };\n\n//       const setTransition = (duration) => {\n//         const {transformEl} = swiper.params.creativeEffect;\n//         const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n//         $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);\n//         effectVirtualTransitionEnd({\n//           swiper,\n//           duration,\n//           transformEl,\n//           allSlides: true,\n//         });\n//       };\n\n//       effectInit({\n//         effect: 'creative',\n//         swiper,\n//         on,\n//         setTranslate,\n//         setTransition,\n//         perspective: () => swiper.params.creativeEffect.perspective,\n//         overwriteParams: () => ({\n//           watchSlidesProgress: true,\n//           virtualTranslate: !swiper.params.cssMode,\n//         }),\n//       });\n//     }\n\n//     function EffectCards({swiper, extendParams, on}) {\n//       extendParams({\n//         cardsEffect: {\n//           slideShadows: true,\n//           transformEl: null,\n//         },\n//       });\n\n//       const setTranslate = () => {\n//         const {slides, activeIndex} = swiper;\n//         const params = swiper.params.cardsEffect;\n//         const {startTranslate, isTouched} = swiper.touchEventsData;\n//         const currentTranslate = swiper.translate;\n\n//         for (let i = 0; i < slides.length; i += 1) {\n//           const $slideEl = slides.eq(i);\n//           const slideProgress = $slideEl[0].progress;\n//           const progress = Math.min(Math.max(slideProgress, -4), 4);\n//           let offset = $slideEl[0].swiperSlideOffset;\n\n//           if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n//             swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);\n//           }\n\n//           if (swiper.params.centeredSlides && swiper.params.cssMode) {\n//             offset -= slides[0].swiperSlideOffset;\n//           }\n\n//           let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n//           let tY = 0;\n//           const tZ = -100 * Math.abs(progress);\n//           let scale = 1;\n//           let rotate = -2 * progress;\n//           let tXAdd = 8 - Math.abs(progress) * 0.75;\n//           const isSwipeToNext =\n//             (i === activeIndex || i === activeIndex - 1) &&\n//             progress > 0 &&\n//             progress < 1 &&\n//             (isTouched || swiper.params.cssMode) &&\n//             currentTranslate < startTranslate;\n//           const isSwipeToPrev =\n//             (i === activeIndex || i === activeIndex + 1) &&\n//             progress < 0 &&\n//             progress > -1 &&\n//             (isTouched || swiper.params.cssMode) &&\n//             currentTranslate > startTranslate;\n\n//           if (isSwipeToNext || isSwipeToPrev) {\n//             const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n//             rotate += -28 * progress * subProgress;\n//             scale += -0.5 * subProgress;\n//             tXAdd += 96 * subProgress;\n//             tY = `${-25 * subProgress * Math.abs(progress)}%`;\n//           }\n\n//           if (progress < 0) {\n//             // next\n//             tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;\n//           } else if (progress > 0) {\n//             // prev\n//             tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;\n//           } else {\n//             tX = `${tX}px`;\n//           }\n\n//           if (!swiper.isHorizontal()) {\n//             const prevY = tY;\n//             tY = tX;\n//             tX = prevY;\n//           }\n\n//           const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n//           const transform = `\n//       translate3d(${tX}, ${tY}, ${tZ}px)\n//       rotateZ(${rotate}deg)\n//       scale(${scaleString})\n//     `;\n\n//           if (params.slideShadows) {\n//             // Set shadows\n//             let $shadowEl = $slideEl.find('.swiper-slide-shadow');\n\n//             if ($shadowEl.length === 0) {\n//               $shadowEl = createShadow(params, $slideEl);\n//             }\n\n//             if ($shadowEl.length)\n//               $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n//           }\n\n//           $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n//           const $targetEl = effectTarget(params, $slideEl);\n//           $targetEl.transform(transform);\n//         }\n//       };\n\n//       const setTransition = (duration) => {\n//         const {transformEl} = swiper.params.cardsEffect;\n//         const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n//         $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);\n//         effectVirtualTransitionEnd({\n//           swiper,\n//           duration,\n//           transformEl,\n//         });\n//       };\n\n//       effectInit({\n//         effect: 'cards',\n//         swiper,\n//         on,\n//         setTranslate,\n//         setTransition,\n//         perspective: () => true,\n//         overwriteParams: () => ({\n//           watchSlidesProgress: true,\n//           virtualTranslate: !swiper.params.cssMode,\n//         }),\n//       });\n//     }\n\n//     // Swiper Class\n//     const modules = [\n//       Virtual,\n//       Keyboard,\n//       Mousewheel,\n//       Navigation,\n//       Pagination,\n//       Scrollbar,\n//       Parallax,\n//       Zoom,\n//       Lazy,\n//       Controller,\n//       A11y,\n//       History,\n//       HashNavigation,\n//       Autoplay,\n//       Thumb,\n//       freeMode,\n//       Grid,\n//       Manipulation,\n//       EffectFade,\n//       EffectCube,\n//       EffectFlip,\n//       EffectCoverflow,\n//       EffectCreative,\n//       EffectCards,\n//     ];\n//     Swiper.use(modules);\n\n//     global.Swiper = Swiper;\n\n//     return Swiper;\n//   });\n//   //# sourceMappingURL=swiper-bundle.js.map\n// };\n\n// export default swiper();\n"]}